;
;	COPYRIGHT (c) 1981 under BERNE and UNIVERSAL COPYRIGHT
;	LAW by DEWAR INFORMATION SYSTEMS CORPORATION.
;
;	The software described in this document is proprietary
;	to DEWAR INFORMATION SYSTEMS CORPORATION and furnished
;	to the purchaser under a license  for use on a  single
;	computer  system and can be copied (with the inclusion
;	of DEWAR INFORMATION SYSTEMS  CORPORATIONS's copyright 
;	notice) only for use in such system.
;
;	This software is the joint property of:
;
;		Steven G. Duff
;		1345-M16 Cabrillo Park Drive
;		Santa Ana, California  96701
;		(714) 541-9619
;
;		and
;
;		Robert B.K. Dewar
;		Anthony P. Mccann
;		c/o Courant Institute of Mathematical Sciences
;		221 Mercer St.
;		New York, N.Y.  USA  10022
;
;	and may not be used without permission.
	.PAGE
;
;	This is the SPITBOL prefix file containing initializing
;	assignments to support the translated interpreter.
;
;		IDENTIFICATION INFORMATION
;		--------------------------
;
		.TITLE SPITBOL - VAX MACRO SPITBOL INTERPRETER
;
;		ACCESS PATH TO MACRO DEFINITIONS
;		-------------------------------
;
		.LIBRARY	"SPITMACS"
;
		IDENT	SPITBOL,A,4
;
		.SBTTL	S P I T B O L - REVISION HISTORY
;
; V35-A4 17-AUG-1981 [SGD]:
; o Patch SGD12 in SPITV35
;
; V35-A3 08-AUG-1981 [SGD]:
; o Patch SGD11 in SPITV35
;
; V35-A2 01-AUG-1981 [SGD]:
; o Patch SGD10 in SPITV35
;
	.PAGE
		.PSECT	SPITBOL,LONG
;
;
;		CONDITIONAL ASSEMBLY SYMBOLS
;		----------------------------
;
;	Note that ALL conditional assembly symbols must be defined -
;	a zero is equivalent to a Minimal .UNDEF, any other value is
;	a .DEF .
;
	CASL==	1	;DEFINE LOWER CASE LETTERS
	CAHT==	1	;DEFINE HORIZONTAL TAB
	CAVT==	1	;DEFINE VERTICAL TAB
	CIOD==	1	;USE DEFAULT DELIMITER TO PROCESS INPUT(), OUTPUT()
	CNCI==	0	;NO REMOTE INT-STR CONVERSION (SYSCI) IT'S SLOWER!
	CNBT==	0	;LEAVE IN BATCH INITIALIZING CODE
	CNEX==	0	;EXIT() CODE
	CNLD==	0	;LOAD() CODE
	CNPF==	0	;&PROFILE CODE
	CNRA==	0	;LEAVE IN REAL ARITHMETIC
	CNSR==	0	;LEAVE IN SORT CODE
	CSAX==	1	;CALL SYSAX (CAN'T HURT)
	CSN6==	0	;PAD STMT NOS. NOT TO 6 CHARACTERS...
	CSN8==	1	;...BUT EIGHT.
	.PAGE
	.SUBTITLE S P I T B O L  -- BASIC INFORMATION
	.PAGE
;
;      GENERAL STRUCTURE
;      -----------------
;
;      THIS PROGRAM IS A TRANSLATOR FOR A VERSION OF THE SNOBOL4
;      PROGRAMMING LANGUAGE. LANGUAGE DETAILS ARE CONTAINED IN
;      THE MANUAL MACRO SPITBOL BY DEWAR AND MCCANN, TECHNICAL
;      REPORT 90, UNIVERSITY OF LEEDS 1976.  THE LANGUAGE
;      IS IDENTICAL TO THAT IMPLEMENTED BY THE BTL TRANSLATOR
;      (R. E. GRISWOLD ET AL.) WITH THE FOLLOWING EXCEPTIONS.
;
;      1)   REDEFINITION OF STANDARD SYSTEM FUNCTIONS AND
;           OPERATORS IS NOT PERMITTED.
;
;      2)   THE VALUE FUNCTION IS NOT PROVIDED.
;
;      3)   ACCESS TRACING IS PROVIDED IN ADDITION TO THE
;           OTHER STANDARD TRACE MODES.
;
;      4)   THE KEYWORD STFCOUNT IS NOT PROVIDED.
;
;      5)   THE KEYWORD FULLSCAN IS NOT PROVIDED AND ALL PATTERN
;           MATCHING TAKES PLACE IN FULLSCAN MODE (I.E. WITH NO
;           HEURISTICS APPLIED).
;
;      6)   A SERIES OF EXPRESSIONS SEPARATED BY COMMAS MAY
;           BE GROUPED WITHIN PARENTHESES TO PROVIDE A SELECTION
;           CAPABILITY. THE SEMANTICS ARE THAT THE SELECTION
;           ASSUMES THE VALUE OF THE FIRST EXPRESSION WITHIN IT
;           WHICH SUCCEEDS AS THEY ARE EVALUATED FROM THE LEFT.
;           IF NO EXPRESSION SUCCEEDS THE ENTIRE STATEMENT FAILS
;
;      7)   AN EXPLICIT PATTERN MATCHING OPERATOR IS PROVIDED.
;           THIS IS THE BINARY QUERY (SEE GIMPEL SIGPLAN OCT 74)
;
;      8)   THE ASSIGNMENT OPERATOR IS INTRODUCED AS IN THE
;           GIMPEL REFERENCE.
;
;      9)   THE EXIT FUNCTION IS PROVIDED FOR GENERATING LOAD
;           MODULES - CF. GIMPELS SITBOL.
;
;
;      THE METHOD USED IN THIS PROGRAM IS TO TRANSLATE THE
;      SOURCE CODE INTO AN INTERNAL PSEUDO-CODE (SEE FOLLOWING
;      SECTION). AN INTERPRETOR IS THEN USED TO EXECUTE THIS
;      GENERATED PSEUDO-CODE. THE NATURE OF THE SNOBOL4 LANGUAGE
;      IS SUCH THAT THE LATTER TASK IS MUCH MORE COMPLEX THAN
;      THE ACTUAL TRANSLATION PHASE. ACCORDINGLY, NEARLY ALL THE
;      CODE IN THE PROGRAM SECTION IS CONCERNED WITH THE ACTUAL
;      EXECUTION OF THE SNOBOL4 PROGRAM.
	.PAGE
;
;      INTERPRETIVE CODE FORMAT
;      ------------------------
;
;      THE INTERPRETIVE PSEUDO-CODE CONSISTS OF A SERIES OF
;      ADDRESS POINTERS. THE EXACT FORMAT OF THE CODE IS
;      DESCRIBED IN CONNECTION WITH THE CDBLK FORMAT. THE
;      PURPOSE OF THIS SECTION IS TO GIVE GENERAL INSIGHT INTO
;      THE INTERPRETIVE APPROACH INVOLVED.
;
;      THE BASIC FORM OF THE CODE IS RELATED TO REVERSE POLISH.
;      IN OTHER WORDS, THE OPERANDS PRECEDE THE OPERATORS WHICH
;      ARE ZERO ADDRESS OPERATORS. THERE ARE SOME EXCEPTIONS TO
;      THESE RULES, NOTABLY THE UNARY NOT OPERATOR AND THE
;      SELECTION CONSTRUCTION WHICH CLEARLY REQUIRE ADVANCE
;      KNOWLEDGE OF THE OPERATOR INVOLVED.
;
;      THE OPERANDS ARE MOVED TO THE TOP OF THE MAIN STACK AND
;      THE OPERATORS ARE APPLIED TO THE TOP STACK ENTRIES. LIKE
;      OTHER VERSIONS OF SPITBOL, THIS PROCESSOR DEPENDS ON
;      KNOWING WHETHER OPERANDS ARE REQUIRED BY NAME OR BY VALUE
;      AND MOVES THE APPROPRIATE OBJECT TO THE STACK. THUS NO
;      NAME/VALUE CHECKS ARE INCLUDED IN THE OPERATOR CIRCUITS.
;
;      THE ACTUAL POINTERS IN THE CODE POINT TO A BLOCK WHOSE
;      FIRST WORD IS THE ADDRESS OF THE INTERPRETOR ROUTINE
;      TO BE EXECUTED FOR THE CODE WORD.
;
;      IN THE CASE OF OPERATORS, THE POINTER IS TO A WORD WHICH
;      CONTAINS THE ADDRESS OF THE OPERATOR TO BE EXECUTED. IN
;      THE CASE OF OPERANDS SUCH AS CONSTANTS, THE POINTER IS TO
;      THE OPERAND ITSELF. ACCORDINGLY, ALL OPERANDS CONTAIN
;      A FIELD WHICH POINTS TO THE ROUTINE TO LOAD THE VALUE OF
;      THE OPERAND ONTO THE STACK. IN THE CASE OF A VARIABLE,
;      THERE ARE THREE SUCH POINTERS. ONE TO LOAD THE VALUE,
;      ONE TO STORE THE VALUE AND A THIRD TO JUMP TO THE LABEL.
;
;      THE HANDLING OF FAILURE RETURNS DESERVES SPECIAL COMMENT.
;      THE LOCATION FLPTR CONTAINS THE POINTER TO THE LOCATION
;      ON THE MAIN STACK WHICH CONTAINS THE FAILURE RETURN
;      WHICH IS IN THE FORM OF A BYTE OFFSET IN THE CURRENT
;      CODE BLOCK (CDBLK OR EXBLK). WHEN A FAILURE OCCURS, THE
;      STACK IS POPPED AS INDICATED BY THE SETTING OF FLPTR AND
;      CONTROL IS PASSED TO THE APPROPRIATE LOCATION IN THE
;      CURRENT CODE BLOCK WITH THE STACK POINTER POINTING TO THE
;      FAILURE OFFSET ON THE STACK AND FLPTR UNCHANGED.
	.PAGE
;
;      INTERNAL DATA REPRESENTATIONS
;      -----------------------------
;
;      REPRESENTATION OF VALUES
;
;      A VALUE IS REPRESENTED BY A POINTER TO A BLOCK WHICH
;      DESCRIBES THE TYPE AND PARTICULARS OF THE DATA VALUE.
;      IN GENERAL, A VARIABLE IS A LOCATION CONTAINING SUCH A
;      POINTER (ALTHOUGH IN THE CASE OF TRACE ASSOCIATIONS THIS
;      IS MODIFIED, SEE DESCRIPTION OF TRBLK).
;
;      THE FOLLOWING IS A LIST OF POSSIBLE DATATYPES SHOWING THE
;      TYPE OF BLOCK USED TO HOLD THE VALUE. THE DETAILS OF
;      EACH BLOCK FORMAT ARE GIVEN LATER.
;
;      DATATYPE              BLOCK TYPE
;      --------              ----------
;
;
;      ARRAY                 ARBLK OR VCBLK
;
;      CODE                  CDBLK
;
;      EXPRESSION            EXBLK OR SEBLK
;
;      INTEGER               ICBLK
;
;      NAME                  NMBLK
;
;      PATTERN               P0BLK OR P1BLK OR P2BLK
;
;      REAL                  RCBLK
;
;      STRING                SCBLK
;
;      TABLE                 TBBLK
;
;      PROGRAM DATATYPE      PDBLK
	.PAGE
;
;      REPRESENTATION OF VARIABLES
;      ---------------------------
;
;      DURING THE COURSE OF EVALUATING EXPRESSIONS, IT IS
;      NECESSARY TO GENERATE NAMES OF VARIABLES (FOR EXAMPLE
;      ON THE LEFT SIDE OF A BINARY EQUALS OPERATOR). THESE ARE
;      NOT TO BE CONFUSED WITH OBJECTS OF DATATYPE NAME WHICH
;      ARE IN FACT VALUES.
;
;      FROM A LOGICAL POINT OF VIEW, SUCH NAMES COULD BE SIMPLY
;      REPRESENTED BY A POINTER TO THE APPROPRIATE VALUE CELL.
;      HOWEVER IN THE CASE OF ARRAYS AND PROGRAM DEFINED
;      DATATYPES, THIS WOULD VIOLATE THE RULE THAT THERE MUST BE
;      NO POINTERS INTO THE MIDDLE OF A BLOCK IN DYNAMIC STORE.
;      ACCORDINGLY, A NAME IS ALWAYS REPRESENTED BY A BASE AND
;      OFFSET. THE BASE POINTS TO THE START OF THE BLOCK
;      CONTAINING THE VARIABLE VALUE AND THE OFFSET IS THE
;      OFFSET WITHIN THIS BLOCK IN BYTES. THUS THE ADDRESS
;      OF THE ACTUAL VARIABLE IS DETERMINED BY ADDING THE BASE
;      AND OFFSET VALUES.
;
;      THE FOLLOWING ARE THE INSTANCES OF VARIABLES REPRESENTED
;      IN THIS MANNER.
;
;      1)   NATURAL VARIABLE BASE IS PTR TO VRBLK
;                            OFFSET IS *VRVAL
;
;      2)   TABLE ELEMENT    BASE IS PTR TO TEBLK
;                            OFFSET IS *TEVAL
;
;      3)   ARRAY ELEMENT    BASE IS PTR TO ARBLK
;                            OFFSET IS OFFSET TO ELEMENT
;
;      4)   VECTOR ELEMENT   BASE IS PTR TO VCBLK
;                            OFFSET IS OFFSET TO ELEMENT
;
;      5)   PROG DEF DTP     BASE IS PTR TO PDBLK
;                            OFFSET IS OFFSET TO FIELD VALUE
;
;      IN ADDITION THERE ARE TWO CASES OF OBJECTS WHICH ARE
;      LIKE VARIABLES BUT CANNOT BE HANDLED IN THIS MANNER.
;      THESE ARE CALLED PSEUDO-VARIABLES AND ARE REPRESENTED
;      WITH A SPECIAL BASE POINTER AS FOLLOWS=
;
;      EXPRESSION VARIABLE   PTR TO EVBLK (SEE EVBLK)
;
;      KEYWORD VARIABLE      PTR TO KVBLK (SEE KVBLK)
;
;      PSEUDO-VARIABLES ARE HANDLED AS SPECIAL CASES BY THE
;      ACCESS PROCEDURE (ACESS) AND THE ASSIGNMENT PROCEDURE
;      (ASIGN). SEE THESE TWO PROCEDURES FOR DETAILS.
	.PAGE
;
;      ORGANIZATION OF DATA AREA
;      -------------------------
;
;
;      THE DATA AREA IS DIVIDED INTO TWO REGIONS.
;
;      STATIC AREA
;
;      THE STATIC AREA BUILDS UP FROM THE BOTTOM AND CONTAINS
;      DATA AREAS WHICH ARE ALLOCATED DYNAMICALLY BUT ARE NEVER
;      DELETED OR MOVED AROUND. THE MACRO-PROGRAM ITSELF
;      USES THE STATIC AREA FOR THE FOLLOWING.
;
;      1)   ALL VARIABLE BLOCKS (VRBLK).
;
;      2)   THE HASH TABLE FOR VARIABLE BLOCKS.
;
;      3)   MISCELLANEOUS BUFFERS AND WORK AREAS (SEE PROGRAM
;           INITIALIZATION SECTION).
;
;      IN ADDITION, THE SYSTEM PROCEDURES MAY USE THIS AREA FOR
;      INPUT/OUTPUT BUFFERS, EXTERNAL FUNCTIONS ETC. SPACE IN
;      THE STATIC REGION IS ALLOCATED BY CALLING PROCEDURE ALOST
;
;      THE FOLLOWING GLOBAL VARIABLES DEFINE THE CURRENT
;      LOCATION AND SIZE OF THE STATIC AREA.
;
;      STATB                 ADDRESS OF START OF STATIC AREA
;      STATE                 ADDRESS+1 OF LAST WORD IN AREA.
;
;      THE MINIMUM SIZE OF STATIC IS GIVEN APPROXIMATELY BY
;           12 + *E$HNB + *E$STS + SPACE FOR ALPHABET STRING
;           AND STANDARD PRINT BUFFER.
	.PAGE
;
;      DYNAMIC AREA
;
;      THE DYNAMIC AREA IS BUILT UPWARDS IN MEMORY AFTER THE
;      STATIC REGION. DATA IN THIS AREA MUST ALL BE IN STANDARD
;      BLOCK FORMATS SO THAT IT CAN BE PROCESSED BY THE GARBAGE
;      COLLECTOR (PROCEDURE GBCOL). GBCOL COMPACTS BLOCKS DOWN
;      IN THIS REGION AS REQUIRED BY SPACE EXHAUSTION AND CAN
;      ALSO MOVE ALL BLOCKS UP TO ALLOW FOR EXPANSION OF THE
;      STATIC REGION.
;      WITH THE EXCEPTION OF TABLES AND ARRAYS, NO SPITBOL
;      OBJECT ONCE BUILT IN DYNAMIC MEMORY IS EVER SUBSEQUENTLY
;      MODIFIED. OBSERVING THIS RULE NECESSITATES A COPYING
;      ACTION DURING STRING AND PATTERN CONCATENATION.
;
;      GARBAGE COLLECTION IS FUNDAMENTAL TO THE ALLOCATION OF
;      SPACE FOR VALUES. SPITBOL USES A VERY EFFICIENT GARBAGE
;      COLLECTOR WHICH INSISTS THAT POINTERS INTO DYNAMIC STORE
;      SHOULD BE IDENTIFIABLE WITHOUT USE OF BIT TABLES,
;      MARKER BITS ETC. TO SATISFY THIS REQUIREMENT, DYNAMIC
;      MEMORY MUST NOT START AT TOO LOW AN ADDRESS AND LENGTHS
;      OF ARRAYS, TABLES, STRINGS, CODE AND EXPRESSION BLOCKS
;      MAY NOT EXCEED THE NUMERICAL VALUE OF THE LOWEST DYNAMIC
;      ADDRESS. TO AVOID EITHER PENALIZING USERS WITH MODEST
;      REQUIREMENTS OR RESTRICTING THOSE WITH GREATER NEEDS ON
;      HOST SYSTEMS WHERE DYNAMIC MEMORY IS ALLOCATED IN LOW
;      ADDRESSES, THE MINIMUM DYNAMIC ADDRESS MAY BE SPECIFIED
;      SUFFICIENTLY HIGH TO PERMIT ARBITRARILY LARGE SPITBOL
;      OBJECTS TO BE CREATED ( WITH THE POSSIBILITY IN EXTREME
;      CASES OF WASTING LARGE AMOUNTS OF MEMORY BELOW THE
;      START ADDRESS). THIS MINIMUM VALUE IS MADE AVAILABLE
;      IN VARIABLE MXLEN BY A SYSTEM ROUTINE, SYSMX.
;      ALTERNATIVELY SYSMX MAY INDICATE THAT A
;      DEFAULT MAY BE USED IN WHICH DYNAMIC IS PLACED
;      AT THE LOWEST POSSIBLE ADDRESS FOLLOWING STATIC.
;
;      THE FOLLOWING GLOBAL WORK CELLS DEFINE THE LOCATION AND
;      LENGTH OF THE DYNAMIC AREA.
;
;      DNAMB                 START OF DYNAMIC AREA
;      DNAMP                 NEXT AVAILABLE LOCATION
;      DNAME                 LAST AVAILABLE LOCATION + 1
;
;      DNAMB IS ALWAYS HIGHER THAN STATE SINCE THE ALOST
;      PROCEDURE MAINTAINS SOME EXPANSION SPACE ABOVE STATE.
;      *** DNAMB MUST NEVER BE PERMITTED TO HAVE A VALUE LESS
;      THAN THAT IN MXLEN ***
;
;      SPACE IN THE DYNAMIC REGION IS ALLOCATED BY THE ALLOC
;      PROCEDURE. THE DYNAMIC REGION MAY BE USED BY SYSTEM
;      PROCEDURES PROVIDED THAT ALL THE RULES ARE OBEYED.
	.PAGE
;
;      REGISTER USAGE
;      --------------
;
;      (CP)                  CODE POINTER REGISTER. USED TO
;                            HOLD A POINTER TO THE CURRENT
;                            LOCATION IN THE INTERPRETIVE PSEUDO
;                            CODE (I.E. PTR INTO A CDBLK).
;
;      (XL,XR)               GENERAL INDEX REGISTERS. USUALLY
;                            USED TO HOLD POINTERS TO BLOCKS IN
;                            DYNAMIC STORAGE. AN IMPORTANT
;                            RESTRICTION IS THAT THE VALUE IN
;                            XL MUST BE COLLECTABLE FOR
;                            A GARBAGE COLLECT CALL. A VALUE
;                            IS COLLECTABLE IF IT EITHER POINTS
;                            OUTSIDE THE DYNAMIC AREA, OR IF IT
;                            POINTS TO THE START OF A BLOCK IN
;                            THE DYNAMIC AREA.
;
;      (XS)                  STACK POINTER. USED TO POINT TO
;                            THE STACK FRONT. THE STACK MAY
;                            BUILD UP OR DOWN AND IS USED
;                            TO STACK SUBROUTINE RETURN POINTS
;                            AND OTHER RECURSIVELY SAVED DATA.
;
;      (XT)                  AN ALTERNATIVE NAME FOR XL DURING
;                            ITS USE IN ACCESSING STACKED ITEMS.
;
;      (WA,WB,WC)            GENERAL WORK REGISTERS. CANNOT BE
;                            USED FOR INDEXING, BUT MAY HOLD
;                            VARIOUS TYPES OF DATA.
;
;      (IA)                  USED FOR ALL SIGNED INTEGER
;                            ARITHMETIC, BOTH THAT USED BY THE
;                            TRANSLATOR AND THAT ARISING FROM
;                            USE OF SNOBOL4 ARITHMETIC OPERATORS
;
;      (RA)                  REAL ACCUMULATOR. USED FOR ALL
;                            FLOATING POINT ARITHMETIC.
	.PAGE
;
;      SPITBOL CONDITIONAL ASSEMBLY SYMBOLS
;      ------------------------------------
;
;      IN THE SPITBOL TRANSLATOR, THE FOLLOWING CONDITIONAL
;      ASSEMBLY SYMBOLS ARE REFERRED TO. TO INCORPORATE THE
;      FEATURES REFERRED TO, THE MINIMAL SOURCE SHOULD BE
;      PREFACED BY SUITABLE CONDITIONAL ASSEMBLY SYMBOL
;      DEFINITIONS.
;      IN ALL CASES IT IS PERMISSIBLE TO DEFAULT THE DEFINITIONS
;      IN WHICH CASE THE ADDITIONAL FEATURES WILL BE OMITTED
;      FROM THE TARGET CODE.
;
;      .CASL                 DEFINE TO INCLUDE 26 SHIFTED LETTRS
;      .CAHT                 DEFINE TO INCLUDE HORIZONTAL TAB
;      .CAVT                 DEFINE TO INCLUDE VERTICAL TAB
;      .CIOD                 IF DEFINED, DEFAULT DELIMITER IS
;                            NOT USED IN PROCESSING 3RD ARG OF
;                            INPUT() AND OUTPUT()
;      .CNBT                 DEFINE TO OMIT BATCH INITIALISATION
;      .CNCI                 DEFINE TO ENABLE SYSCI ROUTINE
;      .CNEX                 DEFINE TO OMIT EXIT() CODE.
;      .CNLD                 DEFINE TO OMIT LOAD() CODE.
;      .CNPF                 DEFINE TO OMIT PROFILE STUFF
;      .CNRA                 DEFINE TO OMIT ALL REAL ARITHMETIC
;      .CNSR                 DEFINE TO OMIT SORT, RSORT
;      .CSAX                 DEFINE IF SYSAX IS TO BE CALLED
;      .CSN6                 DEFINE TO PAD STMT NOS TO 6 CHARS
;      .CSN8                 DEFINE TO PAD STMT NOS TO 8 CHARS
	.PAGE
	.SUBTITLE S P I T B O L -- PROCEDURES SECTION
;
;      THIS SECTION STARTS WITH DESCRIPTIONS OF THE OPERATING
;      SYSTEM DEPENDENT PROCEDURES WHICH ARE USED BY THE SPITBOL
;      TRANSLATOR. ALL SUCH PROCEDURES HAVE FIVE LETTER NAMES
;      BEGINNING WITH SYS. THEY ARE LISTED IN ALPHABETICAL
;      ORDER.
;      ALL PROCEDURES HAVE A  SPECIFICATION CONSISTING OF A
;      MODEL CALL, PRECEDED BY A POSSIBLY EMPTY LIST OF REGISTER
;      CONTENTS GIVING PARAMETERS AVAILABLE TO THE PROCEDURE AND
;      FOLLOWED BY A POSSIBLY EMPTY LIST OF REGISTER CONTENTS
;      REQUIRED ON RETURN FROM THE CALL OR WHICH MAY HAVE HAD
;      THEIR CONTENTS DESTROYED. ONLY THOSE REGISTERS EXPLICITLY
;      MENTIONED IN THE LIST AFTER THE CALL MAY HAVE THEIR
;      VALUES CHANGED.
;      THE SEGMENT OF CODE PROVIDING THE EXTERNAL PROCEDURES IS
;      CONVENIENTLY REFERRED TO AS OSINT (OPERATING SYSTEM
;      INTERFACE). THE SYSXX PROCEDURES IT CONTAINS PROVIDE
;      FACILITIES NOT USUALLY AVAILABLE AS PRIMITIVES IN
;      ASSEMBLY LANGUAGES. FOR PARTICULAR TARGET MACHINES,
;      IMPLEMENTORS MAY CHOOSE FOR SOME MINIMAL OPCODES WHICH
;      DO NOT HAVE REASONABLY DIRECT TRANSLATIONS, TO USE CALLS
;      OF ADDITIONAL PROCEDURES WHICH THEY PROVIDE IN OSINT.
;      E.G. MWB OR TRC MIGHT BE TRANSLATED AS JSR SYSMB,
;      JSR SYSTC IN SOME IMPLEMENTATIONS.
;
;      IN THE DESCRIPTIONS, REFERENCE IS MADE TO --BLK
;      FORMATS (-- = A PAIR OF LETTERS). SEE THE SPITBOL
;      DEFINITIONS SECTION FOR DETAILED DESCRIPTIONS OF ALL
;      SUCH BLOCK FORMATS EXCEPT FCBLK FOR WHICH SYSFC SHOULD
;      BE CONSULTED.
;
;      SECTION 0 CONTAINS INP,INR SPECIFICATIONS OF INTERNAL
;      PROCEDURES,ROUTINES. THIS GIVES A SINGLE PASS TRANSLATOR
;      INFORMATION MAKING IT EASY TO GENERATE ALTERNATIVE CALLS
;      IN THE TRANSLATION OF JSR-S FOR PROCEDURES OF DIFFERENT
;      TYPES IF THIS PROVES NECESSARY.
;
	SEC			;START OF PROCEDURES SECTION
	.IF NOT_EQUAL CSAX
	.PAGE
;
;      SYSAX -- AFTER EXECUTION
;
;
;      IF THE CONDITIONAL ASSEMBLY SYMBOL .CSAX IS DEFINED,
;      THIS ROUTINE IS CALLED IMMEDIATELY AFTER EXECUTION AND
;      BEFORE PRINTING OF EXECUTION STATISTICS OR DUMP OUTPUT.
;      PURPOSE OF CALL IS FOR IMPLEMENTOR TO DETERMINE AND
;      IF THE CALL IS NOT REQUIRED IT WILL BE OMITTED IF .CSAX
;      IS UNDEFINED. IN THIS CASE SYSAX NEED NOT BE CODED.
;
;      JSR  SYSAX            CALL AFTER EXECUTION
	.IF_FALSE
	.ENDC
	.PAGE
;
;      SYSBX -- BEFORE EXECUTION
;
;
;      CALLED AFTER INITIAL SPITBOL COMPILATION AND BEFORE
;      COMMENCING EXECUTION IN CASE OSINT NEEDS
;      TO ASSIGN FILES OR PERFORM OTHER NECESSARY SERVICES.
;      OSINT MAY ALSO CHOOSE TO SEND A MESSAGE TO ONLINE
;      TERMINAL (IF ANY) INDICATING THAT EXECUTION IS STARTING.
;
;      JSR  SYSBX            CALL BEFORE EXECUTION STARTS
	.PAGE
	.IF NOT_EQUAL CNCI
;
;      SYSCI -- CONVERT INTEGER
;
;
;      SYSCI IS AN OPTIONAL OSINT ROUTINE THAT CAUSES SPITBOL TO
;      CALL SYSCI TO CONVERT INTEGER VALUES TO STRINGS, RATHER
;      THAN USING SPITBOL'S OWN INTERNAL CONVERSION CODE.  THIS
;      CODE MAY BE LESS EFFICIENT ON MACHINES WITH HARDWARE
;      CONVERSION INSTRUCTIONS AND IN SUCH CASES, IT MAY BE AN
;      ADVANTAGE TO INCLUDE SYSCI.  THE SYMBOL .CNCI MUST BE
;      DEFINED IF THIS ROUTINE IS TO BE USED.
;
;      THE RULES FOR CONVERTING INTEGERS TO STRINGS ARE THAT
;      POSITIVE VALUES ARE REPRESENTED WITHOUT ANY SIGN, AND
;      THERE ARE NEVER ANY LEADING BLANKS OR ZEROS, EXCEPT IN
;      THE CASE OF ZERO ITSELF WHICH IS REPRESENTED AS A SINGLE
;      ZERO DIGIT.  NEGATIVE NUMBERS ARE REPRESENTED WITH A
;      PRECEEDING MINUS SIGN.  THERE ARE NEVER ANY TRAILING
;      BLANKS, AND CONVERSION CANNOT FAIL.
;
;      (IA)                  VALUE TO BE CONVERTED
;      JSR  SYSCI            CALL TO CONVERT INTEGER VALUE
;      (XL)                  POINTER TO PSEUDO-SCBLK WITH STRING
	.PAGE
	.ENDC
;
;      SYSDC -- DATE CHECK
;
;
;      SYSDC IS CALLED TO CHECK THAT THE EXPIRY DATE FOR A TRIAL
;      VERSION OF SPITBOL IS UNEXPIRED.
;
;      JSR  SYSDC            CALL TO CHECK DATE
;      RETURN ONLY IF DATE IS OK
	.PAGE
;
;      SYSDM  -- DUMP CORE
;
;
;      SYSDM IS CALLED BY A SPITBOL PROGRAM CALL OF DUMP(N) WITH
;      N GE 3.  ITS PURPOSE IS TO PROVIDE A CORE DUMP.
;      N COULD HOLD AN ENCODING OF THE START ADRS FOR DUMP AND
;      AMOUNT TO BE DUMPED E.G.  N = 256*A + S , S = START ADRS
;      IN KILOWORDS,  A = KILOWORDS TO DUMP
;
;      (XR)                  PARAMETER N OF CALL DUMP(N)
;      JSR  SYSDM            CALL TO ENTER ROUTINE
	.PAGE
;
;      SYSDT -- GET CURRENT DATE
;
;
;      SYSDT IS USED TO OBTAIN THE CURRENT DATE. THE DATE IS
;      RETURNED AS A CHARACTER STRING IN ANY FORMAT APPROPRIATE
;      TO THE OPERATING SYSTEM IN USE. IT MAY ALSO CONTAIN THE
;      CURRENT TIME OF DAY. SYSDT IS USED TO IMPLEMENT THE
;      SNOBOL4 FUNCTION DATE.
;
;      JSR  SYSDT            CALL TO GET DATE
;      (XL)                  POINTER TO BLOCK CONTAINING DATE
;
;      THE FORMAT OF THE BLOCK IS LIKE AN SCBLK EXCEPT THAT
;      THE FIRST WORD NEED NOT BE SET. THE RESULT IS COPIED
;      INTO SPITBOL DYNAMIC MEMORY ON RETURN.
	.PAGE
;
;      SYSEF -- EJECT FILE
;
;
;      SYSEF IS USED TO WRITE A PAGE EJECT TO A NAMED FILE. IT
;      MAY ONLY BE USED FOR FILES WHERE THIS CONCEPT MAKES
;      SENSE. NOTE THAT SYSEF IS NOT NORMALLY USED FOR THE
;      STANDARD OUTPUT FILE (SEE SYSEP).
;
;      (WA)                  PTR TO FCBLK OR ZERO
;      (XR)                  EJECT ARGUMENT (SCBLK PTR)
;      JSR  SYSEF            CALL TO EJECT FILE
;      PPM  LOC              RETURN HERE IF FILE DOES NOT EXIST
;      PPM  LOC              RETURN HERE IF INAPPROPRIATE FILE
;      PPM  LOC              RETURN HERE IF I/O ERROR
	.PAGE
;
;      SYSEJ -- END OF JOB
;
;
;      SYSEJ IS CALLED ONCE AT THE END OF EXECUTION TO
;      TERMINATE THE RUN. THE SIGNIFICANCE OF THE ABEND AND
;      CODE VALUES IS SYSTEM DEPENDENT. IN GENERAL, THE CODE
;      VALUE SHOULD BE MADE AVAILABLE FOR TESTING, AND THE
;      ABEND VALUE SHOULD CAUSE SOME POST-MORTEM ACTION SUCH AS
;      A DUMP. NOTE THAT SYSEJ DOES NOT RETURN TO ITS CALLER.
;      SEE SYSXI FOR DETAILS OF FCBLK CHAIN
;
;      (WA)                  VALUE OF ABEND KEYWORD
;      (WB)                  VALUE OF CODE KEYWORD
;      (XL)                  O OR PTR TO HEAD OF FCBLK CHAIN
;      JSR  SYSEJ            CALL TO END JOB
;
;      THE FOLLOWING SPECIAL VALUES ARE USED AS CODES IN (WB)
;      999  EXECUTION SUPPRESSED
;      998  STANDARD OUTPUT FILE FULL OR UNAVAILABLE IN A SYSXI
;           LOAD MODULE. IN THESE CASES (WA) CONTAINS THE NUMBER
;           OF THE STATEMENT CAUSING PREMATURE TERMINATION.
	.PAGE
;
;      SYSEM -- GET ERROR MESSAGE TEXT
;
;
;      SYSEM IS USED TO OBTAIN THE TEXT OF ERR, ERB CALLS IN THE
;      SOURCE PROGRAM GIVEN THE ERROR CODE NUMBER. IT IS ALLOWED
;      TO RETURN A NULL STRING IF THIS FACILITY IS UNAVAILABLE.
;
;      (WA)                  ERROR CODE NUMBER
;      JSR  SYSEM            CALL TO GET TEXT
;      (XR)                  TEXT OF MESSAGE
;
;      THE RETURNED VALUE IS A POINTER TO A BLOCK IN SCBLK
;      FORMAT EXCEPT THAT THE FIRST WORD NEED NOT BE SET. THE
;      STRING IS COPIED INTO DYNAMIC MEMORY ON RETURN.
;      IF THE NULL STRING IS RETURNED EITHER BECAUSE SYSEM DOES
;      NOT PROVIDE ERROR MESSAGE TEXTS OR BECAUSE WA IS OUT OF
;      RANGE, SPITBOL WILL PRINT THE STRING STORED IN ERRTEXT
;      KEYWORD.
	.PAGE
;
;      SYSEN -- ENDFILE
;
;
;      SYSEN IS USED TO IMPLEMENT THE SNOBOL4 FUNCTION ENDFILE.
;      THE MEANING IS SYSTEM DEPENDENT. IN GENERAL, ENDFILE
;      IMPLIES THAT NO FURTHER I/O OPERATIONS WILL BE PERFORMED,
;      BUT DOES NOT GUARANTEE THIS TO BE THE CASE. THE FILE
;      SHOULD BE CLOSED AFTER THE CALL, A SUBSEQUENT READ
;      OR WRITE MAY REOPEN THE FILE AT THE START OR IT MAY BE
;      NECESSARY TO REOPEN THE FILE VIA SYSIO.
;
;      (WA)                  PTR TO FCBLK OR ZERO
;      (XR)                  ENDFILE ARGUMENT (SCBLK PTR)
;      JSR  SYSEN            CALL TO ENDFILE
;      PPM  LOC              RETURN HERE IF FILE DOES NOT EXIST
;      PPM  LOC              RETURN HERE IF ENDFILE NOT ALLOWED
;      PPM  LOC              RETURN HERE IF I/O ERROR
;      (WA,WB)               DESTROYED
;
;      THE SECOND ERROR RETURN IS USED FOR FILES FOR WHICH
;      ENDFILE IS NOT PERMITTED. FOR EXAMPLE, IT MAY BE EXPECTED
;      THAT THE STANDARD INPUT AND OUTPUT FILES ARE IN THIS
;      CATEGORY.
	.PAGE
;
;      SYSEP -- EJECT PRINTER PAGE
;
;
;      SYSEP IS CALLED TO PERFORM A PAGE EJECT ON THE STANDARD
;      PRINTER OUTPUT FILE (CORRESPONDING TO SYSPR OUTPUT).
;
;      JSR  SYSEP            CALL TO EJECT PRINTER OUTPUT
	.PAGE
;
;      SYSEX -- CALL EXTERNAL FUNCTION
;
;
;      SYSEX IS CALLED TO PASS CONTROL TO AN EXTERNAL FUNCTION
;      PREVIOUSLY LOADED WITH A CALL TO SYSLD.
;
;      (XS)                  POINTER TO ARGUMENTS ON STACK
;      (XL)                  POINTER TO CONTROL BLOCK (EFBLK)
;      (WA)                  NUMBER OF ARGUMENTS ON STACK
;      JSR  SYSEX            CALL TO PASS CONTROL TO FUNCTION
;      PPM  LOC              RETURN HERE IF FUNCTION CALL FAILS
;      (XS)                  POPPED PAST ARGUMENTS
;      (XR)                  RESULT RETURNED
;
;      THE ARGUMENTS ARE STORED ON THE STACK WITH
;      THE LAST ARGUMENT AT 0(XS). ON RETURN, XS
;      IS POPPED PAST THE ARGUMENTS.
;
;      THE FORM OF THE ARGUMENTS AS PASSED IS THAT USED IN THE
;      SPITBOL TRANSLATOR (SEE DEFINITIONS AND DATA STRUCTURES
;      SECTION). THE CONTROL BLOCK FORMAT IS ALSO DESCRIBED
;      (UNDER EFBLK) IN THIS SECTION.
;
;      THERE ARE TWO WAYS OF RETURNING A RESULT.
;
;      1)   RETURN A POINTER TO A BLOCK IN DYNAMIC STORAGE. THIS
;           BLOCK MUST BE IN EXACTLY CORRECT FORMAT, INCLUDING
;           THE FIRST WORD. ONLY FUNCTIONS WRITTEN WITH INTIMATE
;           KNOWLEDGE OF THE SYSTEM WILL RETURN IN THIS WAY.
;
;      2)   STRING, INTEGER AND REAL RESULTS MAY BE RETURNED BY
;           POINTING TO A PSEUDO-BLOCK OUTSIDE DYNAMIC MEMORY.
;           THIS BLOCK IS IN ICBLK, RCBLK OR SCBLK FORMAT EXCEPT
;           THAT THE FIRST WORD WILL BE OVERWRITTEN
;           BY A TYPE WORD ON RETURN AND SO NEED NOT
;           BE CORRECTLY SET. SUCH A RESULT IS
;           COPIED INTO MAIN STORAGE BEFORE PROCEEDING.
;           UNCONVERTED RESULTS MAY SIMILARLY BE RETURNED IN A
;           PSEUDO-BLOCK WHICH IS IN CORRECT FORMAT INCLUDING
;           TYPE WORD RECOGNISABLE BY GARBAGE COLLECTOR SINCE
;           BLOCK IS COPIED INTO DYNAMIC MEMORY.
	.PAGE
;
;      SYSFC -- FILE CONTROL BLOCK ROUTINE
;
;
;      SEE ALSO SYSIO
;      INPUT AND OUTPUT HAVE 3 ARGUMENTS REFERRED TO AS SHOWN
;           INPUT(VARIABLE NAME,FILE ARG1,FILE ARG2)
;           OUTPUT(VARIABLE NAME,FILE ARG1,FILE ARG2)
;      FILE ARG1 MAY BE AN INTEGER OR STRING USED TO IDENTIFY
;      AN I/O CHANNEL. IT IS CONVERTED TO A STRING FOR CHECKING.
;      THE EXACT SIGNIFICANCE OF FILE ARG2
;      IS NOT RIGOROUSLY PRESCRIBED BUT TO IMPROVE PORTABILITY,
;      THE SCHEME DESCRIBED IN THE SPITBOL USER MANUAL
;      SHOULD BE ADOPTED WHEN POSSIBLE. THE PREFERRED FORM IS
;      A STRING $F$,R$R$,C$C$,I$I$,...,Z$Z$  WHERE
;      $F$ IS AN OPTIONAL FILE NAME WHICH IS PLACED FIRST.
;       REMAINING ITEMS MAY BE OMITTED OR INCLUDED IN ANY ORDER.
;      $R$ IS MAXIMUM RECORD LENGTH
;      $C$ IS A CARRIAGE CONTROL CHARACTER OR CHARACTER STRING
;      $I$ IS SOME FORM OF CHANNEL IDENTIFICATION USED IN THE
;         ABSENCE OF $F$ TO ASSOCIATE THE VARIABLE
;         WITH A FILE ALLOCATED DYNAMICALLY BY JCL COMMANDS AT
;         SPITBOL LOAD TIME.
;      ,...,Z$Z$ ARE ADDITIONAL FIELDS.
;      IF , (COMMA) CANNOT BE USED AS A DELIMITER, .CIOD
;      SHOULD BE DEFINED TO INTRODUCE BY CONDITIONAL ASSEMBLY
;      ANOTHER DELIMITER (SEE
;        IODEL  EQU  *
;      EARLY IN DEFINITIONS SECTION).
;      SYSFC IS CALLED WHEN A VARIABLE IS INPUT OR OUTPUT
;      ASSOCIATED TO CHECK FILE ARG1 AND FILE ARG2 AND
;      TO  REPORT WHETHER AN FCBLK (FILE CONTROL
;      BLOCK) IS NECESSARY AND IF SO WHAT SIZE IT SHOULD BE.
;      THIS MAKES IT POSSIBLE FOR SPITBOL RATHER THAN OSINT TO
;      ALLOCATE SUCH A BLOCK IN DYNAMIC MEMORY IF REQUIRED
;      OR ALTERNATIVELY IN STATIC MEMORY.
;      THE SIGNIFICANCE OF AN FCBLK , IF ONE IS REQUESTED, IS
;      ENTIRELY UP TO THE SYSTEM INTERFACE. THE ONLY RESTRICTION
;      IS THAT IF THE FCBLK SHOULD APPEAR TO LIE IN DYNAMIC
;      MEMORY , POINTERS TO IT SHOULD BE PROPER POINTERS TO
;      THE START OF A RECOGNISABLE AND GARBAGE COLLECTABLE
;      BLOCK (THIS CONDITION WILL BE MET IF SYSFC REQUESTS
;      SPITBOL TO PROVIDE AN FCBLK).
;      AN OPTION IS PROVIDED FOR OSINT TO RETURN A POINTER IN
;      XL TO AN FCBLK WHICH IT PRIVATELY ALLOCATED. THIS PTR
;      WILL BE MADE AVAILABLE WHEN I/O OCCURS LATER.
;      PRIVATE FCBLKS MAY HAVE ARBITRARY CONTENTS AND SPITBOL
;      STORES NOTHING IN THEM.
	.PAGE
;      THE REQUESTED SIZE FOR AN FCBLK IN DYNAMIC MEMORY
;      SHOULD ALLOW A 2 WORD OVERHEAD FOR BLOCK TYPE AND
;      LENGTH FIELDS. INFORMATION SUBSEQUENTLY STORED IN THE
;      REMAINING WORDS MAY BE ARBITRARY IF AN XNBLK (EXTERNAL
;      NON-RELOCATABLE BLOCK) IS REQUESTED. IF THE REQUEST IS
;      FOR AN XRBLK (EXTERNAL RELOCATABLE BLOCK) THE
;      CONTENTS OF WORDS SHOULD BE COLLECTABLE (I.E. ANY
;      APPARENT POINTERS INTO DYNAMIC SHOULD BE GENUINE BLOCK
;      POINTERS). THESE RESTRICTIONS DO NOT APPLY IF AN FCBLK
;      IS ALLOCATED OUTSIDE DYNAMIC OR IS NOT ALLOCATED AT ALL.
;      IF AN FCBLK IS REQUESTED, ITS FIELDS WILL BE INITIALISED
;      TO ZERO BEFORE ENTRY TO SYSIO WITH THE EXCEPTION OF
;      WORDS 0 AND 1 IN WHICH THE BLOCK TYPE AND LENGTH
;      FIELDS ARE PLACED FOR FCBLKS IN DYNAMIC MEMORY ONLY.
;      FOR THE POSSIBLE USE OF SYSEJ AND SYSXI, IF FCBLKS
;      ARE USED, A CHAIN IS BUILT SO THAT THEY MAY ALL BE
;      FOUND - SEE SYSXI FOR DETAILS.
;      IF BOTH FILE ARG1 AND FILE ARG2 ARE NULL, CALLS OF SYSFC
;      AND SYSIO ARE OMITTED.
;      IF FILE ARG1 IS NULL (STANDARD INPUT/OUTPUT FILE), SYSFC
;      IS CALLED TO CHECK NON-NULL FILE ARG2 BUT ANY REQUEST
;      FOR AN FCBLK WILL BE IGNORED, SINCE SPITBOL HANDLES THE
;      STANDARD FILES SPECIALLY AND CANNOT READILY KEEP FCBLK
;      POINTERS FOR THEM.
;      FILEARG1 IS TYPE CHECKED BY SPITBOL SO FURTHER CHECKING
;      MAY BE UNNECCESSARY IN MANY IMPLEMENTATIONS.
;      FILE ARG2 IS PASSED SO THAT SYSFC MAY ANALYSE AND
;      CHECK IT. HOWEVER TO ASSIST IN THIS, SPITBOL ALSO PASSES
;      ON THE STACK THE COMPONENTS OF THIS ARGUMENT WITH
;      FILE NAME, $F$ (OTHERWISE NULL) EXTRACTED AND STACKED
;      FIRST.
;      THE OTHER FIELDS, IF ANY, ARE EXTRACTED AS SUBSTRINGS,
;      POINTERS TO THEM ARE STACKED AND A COUNT OF ALL ITEMS
;      STACKED IS PLACED IN WC. IF AN FCBLK WAS EARLIER
;      ALLOCATED AND POINTED TO VIA FILE ARG1, SYSFC IS ALSO
;      PASSED A POINTER TO THIS FCBLK.
;
;      (XL)                  FILE ARG1 SCBLK PTR (2ND ARG)
;      (XR)                  FILEARG2 (3RD ARG) OR NULL
;      -(XS)...-(XS)         SCBLKS FOR $F$,$R$,$C$,...
;      (WC)                  NO. OF STACKED SCBLKS ABOVE
;      (WA)                  EXISTING FILE ARG1 FCBLK PTR OR 0
;      (WB)                  0/3 FOR INPUT/OUTPUT ASSOCN
;      JSR  SYSFC            CALL TO CHECK NEED FOR FCBLK
;      PPM  LOC              INVALID FILE ARGUMENT
;      (XS)                  POPPED (WC) TIMES
;      (WA NON ZERO)         BYTE SIZE OF REQUESTED FCBLK
;      (WA=0,XL NON ZERO)    PRIVATE FCBLK PTR IN XL
;      (WA=XL=0)             NO FCBLK WANTED, NO PRIVATE FCBLK
;      (WC)                  0/1/2 REQUEST ALLOC OF XRBLK/XNBLK
;                            /STATIC BLOCK FOR USE AS FCBLK
;      (WB)                  DESTROYED
	.PAGE
;
;      SYSHS -- GIVE ACCESS TO HOST COMPUTER FEATURES
;
;
;      PROVIDES MEANS FOR IMPLEMENTING SPECIAL FEATURES
;      ON DIFFERENT HOST COMPUTERS. THE ONLY DEFINED ENTRY IS
;      THAT WHERE ALL ARGUMENTS ARE NULL IN WHICH CASE SYSHS
;      RETURNS AN SCBLK CONTAINING NAME OF COMPUTER,
;      NAME OF OPERATING SYSTEM AND NAME OF SITE SEPARATED BY
;      COLONS. THE SCBLK NEED NOT HAVE A CORRECT FIRST FIELD
;      AS THIS IS SUPPLIED ON COPYING STRING TO DYNAMIC MEMORY.
;      SPITBOL DOES NO ARGUMENT CHECKING BUT DOES PROVIDE A
;      SINGLE ERROR RETURN FOR ARGUMENTS CHECKED AS ERRONEOUS
;      BY OSINT. IT ALSO PROVIDES A SINGLE EXECUTION ERROR
;      RETURN. IF THESE ARE INADEQUATE, USE MAY BE MADE OF THE
;      MINIMAL ERROR SECTION DIRECT AS DESCRIBED IN MINIMAL
;      DOCUMENTATION, SECTION 10.
;      SEVERAL NON-ERROR RETURNS ARE PROVIDED. THE FIRST
;      CORRESPONDS TO THE DEFINED ENTRY OR, FOR IMPLEMENTATION
;      DEFINED ENTRIES, ANY STRING MAY BE RETURNED. THE OTHERS
;      PERMIT RESPECTIVELY,  RETURN A NULL RESULT, RETURN WITH A
;      RESULT TO BE STACKED WHICH IS POINTED AT BY XR, AND A
;      RETURN CAUSING SPITBOL STATEMENT FAILURE. IF A RETURNED
;      RESULT IS IN DYNAMIC MEMORY IT MUST OBEY GARBAGE
;      COLLECTOR RULES. THE ONLY RESULTS COPIED ON RETURN
;      ARE STRINGS RETURNED VIA PPM LOC3 RETURN.
;
;      (WA)                  ARGUMENT 1
;      (XL)                  ARGUMENT 2
;      (XR)                  ARGUMENT 3
;      JSR  SYSHS            CALL TO GET HOST INFORMATION
;      PPM  LOC1             ERRONEOUS ARG
;      PPM  LOC2             EXECUTION ERROR
;      PPM  LOC3             SCBLK PTR IN XL OR 0 IF UNAVAILABLE
;      PPM  LOC4             RETURN A NULL RESULT
;      PPM  LOC5             RETURN RESULT IN XR
;      PPM  LOC6             CAUSE STATEMENT FAILURE
	.PAGE
;
;      SYSID -- RETURN SYSTEM IDENTIFICATION
;
;
;      THIS ROUTINE SHOULD RETURN STRINGS TO HEAD THE STANDARD
;      PRINTER OUTPUT. THE FIRST STRING WILL BE APPENDED TO
;      A HEADING LINE OF THE FORM
;           MACRO SPITBOL VERSION V.V
;      SUPPLIED BY SPITBOL ITSELF. V.V ARE DIGITS GIVING THE
;      MAJOR VERSION NUMBER AND GENERALLY AT LEAST A MINOR
;      VERSION NUMBER RELATING TO OSINT SHOULD BE SUPPLIED TO
;      GIVE SAY
;           MACRO SPITBOL VERSION V.V(M.M)
;      THE SECOND STRING SHOULD IDENTIFY AT LEAST THE MACHINE
;      AND OPERATING SYSTEM.  PREFERABLY IT SHOULD INCLUDE
;      THE DATE AND TIME OF THE RUN.
;      OPTIONALLY THE STRINGS MAY INCLUDE SITE NAME OF THE
;      THE IMPLEMENTOR AND/OR MACHINE ON WHICH RUN TAKES PLACE,
;      UNIQUE SITE OR COPY NUMBER AND OTHER INFORMATION AS
;      APPROPRIATE WITHOUT MAKING IT SO LONG AS TO BE A
;      NUISANCE TO USERS.
;      THE FIRST WORDS OF THE SCBLKS POINTED AT NEED NOT BE
;      CORRECTLY SET.
;
;      JSR  SYSID            CALL FOR SYSTEM IDENTIFICATION
;      (XR)                  SCBLK PTR FOR ADDITION TO HEADER
;      (XL)                  PTR TO SECOND HEADER SCBLK
	.PAGE
;
;      SYSIL -- GET INPUT RECORD LENGTH
;
;
;      SYSIL IS USED TO GET THE LENGTH OF THE NEXT INPUT RECORD
;      FROM A FILE PREVIOUSLY INPUT ASSOCIATED WITH A SYSIO
;      CALL. THE LENGTH RETURNED IS USED TO ESTABLISH A BUFFER
;      FOR A SUBSEQUENT SYSIN CALL.
;
;      (WA)                  PTR TO FCBLK OR ZERO
;      JSR  SYSIL            CALL TO GET RECORD LENGTH
;      (WA)                  LENGTH OR ZERO IF FILE CLOSED
;
;      NO HARM IS DONE IF THE VALUE RETURNED IS TOO LONG SINCE
;      UNUSED SPACE WILL BE RECLAIMED AFTER THE SYSIN CALL.
;
;      NOTE THAT IT IS THE SYSIL CALL (NOT THE SYSIO CALL) WHICH
;      CAUSES THE FILE TO BE OPENED AS REQUIRED FOR THE FIRST
;      RECORD INPUT FROM THE FILE.
	.PAGE
;
;      SYSIN -- READ INPUT RECORD
;
;
;      SYSIN IS USED TO READ A RECORD FROM THE FILE WHICH WAS
;      REFERENCED IN A PRIOR CALL TO SYSIL (I.E. THESE CALLS
;      ALWAYS OCCUR IN PAIRS). THE BUFFER PROVIDED IS AN
;      SCBLK FOR A STRING OF LENGTH SET FROM THE SYSIL CALL.
;      IF THE ACTUAL LENGTH READ IS LESS THAN THIS, THE LENGTH
;      FIELD OF THE SCBLK MUST BE MODIFIED BEFORE RETURNING
;      UNLESS BUFFER IS RIGHT PADDED WITH ZEROES.
;      IT IS ALSO PERMISSIBLE TO TAKE ANY OF THE ALTERNATIVE
;      RETURNS AFTER SCBLK LENGTH HAS BEEN MODIFIED.
;
;      (WA)                  PTR TO FCBLK OR ZERO
;      (XR)                  POINTER TO BUFFER (SCBLK PTR)
;      JSR  SYSIN            CALL TO READ RECORD
;      PPM  LOC              ENDFILE OR NO I/P FILE AFTER SYSXI
;      PPM  LOC              RETURN HERE IF I/O ERROR
;      PPM  LOC              RETURN HERE IF RECORD FORMAT ERROR
;      (WA,WB,WC)            DESTROYED
	.PAGE
;
;      SYSIO -- INPUT/OUTPUT FILE ASSOCIATION
;
;
;      SEE ALSO SYSFC.
;      SYSIO IS CALLED IN RESPONSE TO A SNOBOL4 INPUT OR OUTPUT
;      FUNCTION CALL EXCEPT WHEN FILE ARG1 AND FILE ARG2
;      ARE BOTH NULL.
;      ITS CALL ALWAYS FOLLOWS IMMEDIATELY AFTER A CALL
;      OF SYSFC. IF SYSFC REQUESTED ALLOCATION
;      OF AN FCBLK, ITS ADDRESS WILL BE IN WA.
;      FOR INPUT FILES, NON-ZERO VALUES OF $R$ SHOULD BE
;      COPIED TO WC FOR USE IN ALLOCATING INPUT BUFFERS. IF $R$
;      IS DEFAULTED OR NOT IMPLEMENTED, WC SHOULD BE ZEROISED.
;      ONCE A FILE HAS BEEN OPENED, SUBSEQUENT INPUT(),OUTPUT()
;      CALLS IN WHICH THE SECOND ARGUMENT IS IDENTICAL WITH THAT
;      IN A PREVIOUS CALL, MERELY ASSOCIATE THE ADDITIONAL
;      VARIABLE NAME (FIRST ARGUMENT) TO THE FILE AND DO NOT
;      RESULT IN RE-OPENING THE FILE.
;      IN SUBSEQUENT ASSOCIATED ACCESSES TO THE FILE A POINTER
;      TO ANY FCBLK ALLOCATED WILL BE MADE AVAILABLE.
;
;      (XL)                  FILE ARG1 SCBLK PTR (2ND ARG)
;      (XR)                  FILE ARG2 SCBLK PTR (3RD ARG)
;      (WA)                  FCBLK PTR (0 IF NONE)
;      (WB)                  0 FOR INPUT, 3 FOR OUTPUT
;      JSR  SYSIO            CALL TO ASSOCIATE FILE
;      PPM  LOC              RETURN HERE IF FILE DOES NOT EXIST
;      PPM  LOC              RETURN IF INPUT/OUTPUT NOT ALLOWED
;      (XL)                  FCBLK POINTER (0 IF NONE)
;      (WC)                  0 (FOR DEFAULT) OR MAX RECORD LNGTH
;      (WA,WB)               DESTROYED
;
;      THE SECOND ERROR RETURN IS USED IF THE FILE NAMED EXISTS
;      BUT INPUT/OUTPUT FROM THE FILE IS NOT ALLOWED. FOR
;      EXAMPLE, THE STANDARD OUTPUT FILE MAY BE IN THIS CATEGORY
;      AS REGARDS INPUT ASSOCIATION.
	.PAGE
;
;      SYSLD -- LOAD EXTERNAL FUNCTION
;
;
;      SYSLD IS CALLED IN RESPONSE TO THE USE OF THE SNOBOL4
;      LOAD FUNCTION. THE NAMED FUNCTION IS LOADED (WHATEVER
;      THIS MEANS), AND A POINTER IS RETURNED. THE POINTER WILL
;      BE USED ON SUBSEQUENT CALLS TO THE FUNCTION (SEE SYSEX).
;
;      (XR)                  POINTER TO FUNCTION NAME (SCBLK)
;      (XL)                  POINTER TO LIBRARY NAME (SCBLK)
;      JSR  SYSLD            CALL TO LOAD FUNCTION
;      PPM  LOC              RETURN HERE IF FUNC DOES NOT EXIST
;      PPM  LOC              RETURN HERE IF I/O ERROR
;      (XR)                  POINTER TO LOADED CODE
;
;      THE SIGNIFICANCE OF THE POINTER RETURNED IS UP TO THE
;      SYSTEM INTERFACE ROUTINE. THE ONLY RESTRICTION IS THAT
;      IF THE POINTER IS WITHIN DYNAMIC STORAGE, IT MUST BE
;      A PROPER BLOCK POINTER.
	.PAGE
;
;      SYSMM -- GET MORE MEMORY
;
;
;      SYSMM IS CALLED IN AN ATTEMPT TO ALLOCATE MORE DYNAMIC
;      MEMORY. THIS MEMORY MUST BE ALLOCATED CONTIGUOUSLY WITH
;      THE CURRENT DYNAMIC DATA AREA.
;
;      THE AMOUNT ALLOCATED IS UP TO THE SYSTEM TO DECIDE. ANY
;      VALUE IS ACCEPTABLE INCLUDING ZERO IF ALLOCATION IS
;      IMPOSSIBLE.
;
;      JSR  SYSMM            CALL TO GET MORE MEMORY
;      (XR)                  NUMBER OF ADDITIONAL WORDS OBTAINED
	.PAGE
;
;      SYSMX -- SUPPLY MXLEN
;
;
;      BECAUSE OF THE METHOD OF GARBAGE COLLECTION, NO SPITBOL
;      OBJECT IS ALLOWED TO OCCUPY MORE BYTES OF MEMORY THAN
;      THE INTEGER GIVING THE LOWEST ADDRESS OF DYNAMIC
;      (GARBAGE COLLECTABLE) MEMORY. MXLEN IS THE NAME USED TO
;      REFER TO THIS MAXIMUM LENGTH OF AN OBJECT AND FOR MOST
;      USERS OF MOST IMPLEMENTATIONS, PROVIDED DYNAMIC MEMORY
;      STARTS AT AN ADDRESS OF AT LEAST A FEW THOUSAND WORDS,
;      THERE IS NO PROBLEM.
;      IF THE DEFAULT STARTING ADDRESS IS LESS THAN SAY 10000 OR
;      20000, THEN A LOAD TIME OPTION SHOULD BE PROVIDED WHERE A
;      USER CAN REQUEST THAT HE BE ABLE TO CREATE LARGER
;      OBJECTS. THIS ROUTINE INFORMS SPITBOL OF THIS REQUEST IF
;      ANY. THE VALUE RETURNED IS EITHER AN INTEGER
;      REPRESENTING THE DESIRED VALUE OF MXLEN (AND HENCE THE
;      MINIMUM DYNAMIC STORE ADDRESS WHICH MAY RESULT IN
;      NON-USE OF SOME STORE) OR ZERO IF A DEFAULT IS ACCEPTABLE
;      IN WHICH MXLEN IS SET TO THE LOWEST ADDRESS ALLOCATED
;      TO DYNAMIC STORE BEFORE COMPILATION STARTS.
;      IF A NON-ZERO VALUE IS RETURNED, THIS IS USED FOR KEYWORD
;      MAXLNGTH. OTHERWISE THE INITIAL LOW ADDRESS OF DYNAMIC
;      MEMORY IS USED FOR THIS KEYWORD.
;
;      JSR  SYSMX            CALL TO GET MXLEN
;      (WA)                  EITHER MXLEN OR 0 FOR DEFAULT
	.PAGE
;
;      SYSOU -- OUTPUT RECORD
;
;
;      SYSOU IS USED TO WRITE A RECORD TO A FILE PREVIOUSLY
;      ASSOCIATED WITH A SYSIO CALL.
;
;      (WA)                  PTR TO FCBLK OR ZERO
;      (XR)                  RECORD TO BE WRITTEN (SCBLK)
;      JSR  SYSOU            CALL TO OUTPUT RECORD
;      PPM  LOC              FILE FULL OR NO FILE AFTER SYSXI
;      PPM  LOC              RETURN HERE IF I/O ERROR
;      (WA,WB,WC)            DESTROYED
;
;      NOTE THAT IT IS THE SYSOU CALL (NOT THE SYSIO CALL) WHICH
;      CAUSES THE FILE TO BE OPENED AS REQUIRED FOR THE FIRST
;      RECORD OUTPUT TO THE FILE.
	.PAGE
;
;      SYSPI -- PRINT ON INTERACTIVE CHANNEL
;
;
;      IF SPITBOL IS RUN FROM AN ONLINE TERMINAL, OSINT CAN
;      REQUEST THAT MESSAGES SUCH AS COPIES OF COMPILATION
;      ERRORS BE SENT TO THE TERMINAL (SEE SYSPP). IF RELEVANT
;      REPLY WAS MADE BY SYSPP THEN SYSPI IS CALLED TO SEND SUCH
;      MESSAGES TO THE INTERACTIVE CHANNEL.
;      SYSPI IS ALSO USED FOR SENDING OUTPUT TO THE TERMINAL
;      THROUGH THE SPECIAL VARIABLE NAME, TERMINAL.
;
;      (XR)                  PTR TO LINE BUFFER (SCBLK)
;      (WA)                  LINE LENGTH
;      JSR  SYSPI            CALL TO PRINT LINE
;      PPM  LOC              FAILURE RETURN
;      (WA,WB)               DESTROYED
	.PAGE
;
;      SYSPP -- OBTAIN PRINT PARAMETERS
;
;
;      SYSPP IS CALLED ONCE DURING COMPILATION TO OBTAIN
;      PARAMETERS REQUIRED FOR CORRECT PRINTED OUTPUT FORMAT
;      AND TO SELECT OTHER OPTIONS. IT MAY ALSO BE CALLED AGAIN
;      AFTER SYSXI WHEN A LOAD MODULE IS RESUMED. IN THIS
;      CASE THE VALUE RETURNED IN WA MAY BE LESS THAN OR EQUAL
;      TO THAT RETURNED IN INITIAL CALL BUT MAY NOT BE
;      GREATER.
;      THE INFORMATION RETURNED IS -
;      1.   LINE LENGTH IN CHARS FOR STANDARD PRINT FILE
;      2.   NO OF LINES/PAGE. 0 IS PREFERABLE FOR A NON-PAGED
;           DEVICE (E.G. ONLINE TERMINAL) IN WHICH CASE LISTING
;           PAGE THROWS ARE SUPPRESSED AND PAGE HEADERS
;           RESULTING FROM -TITLE,-STITL LINES ARE KEPT SHORT.
;      3.   AN INITIAL -NOLIST OPTION TO SUPPRESS LISTING UNLESS
;           THE PROGRAM CONTAINS AN EXPLICIT -LIST.
;      4.   OPTIONS TO SUPPRESS LISTING OF COMPILATION AND/OR
;           EXECUTION STATS (USEFUL FOR ESTABLISHED PROGRAMS) -
;           COMBINED WITH 3. GIVES POSSIBILITY OF LISTING
;           FILE NEVER BEING OPENED.
;      5.   OPTION TO HAVE COPIES OF ERRORS SENT TO AN
;           INTERACTIVE CHANNEL IN ADDITION TO STANDARD PRINTER.
;      6.   OPTION TO KEEP PAGE HEADERS SHORT (E.G. IF LISTING
;           TO AN ONLINE TERMINAL).
;      7.   AN OPTION TO CHOOSE EXTENDED OR COMPACT LISTING
;           FORMAT. IN THE FORMER A PAGE EJECT AND IN THE LATTER
;           A FEW LINE FEEDS PRECEDE THE PRINTING OF EACH
;           OF-- LISTING, COMPILATION STATISTICS, EXECUTION
;           OUTPUT AND EXECUTION STATISTICS.
;      8.   AN OPTION TO SUPPRESS EXECUTION AS THOUGH A
;           -NOEXECUTE CARD WERE SUPPLIED.
;      9.   AN OPTION TO REQUEST THAT NAME /TERMINAL/  BE PRE-
;           ASSOCIATED TO AN ONLINE TERMINAL VIA SYSPI AND SYSRI
;      10.  AN INTERMEDIATE (STANDARD) LISTING OPTION REQUIRING
;           THAT PAGE EJECTS OCCUR IN SOURCE LISTINGS. REDUNDANT
;           IF EXTENDED OPTION CHOSEN BUT PARTIALLY EXTENDS
;           COMPACT OPTION.
;      11.  OPTION TO SUPPRESS SYSID IDENTIFICATION.
;
;      JSR  SYSPP            CALL TO GET PRINT PARAMETERS
;      (WA)                  PRINT LINE LENGTH IN CHARS
;      (WB)                  NUMBER OF LINES/PAGE
;      (WC)                  BITS VALUE ...JIHGFEDCBA WHERE
;                            A = 1 TO SEND ERROR COPY TO INT.CH.
;                            B = 1 MEANS STD PRINTER IS INT. CH.
;                            C = 1 FOR -NOLIST OPTION
;                            D = 1 TO SUPPRESS COMPILN. STATS
;                            E = 1 TO SUPPRESS EXECN. STATS
;                            F = 1/0 FOR EXTNDED/COMPACT LISTING
;                            G = 1 FOR -NOEXECUTE
;                            H = 1 PRE-ASSOCIATE /TERMINAL/
;                            I = 1 FOR STANDARD LISTING OPTION.
;                            J = 1 SUPPRESSES LISTING HEADER
	.PAGE
;
;      SYSPR -- PRINT LINE ON STANDARD OUTPUT FILE
;
;
;      SYSPR IS USED TO PRINT A SINGLE LINE ON THE STANDARD
;      OUTPUT FILE.
;
;      (XR)                  POINTER TO LINE BUFFER (SCBLK)
;      (WA)                  LINE LENGTH
;      JSR  SYSPR            CALL TO PRINT LINE
;      PPM  LOC              TOO MUCH O/P OR NO FILE AFTER SYSXI
;      (WA,WB)               DESTROYED
;
;      THE BUFFER POINTED TO IS THE LENGTH OBTAINED FROM THE
;      SYSPP CALL AND IS FILLED OUT WITH TRAILING BLANKS. THE
;      VALUE IN WA IS THE ACTUAL LINE LENGTH WHICH MAY BE LESS
;      THAN THE MAXIMUM LINE LENGTH POSSIBLE. THERE IS NO SPACE
;      CONTROL ASSOCIATED WITH THE LINE, ALL LINES ARE PRINTED
;      SINGLE SPACED. NOTE THAT NULL LINES (WA=0) ARE POSSIBLE
;      IN WHICH CASE A BLANK LINE IS TO BE PRINTED.
;
;      THE ERROR EXIT IS USED FOR SYSTEMS WHICH LIMIT THE AMOUNT
;      OF PRINTED OUTPUT. IF POSSIBLE, PRINTING SHOULD BE
;      PERMITTED AFTER THIS CONDITION HAS BEEN SIGNALLED ONCE TO
;      ALLOW FOR DUMP AND OTHER DIAGNOSTIC INFORMATION.
;      ASSUMING THIS TO BE POSSIBLE, SPITBOL MAY MAKE MORE SYSPR
;      CALLS. IF THE ERROR RETURN OCCURS ANOTHER TIME, EXECUTION
;      IS TERMINATED BY A CALL OF SYSEJ WITH ENDING CODE 998.
	.PAGE
;
;      SYSRD -- READ RECORD FROM STANDARD INPUT FILE
;
;
;      SYSRD IS USED TO READ A RECORD FROM THE STANDARD INPUT
;      FILE. THE BUFFER PROVIDED IS AN SCBLK FOR A STRING THE
;      LENGTH OF WHICH IN CHARACTERS IS GIVEN IN WC, THIS
;      CORRESPONDING TO THE MAXIMUM LENGTH OF STRING WHICH
;      SPITBOL IS PREPARED TO RECEIVE. AT COMPILE TIME IT
;      CORRESPONDS TO XXX IN THE MOST RECENT -INXXX CARD
;      (DEFAULT 72) AND AT EXECUTION TIME TO THE MOST RECENT
;      ,R$R$ (RECORD LENGTH) IN THE THIRD ARG OF AN INPUT()
;      STATEMENT FOR THE STANDARD INPUT FILE (DEFAULT 80).
;      IF FEWER THAN (WC) CHARACTERS ARE READ, THE LENGTH
;      FIELD OF THE SCBLK MUST BE ADJUSTED BEFORE RETURNING
;      UNLESS THE BUFFER IS RIGHT PADDED WITH ZEROES.
;      IT IS ALSO PERMISSIBLE TO TAKE THE ALTERNATIVE RETURN
;      AFTER SUCH AN ADJUSTMENT HAS BEEN MADE.
;      SPITBOL MAY CONTINUE TO MAKE CALLS AFTER AN ENDFILE
;      RETURN SO THIS ROUTINE SHOULD BE PREPARED TO MAKE
;      REPEATED ENDFILE RETURNS.
;
;      (XR)                  POINTER TO BUFFER (SCBLK PTR)
;      (WC)                  LENGTH OF BUFFER IN CHARACTERS
;      JSR  SYSRD            CALL TO READ LINE
;      PPM  LOC              ENDFILE OR NO I/P FILE AFTER SYSXI
;      (WA,WB,WC)            DESTROYED
	.PAGE
;
;      SYSRI -- READ RECORD FROM INTERACTIVE CHANNEL
;
;
;      READS A RECORD FROM ONLINE TERMINAL FOR SPITBOL VARIABLE,
;      TERMINAL. IF ONLINE TERMINAL IS UNAVAILABLE THEN CODE THE
;      ENDFILE RETURN ONLY.
;      THE BUFFER PROVIDED IS OF LENGTH 120 CHARACTERS. SYSRI
;      SHOULD REPLACE THE COUNT IN THE SECOND WORD OF THE SCBLK
;      BY THE ACTUAL CHARACTER COUNT UNLESS BUFFER IS RIGHT
;      PADDED WITH ZEROES.
;      IT IS ALSO PERMISSIBLE TO TAKE THE ALTERNATIVE
;      RETURN AFTER ADJUSTING THE COUNT.
;      THE END OF FILE RETURN MAY BE USED IF THIS MAKES
;      SENSE ON THE TARGET MACHINE (E.G. IF THERE IS AN
;      EOF CHARACTER.)
;
;      (XR)                  PTR TO 120 CHAR BUFFER (SCBLK PTR)
;      JSR  SYSRI            CALL TO READ LINE FROM TERMINAL
;      PPM  LOC              END OF FILE RETURN
;      (WA,WB,WC)            MAY BE DESTROYED
	.PAGE
;
;      SYSRW -- REWIND FILE
;
;
;      SYSRW IS USED TO REWIND A FILE I.E. REPOSITION THE FILE
;      AT THE START BEFORE THE FIRST RECORD. THE FILE SHOULD BE
;      CLOSED AND THE NEXT READ OR WRITE CALL WILL OPEN THE
;      FILE AT THE START.
;
;      (WA)                  PTR TO FCBLK OR ZERO
;      (XR)                  REWIND ARG (SCBLK PTR)
;      JSR  SYSRW            CALL TO REWIND FILE
;      PPM  LOC              RETURN HERE IF FILE DOES NOT EXIST
;      PPM  LOC              RETURN HERE IF REWIND NOT ALLOWED
;      PPM  LOC              RETURN HERE IF I/O ERROR
	.PAGE
;
;      SYSTM -- GET EXECUTION TIME SO FAR
;
;
;      SYSTM IS USED TO OBTAIN THE AMOUNT OF EXECUTION TIME
;      USED SO FAR SINCE SPITBOL WAS GIVEN CONTROL. THE UNITS
;      ARE DESCRIBED AS MILLISECONDS IN THE SPITBOL OUTPUT, BUT
;      THE EXACT MEANING IS SYSTEM DEPENDENT. WHERE APPROPRIATE,
;      THIS VALUE SHOULD RELATE TO PROCESSOR RATHER THAN CLOCK
;      TIMING VALUES.
;
;      JSR  SYSTM            CALL TO GET TIMER VALUE
;      (IA)                  TIME SO FAR IN MILLISECONDS
	.PAGE
;
;      SYSTT -- TRACE TOGGLE
;
;
;      CALLED BY SPITBOL FUNCTION TRACE() WITH NO ARGS TO
;      TOGGLE THE SYSTEM TRACE SWITCH.  THIS PERMITS TRACING OF
;      LABELS IN SPITBOL CODE TO BE TURNED ON OR OFF.
;
;      JSR  SYSTT            CALL TO TOGGLE TRACE SWITCH
	.PAGE
;
;      SYSUL -- UNLOAD EXTERNAL FUNCTION
;
;
;      SYSUL IS USED TO UNLOAD A FUNCTION PREVIOUSLY
;      LOADED WITH A CALL TO SYSLD.
;
;      (XR)                  PTR TO CONTROL BLOCK (EFBLK)
;      JSR  SYSUL            CALL TO UNLOAD FUNCTION
;
;      THE FUNCTION CANNOT BE CALLED FOLLOWING A SYSUL CALL
;      UNTIL ANOTHER SYSLD CALL IS MADE FOR THE SAME FUNCTION.
;
;      THE EFBLK CONTAINS THE FUNCTION CODE POINTER AND ALSO A
;      POINTER TO THE VRBLK CONTAINING THE FUNCTION NAME (SEE
;      DEFINITIONS AND DATA STRUCTURES SECTION).
	.IF NOT_EQUAL CNEX
	.IF_FALSE
	.PAGE
;
;      SYSXI -- EXIT TO PRODUCE LOAD MODULE
;
;
;      WHEN SYSXI IS CALLED, XL CONTAINS EITHER A STRING POINTER
;      OR ZERO. IN THE FORMER CASE, THE STRING GIVES THE
;      CHARACTER NAME OF A PROGRAM. THE INTENTION IS THAT
;      SPITBOL EXECUTION SHOULD BE TERMINATED FORTHWITH AND
;      THE NAMED PROGRAM LOADED AND EXECUTED. THIS TYPE OF CHAIN
;      EXECUTION IS VERY SYSTEM DEPENDENT AND IMPLEMENTORS MAY
;      CHOOSE TO OMIT IT OR FIND IT IMPOSSIBLE TO PROVIDE.
;      IF (XL) IS ZERO,IA CONTAINS ONE OF THE FOLLOWING INTEGERS
;
;      -1, -2, -3
;           CREATE IF POSSIBLE A LOAD MODULE CONTAINING ONLY THE
;           IMPURE AREA OF MEMORY WHICH NEEDS TO BE LOADED WITH
;           A COMPATIBLE PURE SEGMENT FOR SUBSEQUENT EXECUTIONS.
;           VERSION NUMBERS TO CHECK COMPATIBILITY SHOULD BE
;           KEPT IN BOTH SEGMENTS AND CHECKED ON LOADING.
;           TO ASSIST WITH THIS CHECK, (XR) ON ENTRY IS A
;           POINTER TO AN SCBLK CONTAINING THE SPITBOL MAJOR
;           VERSION NUMBER V.V (SEE SYSID).
;
;      0    IF POSSIBLE, RETURN CONTROL TO JOB CONTROL
;           COMMAND LEVEL. THE EFFECT IF AVAILABLE WILL BE
;           SYSTEM DEPENDENT.
;
;      +1, +2, +3
;           CREATE IF POSSIBLE A LOAD MODULE FROM ALL OF
;           MEMORY. IT SHOULD BE POSSIBLE TO LOAD AND EXECUTE
;           THIS MODULE DIRECTLY.
;
;      IN THE CASE OF SAVED LOAD MODULES, THE STATUS OF OPEN
;      FILES IS NOT PRESERVED AND IMPLEMENTORS MAY CHOOSE TO
;      OFFER MEANS OF ATTACHING FILES BEFORE EXECUTION OF LOAD
;      MODULES STARTS OR LEAVE IT TO THE USER TO INCLUDE
;      SUITABLE INPUT(), OUTPUT() CALLS IN HIS PROGRAM.
;      SYSXI SHOULD MAKE A NOTE THAT NO I/O CHANNELS,
;      INCLUDING STANDARD FILES, HAVE FILES ATTACHED SO THAT
;      CALLS OF SYSIN, SYSOU, SYSPR, SYSRD SHOULD FAIL UNLESS
;      NEW ASSOCIATIONS ARE MADE FOR THE LOAD MODULE.
;      AT LEAST IN THE CASE OF THE STANDARD OUTPUT FILE, IT IS
;      RECOMMENDED THAT EITHER THE USER BE REQUIRED TO ATTACH
;      A FILE OR THAT A DEFAULT FILE IS ATTACHED, SINCE THE
;      PROBLEM OF ERROR MESSAGES GENERATED BY THE LOAD MODULE
;      IS OTHERWISE SEVERE. AS A LAST RESORT, IF SPITBOL
;      ATTEMPTS TO WRITE TO THE STANDARD OUTPUT FILE AND GETS A
;      REPLY INDICATING THAT SUCH OUPUT IS UNACCEPTABLE IT STOPS
;      BY USING AN ENTRY TO SYSEJ WITH ENDING CODE 998.
;      AS DESCRIBED BELOW, PASSING OF SOME ARGUMENTS MAKES IT
;      CLEAR THAT LOAD MODULE WILL USE A STANDARD OUTPUT FILE.
;
;      IF USE IS MADE OF FCBLKS FOR I/O ASSOCIATION, SPITBOL
;      BUILDS A CHAIN SO THAT THOSE IN USE MAY BE FOUND IN SYSXI
;      AND SYSEJ. THE NODES ARE 4 WORDS LONG. THIRD WORD
;      CONTAINS LINK TO NEXT NODE OR 0, FOURTH WORD CONTAINS
;      FCBLK POINTER.
	.PAGE
;
;      SYSXI (CONTINUED)
;
;      (XL)                  ZERO OR SCBLK PTR
;      (XR)                  PTR TO V.V SCBLK
;      (IA)                  SIGNED INTEGER ARGUMENT
;      (WB)                  0 OR PTR TO HEAD OF FCBLK CHAIN
;      JSR  SYSXI            CALL TO EXIT
;      PPM  LOC              REQUESTED ACTION NOT POSSIBLE
;      PPM  LOC              ACTION CAUSED IRRECOVERABLE ERROR
;      (REGISTERS)           SHOULD BE PRESERVED OVER CALL
;
;      LOADING AND RUNNING THE LOAD MODULE OR RETURNING FROM
;      JCL COMMAND LEVEL CAUSES EXECUTION TO RESUME AT THE POINT
;      AFTER THE ERROR RETURNS WHICH FOLLOW THE CALL OF SYSXI.
;      THE VALUE PASSED AS EXIT ARGUMENT IS USED TO INDICATE
;      OPTIONS REQUIRED ON RESUMPTION OF LOAD MODULE.
;      +1 OR -1 REQUIRE THAT ON RESUMPTION, SYSID AND SYSPP BE
;      CALLED AND A HEADING PRINTED ON THE STANDARD OUTPUT FILE.
;      +2 OR -2 INDICATE THAT SYSPP WILL BE CALLED BUT NOT SYSID
;      AND NO HEADING WILL BE PUT ON STANDARD OUTPUT FILE.
;      ABOVE OPTIONS HAVE THE OBVIOUS IMPLICATION THAT A
;      STANDARD O/P FILE MUST BE PROVIDED FOR THE LOAD MODULE.
;      +3 OR -3 INDICATE CALLS OF NEITHER SYSID NOR SYSPP
;      AND NO HEADING WILL BE PLACED ON STANDARD OUTPUT FILE.
;      NO RETURN FROM SYSXI IS POSSIBLE IF ANOTHER PROGRAM
;      IS LOADED AND ENTERED.
	.ENDC
	.PAGE
;
;      INTRODUCE THE INTERNAL PROCEDURES.
;
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	.ENDC
	.PAGE
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	.ENDC
	.IF NOT_EQUAL CNPF
	.IF_FALSE
	.ENDC
	.PAGE
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	.ENDC
	.IF NOT_EQUAL CNSR
	.IF_FALSE
	.ENDC
;
;      INTRODUCE THE INTERNAL ROUTINES
;
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	.ENDC
	.PAGE
	.SUBTITLE S P I T B O L -- DEFINITIONS AND DATA STRUCTURES
;      (C) COPYRIGHT - ROBERT B.K.DEWAR
;      CIMS, 251 MERCER ST, NEW YORK, NY 10012, USA.
;      NEGOTIATE WITH THE ABOVE TO USE THIS SOFTWARE.
;
;      THIS SECTION CONTAINS ALL SYMBOL DEFINITIONS AND ALSO
;      PICTURES OF ALL DATA STRUCTURES USED IN THE SYSTEM.
;
	SEC			;START OF DEFINITIONS SECTION
;
;      DEFINITIONS OF MACHINE PARAMETERS
;
;      THE MINIMAL TRANSLATOR SHOULD SUPPLY APPROPRIATE VALUES
;      FOR THE PARTICULAR TARGET MACHINE FOR ALL THE
;      EQU  *
;      DEFINITIONS GIVEN AT THE START OF THIS SECTION.
;
	CFP$A==	256		;NUMBER OF CHARACTERS IN ALPHABET
;
	CFP$B==	4		;BYTES/WORD ADDRESSING FACTOR
;
	CFP$C==	4		;NUMBER OF CHARACTERS PER WORD
;
	CFP$F==	8		;OFFSET IN BYTES TO CHARS IN
;                            SCBLK. SEE SCBLK FORMAT.
;
	CFP$I==	1		;NUMBER OF WORDS IN INTEGER CONSTANT
;
	CFP$M==	^X7FFFFFFF	;MAX POSITIVE INTEGER IN ONE WORD
;
	CFP$N==	32		;NUMBER OF BITS IN ONE WORD
;
;      THE FOLLOWING DEFINITIONS REQUIRE THE SUPPLY OF EITHER
;      A SINGLE PARAMETER IF REAL ARITHMETIC IS OMITTED OR
;      THREE PARAMETERS IF REAL ARITHMETIC IS INCLUDED.
;
	.IF NOT_EQUAL CNRA
	NSTMX==	10		;NO. OF DECIMAL DIGITS IN CFP$M
	.IF_FALSE
;
	CFP$R==	1		;NUMBER OF WORDS IN REAL CONSTANT
;
	CFP$S==	6		;NUMBER OF SIG DIGS FOR REAL OUTPUT
;
	CFP$X==	2		;MAX DIGITS IN REAL EXPONENT
;
	MXDGS==	CFP$S+CFP$X	;MAX DIGITS IN REAL NUMBER
;
	NSTMX==	MXDGS+5	;MAX SPACE FOR REAL (FOR +0.E+)
	.ENDC
	.PAGE
;
;      ENVIRONMENT PARAMETERS
;
;      THE SPITBOL PROGRAM IS ESSENTIALLY INDEPENDENT OF
;      THE DEFINITIONS OF THESE PARAMETERS. HOWEVER, THE
;      EFFICIENCY OF THE SYSTEM MAY BE AFFECTED. CONSEQUENTLY,
;      THESE PARAMETERS MAY REQUIRE TUNING FOR A GIVEN VERSION
;      THE VALUES GIVEN IN COMMENTS HAVE BEEN SUCCESSFULLY USED.
;
;      E$SRS IS THE NUMBER OF WORDS TO RESERVE AT THE END OF
;      STORAGE FOR END OF RUN PROCESSING. IT SHOULD BE
;      SET AS SMALL AS POSSIBLE WITHOUT CAUSING MEMORY OVERFLOW
;      IN CRITICAL SITUATIONS (E.G. MEMORY OVERFLOW TERMINATION)
;      AND SHOULD THUS RESERVE SUFFICIENT SPACE AT LEAST FOR
;      AN SCBLK CONTAINING SAY 30 CHARACTERS.
;
	E$SRS==	50		;30 WORDS
;
;      E$STS IS THE NUMBER OF WORDS GRABBED IN A CHUNK WHEN
;      STORAGE IS ALLOCATED IN THE STATIC REGION. THE MINIMUM
;      PERMITTED VALUE IS 256/CFP$B. LARGER VALUES WILL LEAD
;      TO INCREASED EFFICIENCY AT THE COST OF WASTING MEMORY.
;
	E$STS==	512		;500 WORDS
;
;      E$CBS IS THE SIZE OF CODE BLOCK ALLOCATED INITIALLY AND
;      THE EXPANSION INCREMENT IF OVERFLOW OCCURS. IF THIS VALUE
;      IS TOO SMALL OR TOO LARGE, EXCESSIVE GARBAGE COLLECTIONS
;      WILL OCCUR DURING COMPILATION AND MEMORY MAY BE LOST
;      IN THE CASE OF A TOO LARGE VALUE.
;
	E$CBS==	512		;500 WORDS
;
;      E$HNB IS THE NUMBER OF BUCKET HEADERS IN THE VARIABLE
;      HASH TABLE. IT SHOULD ALWAYS BE ODD. LARGER VALUES WILL
;      SPEED UP COMPILATION AND INDIRECT REFERENCES AT THE
;      EXPENSE OF ADDITIONAL STORAGE FOR THE HASH TABLE ITSELF.
;
	E$HNB==	253		;127 BUCKET HEADERS
;
;      E$HNW IS THE MAXIMUM NUMBER OF WORDS OF A STRING
;      NAME WHICH PARTICIPATE IN THE STRING HASH ALGORITHM.
;      LARGER VALUES GIVE A BETTER HASH AT THE EXPENSE OF TAKING
;      LONGER TO COMPUTE THE HASH. THERE IS SOME OPTIMAL VALUE.
;
	E$HNW==	3		;6 WORDS
;
;      E$FSP .  IF THE AMOUNT OF FREE SPACE LEFT AFTER A GARBAGE
;      COLLECTION IS SMALL COMPARED TO THE TOTAL AMOUNT OF SPACE
;      IN USE GARBAGE COLLECTOR THRASHING IS LIKELY TO OCCUR AS
;      THIS SPACE IS USED UP.  E$FSP IS A MEASURE OF THE
;      MINIMUM PERCENTAGE OF DYNAMIC MEMORY LEFT AS FREE SPACE
;      BEFORE THE SYSTEM ROUTINE SYSMM IS CALLED TO TRY TO
;      OBTAIN MORE MEMORY.
;
	E$FSP==	20		;15 PERCENT
	.PAGE
;
;      DEFINITIONS OF CODES FOR LETTERS
;
	CH$LA==	065		;LETTER A
	CH$LB==	066		;LETTER B
	CH$LC==	067		;LETTER C
	CH$LD==	068		;LETTER D
	CH$LE==	069		;LETTER E
	CH$LF==	070		;LETTER F
	CH$LG==	071		;LETTER G
	CH$LH==	072		;LETTER H
	CH$LI==	073		;LETTER I
	CH$LJ==	074		;LETTER J
	CH$LK==	075		;LETTER K
	CH$LL==	076		;LETTER L
	CH$LM==	077		;LETTER M
	CH$LN==	078		;LETTER N
	CH$LO==	079		;LETTER O
	CH$LP==	080		;LETTER P
	CH$LQ==	081		;LETTER Q
	CH$LR==	082		;LETTER R
	CH$LS==	083		;LETTER S
	CH$LT==	084		;LETTER T
	CH$LU==	085		;LETTER U
	CH$LV==	086		;LETTER V
	CH$LW==	087		;LETTER W
	CH$LX==	088		;LETTER X
	CH$LY==	089		;LETTER Y
	CH$L$==	090		;LETTER Z
;
;      DEFINITIONS OF CODES FOR DIGITS
;
	CH$D0==	048		;DIGIT 0
	CH$D1==	049		;DIGIT 1
	CH$D2==	050		;DIGIT 2
	CH$D3==	051		;DIGIT 3
	CH$D4==	052		;DIGIT 4
	CH$D5==	053		;DIGIT 5
	CH$D6==	054		;DIGIT 6
	CH$D7==	055		;DIGIT 7
	CH$D8==	056		;DIGIT 8
	CH$D9==	057		;DIGIT 9
	.PAGE
;
;      DEFINITIONS OF CODES FOR SPECIAL CHARACTERS
;
;      THE NAMES OF THESE CHARACTERS ARE RELATED TO THEIR
;      ORIGINAL REPRESENTATION IN THE EBCDIC SET CORRESPONDING
;      TO THE DESCRIPTION IN STANDARD SNOBOL4 MANUALS AND TEXTS.
;
	CH$AM==	038		;KEYWORD OPERATOR (AMPERSAND)
	CH$AS==	042		;MULTIPLICATION SYMBOL (ASTERISK)
	CH$AT==	064		;CURSOR POSITION OPERATOR (AT)
	CH$BB==	060		;LEFT ARRAY BRACKET (LESS THAN)
	CH$BL==	032		;BLANK
	CH$BR==	124		;ALTERNATION OPERATOR (VERTICAL BAR)
	CH$CL==	058		;GOTO SYMBOL (COLON)
	CH$CM==	044		;COMMA
	CH$DL==	036		;INDIRECTION OPERATOR (DOLLAR)
	CH$DT==	046		;NAME OPERATOR (DOT)
	CH$DQ==	034		;DOUBLE QUOTE
	CH$EQ==	061		;EQUAL SIGN
	CH$EX==	033		;EXPONENTIATION OPERATOR (EXCLM)
	CH$MN==	045		;MINUS SIGN
	CH$NM==	035		;NUMBER SIGN
	CH$NT==	126		;NEGATION OPERATOR (NOT)
	CH$PC==	037		;PERCENT
	CH$PL==	043		;PLUS SIGN
	CH$PP==	040		;LEFT PARENTHESIS
	CH$RB==	062		;RIGHT ARRAY BRACKET (GRTR THAN)
	CH$RP==	041		;RIGHT PARENTHESIS
	CH$QU==	063		;INTERROGATION OPERATOR (QUESTION)
	CH$SL==	047		;SLASH
	CH$SM==	059		;SEMICOLON
	CH$SQ==	039		;SINGLE QUOTE
	CH$UN==	095		;SPECIAL IDENTIFIER CHAR (UNDERLINE)
	CH$OB==	091		;OPENING BRACKET
	CH$CB==	093		;CLOSING BRACKET
	.PAGE
;
;      REMAINING CHARS ARE OPTIONAL ADDITIONS TO THE STANDARDS.
	.IF NOT_EQUAL CAHT
;
;      TAB CHARACTERS - SYNTACTICALLY EQUIVALENT TO BLANK
;
	CH$HT==	009		;HORIZONTAL TAB
	.ENDC
	.IF NOT_EQUAL CAVT
	CH$VT==	012		;VERTICAL TAB
	.ENDC
	.IF NOT_EQUAL CASL
;
;      LOWER CASE OR SHIFTED CASE ALPHABETIC CHARS
;
	CH$$A==	097		;SHIFTED A
	CH$$B==	098		;SHIFTED B
	CH$$C==	099		;SHIFTED C
	CH$$D==	100		;SHIFTED D
	CH$$E==	101		;SHIFTED E
	CH$$F==	102		;SHIFTED F
	CH$$G==	103		;SHIFTED G
	CH$$H==	104		;SHIFTED H
	CH$$I==	105		;SHIFTED I
	CH$$J==	106		;SHIFTED J
	CH$$K==	107		;SHIFTED K
	CH$$L==	108		;SHIFTED L
	CH$$M==	109		;SHIFTED M
	CH$$N==	110		;SHIFTED N
	CH$$O==	111		;SHIFTED O
	CH$$P==	112		;SHIFTED P
	CH$$Q==	113		;SHIFTED Q
	CH$$R==	114		;SHIFTED R
	CH$$S==	115		;SHIFTED S
	CH$$T==	116		;SHIFTED T
	CH$$U==	117		;SHIFTED U
	CH$$V==	118		;SHIFTED V
	CH$$W==	119		;SHIFTED W
	CH$$X==	120		;SHIFTED X
	CH$$Y==	121		;SHIFTED Y
	CH$$$==	122		;SHIFTED Z
	.ENDC
;      IF A DELIMITER OTHER THAN CH$CM MUST BE USED IN
;      THE THIRD ARGUMENT OF INPUT(),OUTPUT() THEN .CIOD SHOULD
;      BE DEFINED AND A PARAMETER SUPPLIED FOR IODEL.
;
	.IF NOT_EQUAL CIOD
	IODEL==	047
	.IF_FALSE
	IODEL==	CH$CM
	.ENDC
	.PAGE
;
;      DATA BLOCK FORMATS AND DEFINITIONS
;
;      THE FOLLOWING SECTIONS DESCRIBE THE DETAILED FORMAT OF
;      ALL POSSIBLE DATA BLOCKS IN STATIC AND DYNAMIC MEMORY.
;
;      EVERY BLOCK HAS A NAME OF THE FORM XXBLK WHERE XX IS A
;      UNIQUE TWO CHARACTER IDENTIFIER. THE FIRST WORD OF EVERY
;      BLOCK MUST CONTAIN A POINTER TO A PROGRAM LOCATION IN THE
;      INTERPRETOR WHICH IS IMMEDIATELY PRECEDED BY AN ADDRESS
;      CONSTANT CONTAINING THE VALUE BL$XX WHERE XX IS THE BLOCK
;      IDENTIFIER. THIS PROVIDES A UNIFORM MECHANISM FOR
;      DISTINGUISHING BETWEEN THE VARIOUS BLOCK TYPES.
;
;      IN SOME CASES, THE CONTENTS OF THE FIRST WORD IS CONSTANT
;      FOR A GIVEN BLOCK TYPE AND MERELY SERVES AS A POINTER
;      TO THE IDENTIFYING ADDRESS CONSTANT. HOWEVER, IN OTHER
;      CASES THERE ARE SEVERAL POSSIBILITIES FOR THE FIRST
;      WORD IN WHICH CASE EACH OF THE SEVERAL PROGRAM ENTRY
;      POINTS MUST BE PRECEDED BY THE APPROPRIATE CONSTANT.
;
;      IN EACH BLOCK, SOME OF THE FIELDS ARE RELOCATABLE. THIS
;      MEANS THAT THEY MAY CONTAIN A POINTER TO ANOTHER BLOCK
;      IN THE DYNAMIC AREA. (TO BE MORE PRECISE, IF THEY CONTAIN
;      A POINTER WITHIN THE DYNAMIC AREA, THEN IT IS A POINTER
;      TO A BLOCK). SUCH FIELDS MUST BE MODIFIED BY THE GARBAGE
;      COLLECTOR (PROCEDURE GBCOL) WHENEVER BLOCKS ARE COMPACTED
;      IN THE DYNAMIC REGION. THE GARBAGE COLLECTOR (ACTUALLY
;      PROCEDURE GBCPF) REQUIRES THAT ALL SUCH RELOCATABLE
;      FIELDS IN A BLOCK MUST BE CONTIGUOUS.
	.PAGE
;
;      THE DESCRIPTION FORMAT USES THE FOLLOWING SCHEME.
;
;      1)   BLOCK TITLE AND TWO CHARACTER IDENTIFIER
;
;      2)   DESCRIPTION OF BASIC USE OF BLOCK AND INDICATION
;           OF CIRCUMSTANCES UNDER WHICH IT IS CONSTRUCTED.
;
;      3)   PICTURE OF THE BLOCK FORMAT. IN THESE PICTURES LOW
;           MEMORY ADDRESSES ARE AT THE TOP OF THE PAGE. FIXED
;           LENGTH FIELDS ARE SURROUNDED BY I (LETTER I). FIELDS
;           WHICH ARE FIXED LENGTH BUT WHOSE LENGTH IS DEPENDENT
;           ON A CONFIGURATION PARAMETER ARE SURROUNDED BY *
;           (ASTERISK). VARIABLE LENGTH FIELDS ARE SURROUNDED
;           BY / (SLASH).
;
;      4)   DEFINITION OF SYMBOLIC OFFSETS TO FIELDS IN
;           BLOCK AND OF THE SIZE OF THE BLOCK IF FIXED LENGTH
;           OR OF THE SIZE OF THE FIXED LENGTH FIELDS IF THE
;           BLOCK IS VARIABLE LENGTH.
;           NOTE THAT SOME ROUTINES SUCH AS GBCPF ASSUME
;           CERTAIN OFFSETS ARE EQUAL. THE DEFINITIONS
;           GIVEN HERE ENFORCE THIS.  MAKE CHANGES TO
;           THEM ONLY WITH DUE CARE.
;
;      DEFINITIONS OF COMMON OFFSETS
;
	OFFS1==	1
	OFFS2==	2
	OFFS3==	3
;
;      5)   DETAILED COMMENTS ON THE SIGNIFICANCE AND FORMATS
;           OF THE VARIOUS FIELDS.
;
;      THE ORDER IS ALPHABETICAL BY IDENTIFICATION CODE.
	.PAGE
;
;      DEFINITIONS OF BLOCK CODES
;
;      THIS TABLE PROVIDES A UNIQUE IDENTIFICATION CODE FOR
;      EACH SEPARATE BLOCK TYPE. THE FIRST WORD OF A BLOCK IN
;      THE DYNAMIC AREA ALWAYS CONTAINS THE ADDRESS OF A PROGRAM
;      ENTRY POINT. THE BLOCK CODE IS USED AS THE ENTRY POINT ID
;      THE ORDER OF THESE CODES DICTATES THE ORDER OF THE TABLE
;      USED BY THE DATATYPE FUNCTION (SCNMT IN THE CONSTANT SEC)
;
;      BLOCK CODES FOR ACCESSIBLE DATATYPES
;
	BL$AR==	0		;ARBLK     ARRAY
	BL$CD==	BL$AR+1	;CDBLK     CODE
	BL$EX==	BL$CD+1	;EXBLK     EXPRESSION
	BL$IC==	BL$EX+1	;ICBLK     INTEGER
	BL$NM==	BL$IC+1	;NMBLK     NAME
	BL$P0==	BL$NM+1	;P0BLK     PATTERN
	BL$P1==	BL$P0+1	;P1BLK     PATTERN
	BL$P2==	BL$P1+1	;P2BLK     PATTERN
	.IF NOT_EQUAL CNRA
	BL$SC==	BL$P2+1	;SCBLK     STRING
	.IF_FALSE
	BL$RC==	BL$P2+1	;RCBLK     REAL
	BL$SC==	BL$RC+1	;SCBLK     STRING
	.ENDC
	BL$SE==	BL$SC+1	;SEBLK     EXPRESSION
	BL$TB==	BL$SE+1	;TBBLK     TABLE
	BL$VC==	BL$TB+1	;VCBLK     ARRAY
	BL$XN==	BL$VC+1	;XNBLK     EXTERNAL
	BL$XR==	BL$XN+1	;XRBLK     EXTERNAL
	BL$PD==	BL$XR+1	;PDBLK     PROGRAM DEFINED DATATYPE
;
	BL$$D==	BL$PD+1	;NUMBER OF BLOCK CODES FOR DATA
;
;      OTHER BLOCK CODES
;
	BL$TR==	BL$PD+1	;TRBLK
	BL$CC==	BL$TR+1	;CCBLK
	BL$CM==	BL$CC+1	;CMBLK
	BL$CT==	BL$CM+1	;CTBLK
	BL$DF==	BL$CT+1	;DFBLK
	BL$EF==	BL$DF+1	;EFBLK
	BL$EV==	BL$EF+1	;EVBLK
	BL$FF==	BL$EV+1	;FFBLK
	BL$KV==	BL$FF+1	;KVBLK
	BL$PF==	BL$KV+1	;PFBLK
	BL$TE==	BL$PF+1	;TEBLK
;
	BL$$I==	0		;DEFAULT IDENTIFICATION CODE
	BL$$T==	BL$TR+1	;CODE FOR DATA OR TRACE BLOCK
	BL$$$==	BL$TE+1	;NUMBER OF BLOCK CODES
	.PAGE
;
;      FIELD REFERENCES
;
;      REFERENCES TO THE FIELDS OF DATA BLOCKS ARE SYMBOLIC
;      (I.E. USE THE SYMBOLIC OFFSETS) WITH THE FOLLOWING
;      EXCEPTIONS.
;
;      1)   REFERENCES TO THE FIRST WORD ARE USUALLY NOT
;           SYMBOLIC SINCE THEY USE THE (X) OPERAND FORMAT.
;
;      2)   THE CODE WHICH CONSTRUCTS A BLOCK IS OFTEN NOT
;           SYMBOLIC AND SHOULD BE CHANGED IF THE CORRESPONDING
;           BLOCK FORMAT IS MODIFIED.
;
;      3)   THE PLC AND PSC INSTRUCTIONS IMPLY AN OFFSET
;           CORRESPONDING TO THE DEFINITION OF CFP$F.
;
;      4)   THERE ARE NON-SYMBOLIC REFERENCES (EASILY CHANGED)
;           IN THE GARBAGE COLLECTOR (PROCEDURES GBCPF, BLKLN).
;
;      5)   THE FIELDS IDVAL, FARGS APPEAR IN SEVERAL BLOCKS
;           AND ANY CHANGES MUST BE MADE IN PARALLEL TO ALL
;           BLOCKS CONTAINING THE FIELDS. THE ACTUAL REFERENCES
;           TO THESE FIELDS ARE SYMBOLIC WITH THE ABOVE
;           LISTED EXCEPTIONS.
;
;      6)   SEVERAL SPOTS IN THE CODE ASSUME THAT THE
;           DEFINITIONS OF THE FIELDS VRVAL, TEVAL, TRNXT ARE
;           THE SAME (THESE ARE SECTIONS OF CODE WHICH SEARCH
;           OUT ALONG A TRBLK CHAIN FROM A VARIABLE).
;
;      7)   REFERENCES TO THE FIELDS OF AN ARRAY BLOCK IN THE
;           ARRAY REFERENCE ROUTINE ARREF ARE NON-SYMBOLIC.
;
;      APART FROM THE EXCEPTIONS LISTED, REFERENCES ARE SYMBOLIC
;      AS FAR AS POSSIBLE AND MODIFYING THE ORDER OR NUMBER
;      OF FIELDS WILL NOT REQUIRE CHANGES.
	.PAGE
;
;      COMMON FIELDS FOR FUNCTION BLOCKS
;
;      BLOCKS WHICH REPRESENT CALLABLE FUNCTIONS HAVE TWO
;      COMMON FIELDS AT THE START OF THE BLOCK AS FOLLOWS.
;
;           +------------------------------------+
;           I                FCODE               I
;           +------------------------------------+
;           I                FARGS               I
;           +------------------------------------+
;           /                                    /
;           /       REST OF FUNCTION BLOCK       /
;           /                                    /
;           +------------------------------------+
;
	FCODE==	0		;POINTER TO CODE FOR FUNCTION
	FARGS==	1		;NUMBER OF ARGUMENTS
;
;      FCODE IS A POINTER TO THE LOCATION IN THE INTERPRETOR
;      PROGRAM WHICH PROCESSES THIS TYPE OF FUNCTION CALL.
;
;      FARGS IS THE EXPECTED NUMBER OF ARGUMENTS. THE ACTUAL
;      NUMBER OF ARGUMENTS IS ADJUSTED TO THIS AMOUNT BY
;      DELETING EXTRA ARGUMENTS OR SUPPLYING TRAILING NULLS
;      FOR MISSING ONES BEFORE TRANSFERRING THOUGH FCODE.
;      A VALUE OF 999 MAY BE USED IN THIS FIELD TO INDICATE A
;      VARIABLE NUMBER OF ARGUMENTS (SEE SVBLK FIELD SVNAR).
;
;      THE BLOCK TYPES WHICH FOLLOW THIS SCHEME ARE.
;
;      FFBLK                 FIELD FUNCTION
;      DFBLK                 DATATYPE FUNCTION
;      PFBLK                 PROGRAM DEFINED FUNCTION
;      EFBLK                 EXTERNAL LOADED FUNCTION
	.PAGE
;
;      IDENTIFICATION FIELD
;
;
;      ID   FIELD
;
;      CERTAIN PROGRAM ACCESSIBLE OBJECTS (THOSE WHICH CONTAIN
;      OTHER DATA VALUES AND CAN BE COPIED) ARE GIVEN A UNIQUE
;      IDENTIFICATION NUMBER (SEE EXSID). THIS ID VALUE IS AN
;      ADDRESS INTEGER VALUE WHICH IS ALWAYS STORED IN WORD TWO.
;
	IDVAL==	1		;ID VALUE FIELD
;
;      THE BLOCKS CONTAINING AN IDVAL FIELD ARE.
;
;      ARBLK                 ARRAY
;      PDBLK                 PROGRAM DEFINED DATATYPE
;      TBBLK                 TABLE
;      VCBLK                 VECTOR BLOCK (ARRAY)
;
;      NOTE THAT A ZERO IDVAL MEANS THAT THE BLOCK IS ONLY
;      HALF BUILT AND SHOULD NOT BE DUMPED (SEE DUMPR).
	.PAGE
;
;      ARRAY BLOCK (ARBLK)
;
;      AN ARRAY BLOCK REPRESENTS AN ARRAY VALUE OTHER THAN ONE
;      WITH ONE DIMENSION WHOSE LOWER BOUND IS ONE (SEE VCBLK).
;      AN ARBLK IS BUILT WITH A CALL TO THE FUNCTIONS CONVERT
;      (S$CNV) OR ARRAY (S$ARR).
;
;           +------------------------------------+
;           I                ARTYP               I
;           +------------------------------------+
;           I                IDVAL               I
;           +------------------------------------+
;           I                ARLEN               I
;           +------------------------------------+
;           I                AROFS               I
;           +------------------------------------+
;           I                ARNDM               I
;           +------------------------------------+
;           *                ARLBD               *
;           +------------------------------------+
;           *                ARDIM               *
;           +------------------------------------+
;           *                                    *
;           * ABOVE 2 FLDS REPEATED FOR EACH DIM *
;           *                                    *
;           +------------------------------------+
;           I                ARPRO               I
;           +------------------------------------+
;           /                                    /
;           /                ARVLS               /
;           /                                    /
;           +------------------------------------+
	.PAGE
;
;      ARRAY BLOCK (CONTINUED)
;
	ARTYP==	0		;POINTER TO DUMMY ROUTINE B$ART
	ARLEN==	IDVAL+1	;LENGTH OF ARBLK IN BYTES
	AROFS==	ARLEN+1	;OFFSET IN ARBLK TO ARPRO FIELD
	ARNDM==	AROFS+1	;NUMBER OF DIMENSIONS
	ARLBD==	ARNDM+1	;LOW BOUND (FIRST SUBSCRIPT)
	ARDIM==	ARLBD+CFP$I	;DIMENSION (FIRST SUBSCRIPT)
	ARLB2==	ARDIM+CFP$I	;LOW BOUND (SECOND SUBSCRIPT)
	ARDM2==	ARLB2+CFP$I	;DIMENSION (SECOND SUBSCRIPT)
	ARPRO==	ARDIM+CFP$I	;ARRAY PROTOTYPE (ONE DIMENSION)
	ARVLS==	ARPRO+1	;START OF VALUES (ONE DIMENSION)
	ARPR2==	ARDM2+CFP$I	;ARRAY PROTOTYPE (TWO DIMENSIONS)
	ARVL2==	ARPR2+1	;START OF VALUES (TWO DIMENSIONS)
	ARSI$==	ARLBD		;NUMBER OF STANDARD FIELDS IN BLOCK
	ARDMS==	ARLB2-ARLBD	;SIZE OF INFO FOR ONE SET OF BOUNDS
;
;      THE BOUNDS AND DIMENSION FIELDS ARE SIGNED INTEGER
;      VALUES AND EACH OCCUPY CFP$I WORDS IN THE ARBLK.
;
;      THE LENGTH OF AN ARBLK IN BYTES MAY NOT EXCEED MXLEN.
;      THIS IS REQUIRED TO KEEP NAME OFFSETS GARBAGE COLLECTABLE
;
;      THE ACTUAL VALUES ARE ARRANGED IN ROW-WISE ORDER AND
;      CAN CONTAIN A DATA POINTER OR A POINTER TO A TRBLK.
	.PAGE
;
;      CODE CONSTRUCTION BLOCK (CCBLK)
;
;      AT ANY ONE MOMENT THERE IS AT MOST ONE CCBLK INTO
;      WHICH THE COMPILER IS CURRENTLY STORING CODE (CDWRD).
;
;           +------------------------------------+
;           I                CCTYP               I
;           +------------------------------------+
;           I                CCLEN               I
;           +------------------------------------+
;           I                CCUSE               I
;           +------------------------------------+
;           /                                    /
;           /                CCCOD               /
;           /                                    /
;           +------------------------------------+
;
	CCTYP==	0		;POINTER TO DUMMY ROUTINE B$CCT
	CCLEN==	CCTYP+1	;LENGTH OF CCBLK IN BYTES
	CCUSE==	CCLEN+1	;OFFSET PAST LAST USED WORD (BYTES)
	CCCOD==	CCUSE+1	;START OF GENERATED CODE IN BLOCK
;
;      THE REASON THAT THE CCBLK IS A SEPARATE BLOCK TYPE FROM
;      THE USUAL CDBLK IS THAT THE GARBAGE COLLECTOR MUST
;      ONLY PROCESS THOSE FIELDS WHICH HAVE BEEN SET (SEE GBCPF)
	.PAGE
;
;      CODE BLOCK (CDBLK)
;
;      A CODE BLOCK IS BUILT FOR EACH STATEMENT COMPILED DURING
;      THE INITIAL COMPILATION OR BY SUBSEQUENT CALLS TO CODE.
;
;           +------------------------------------+
;           I                CDJMP               I
;           +------------------------------------+
;           I                CDSTM               I
;           +------------------------------------+
;           I                CDLEN               I
;           +------------------------------------+
;           I                CDFAL               I
;           +------------------------------------+
;           /                                    /
;           /                CDCOD               /
;           /                                    /
;           +------------------------------------+
;
	CDJMP==	0		;PTR TO ROUTINE TO EXECUTE STATEMENT
	CDSTM==	CDJMP+1	;STATEMENT NUMBER
	CDLEN==	OFFS2		;LENGTH OF CDBLK IN BYTES
	CDFAL==	OFFS3		;FAILURE EXIT (SEE BELOW)
	CDCOD==	CDFAL+1	;EXECUTABLE PSEUDO-CODE
	CDSI$==	CDCOD		;NUMBER OF STANDARD FIELDS IN CDBLK
;
;      CDSTM IS THE STATEMENT NUMBER OF THE CURRENT STATEMENT.
;
;      CDJMP, CDFAL ARE SET AS FOLLOWS.
;
;      1)   IF THE FAILURE EXIT IS THE NEXT STATEMENT
;
;           CDJMP = B$CDS
;           CDFAL = PTR TO CDBLK FOR NEXT STATEMENT
;
;      2)   IF THE FAILURE EXIT IS A SIMPLE LABEL NAME
;
;           CDJMP = B$CDS
;           CDFAL IS A PTR TO THE VRTRA FIELD OF THE VRBLK
;
;      3)   IF THERE IS NO FAILURE EXIT (-NOFAIL MODE)
;
;           CDJMP = B$CDS
;           CDFAL = O$UNF
;
;      4)   IF THE FAILURE EXIT IS COMPLEX OR DIRECT
;
;           CDJMP = B$CDC
;           CDFAL IS THE OFFSET TO THE O$GOF WORD
	.PAGE
;
;      CODE BLOCK (CONTINUED)
;
;      CDCOD IS THE START OF THE ACTUAL CODE. FIRST WE DESCRIBE
;      THE CODE GENERATED FOR AN EXPRESSION. IN AN EXPRESSION,
;      ELEMENTS ARE FETCHED BY NAME OR BY VALUE. FOR EXAMPLE,
;      THE BINARY EQUAL OPERATOR FETCHES ITS LEFT ARGUMENT
;      BY NAME AND ITS RIGHT ARGUMENT BY VALUE. THESE TWO
;      CASES GENERATE QUITE DIFFERENT CODE AND ARE DESCRIBED
;      SEPARATELY. FIRST WE CONSIDER THE CODE BY VALUE CASE.
;
;      GENERATION OF CODE BY VALUE FOR EXPRESSIONS ELEMENTS.
;
;      EXPRESSION            POINTER TO EXBLK OR SEBLK
;
;      INTEGER CONSTANT      POINTER TO ICBLK
;
;      NULL CONSTANT         POINTER TO NULLS
;
;      PATTERN               (RESULTING FROM PREEVALUATION)
;                            =O$LPT
;                            POINTER TO P0BLK,P1BLK OR P2BLK
;
;      REAL CONSTANT         POINTER TO RCBLK
;
;      STRING CONSTANT       POINTER TO SCBLK
;
;      VARIABLE              POINTER TO VRGET FIELD OF VRBLK
;
;      ADDITION              VALUE CODE FOR LEFT OPERAND
;                            VALUE CODE FOR RIGHT OPERAND
;                            =O$ADD
;
;      AFFIRMATION           VALUE CODE FOR OPERAND
;                            =O$AFF
;
;      ALTERNATION           VALUE CODE FOR LEFT OPERAND
;                            VALUE CODE FOR RIGHT OPERAND
;                            =O$ALT
;
;      ARRAY REFERENCE       (CASE OF ONE SUBSCRIPT)
;                            VALUE CODE FOR ARRAY OPERAND
;                            VALUE CODE FOR SUBSCRIPT OPERAND
;                            =O$AOV
;
;                            (CASE OF MORE THAN ONE SUBSCRIPT)
;                            VALUE CODE FOR ARRAY OPERAND
;                            VALUE CODE FOR FIRST SUBSCRIPT
;                            VALUE CODE FOR SECOND SUBSCRIPT
;                            ...
;                            VALUE CODE FOR LAST SUBSCRIPT
;                            =O$AMV
;                            NUMBER OF SUBSCRIPTS
	.PAGE
;
;      CODE BLOCK (CONTINUED)
;
;      ASSIGNMENT            (TO NATURAL VARIABLE)
;                            VALUE CODE FOR RIGHT OPERAND
;                            POINTER TO VRSTO FIELD OF VRBLK
;
;                            (TO ANY OTHER VARIABLE)
;                            NAME CODE FOR LEFT OPERAND
;                            VALUE CODE FOR RIGHT OPERAND
;                            =O$ASS
;
;      COMPILE ERROR         =O$CER
;
;
;      COMPLEMENTATION       VALUE CODE FOR OPERAND
;                            =O$COM
;
;      CONCATENATION         (CASE OF PRED FUNC LEFT OPERAND)
;                            VALUE CODE FOR LEFT OPERAND
;                            =O$POP
;                            VALUE CODE FOR RIGHT OPERAND
;
;                            (ALL OTHER CASES)
;                            VALUE CODE FOR LEFT OPERAND
;                            VALUE CODE FOR RIGHT OPERAND
;                            =O$CNC
;
;      CURSOR ASSIGNMENT     NAME CODE FOR OPERAND
;                            =O$CAS
;
;      DIVISION              VALUE CODE FOR LEFT OPERAND
;                            VALUE CODE FOR RIGHT OPERAND
;                            =O$DVD
;
;      EXPONENTIATION        VALUE CODE FOR LEFT OPERAND
;                            VALUE CODE FOR RIGHT OPERAND
;                            =O$EXP
;
;      FUNCTION CALL         (CASE OF CALL TO SYSTEM FUNCTION)
;                            VALUE CODE FOR FIRST ARGUMENT
;                            VALUE CODE FOR SECOND ARGUMENT
;                            ...
;                            VALUE CODE FOR LAST ARGUMENT
;                            POINTER TO SVFNC FIELD OF SVBLK
;
	.PAGE
;
;      CODE BLOCK (CONTINUED)
;
;      FUNCTION CALL         (CASE OF NON-SYSTEM FUNCTION 1 ARG)
;                            VALUE CODE FOR ARGUMENT
;                            =O$FNS
;                            POINTER TO VRBLK FOR FUNCTION
;
;                            (NON-SYSTEM FUNCTION, GT 1 ARG)
;                            VALUE CODE FOR FIRST ARGUMENT
;                            VALUE CODE FOR SECOND ARGUMENT
;                            ...
;                            VALUE CODE FOR LAST ARGUMENT
;                            =O$FNC
;                            NUMBER OF ARGUMENTS
;                            POINTER TO VRBLK FOR FUNCTION
;
;      IMMEDIATE ASSIGNMENT  VALUE CODE FOR LEFT OPERAND
;                            NAME CODE FOR RIGHT OPERAND
;                            =O$IMA
;
;      INDIRECTION           VALUE CODE FOR OPERAND
;                            =O$INV
;
;      INTERROGATION         VALUE CODE FOR OPERAND
;                            =O$INT
;
;      KEYWORD REFERENCE     NAME CODE FOR OPERAND
;                            =O$KWV
;
;      MULTIPLICATION        VALUE CODE FOR LEFT OPERAND
;                            VALUE CODE FOR RIGHT OPERAND
;                            =O$MLT
;
;      NAME REFERENCE        (NATURAL VARIABLE CASE)
;                            POINTER TO NMBLK FOR NAME
;
;                            (ALL OTHER CASES)
;                            NAME CODE FOR OPERAND
;                            =O$NAM
;
;      NEGATION              =O$NTA
;                            CDBLK OFFSET OF O$NTC WORD
;                            VALUE CODE FOR OPERAND
;                            =O$NTB
;                            =O$NTC
	.PAGE
;
;      CODE BLOCK (CONTINUED)
;
;      PATTERN ASSIGNMENT    VALUE CODE FOR LEFT OPERAND
;                            NAME CODE FOR RIGHT OPERAND
;                            =O$PAS
;
;      PATTERN MATCH         VALUE CODE FOR LEFT OPERAND
;                            VALUE CODE FOR RIGHT OPERAND
;                            =O$PMV
;
;      PATTERN REPLACEMENT   NAME CODE FOR SUBJECT
;                            VALUE CODE FOR PATTERN
;                            =O$PMN
;                            VALUE CODE FOR REPLACEMENT
;                            =O$RPL
;
;      SELECTION             (FOR FIRST ALTERNATIVE)
;                            =O$SLA
;                            CDBLK OFFSET TO NEXT O$SLC WORD
;                            VALUE CODE FOR FIRST ALTERNATIVE
;                            =O$SLB
;                            CDBLK OFFSET PAST ALTERNATIVES
;
;                            (FOR SUBSEQUENT ALTERNATIVES)
;                            =O$SLC
;                            CDBLK OFFSET TO NEXT O$SLC,O$SLD
;                            VALUE CODE FOR ALTERNATIVE
;                            =O$SLB
;                            OFFSET IN CDBLK PAST ALTERNATIVES
;
;                            (FOR LAST ALTERNATIVE)
;                            =O$SLD
;                            VALUE CODE FOR LAST ALTERNATIVE
;
;      SUBTRACTION           VALUE CODE FOR LEFT OPERAND
;                            VALUE CODE FOR RIGHT OPERAND
;                            =O$SUB
	.PAGE
;
;      CODE BLOCK (CONTINUED)
;
;      GENERATION OF CODE BY NAME FOR EXPRESSION ELEMENTS.
;
;      VARIABLE              =O$LVN
;                            POINTER TO VRBLK
;
;      EXPRESSION            (CASE OF *NATURAL VARIABLE)
;                            =O$LVN
;                            POINTER TO VRBLK
;
;                            (ALL OTHER CASES)
;                            =O$LEX
;                            POINTER TO EXBLK
;
;
;      ARRAY REFERENCE       (CASE OF ONE SUBSCRIPT)
;                            VALUE CODE FOR ARRAY OPERAND
;                            VALUE CODE FOR SUBSCRIPT OPERAND
;                            =O$AON
;
;                            (CASE OF MORE THAN ONE SUBSCRIPT)
;                            VALUE CODE FOR ARRAY OPERAND
;                            VALUE CODE FOR FIRST SUBSCRIPT
;                            VALUE CODE FOR SECOND SUBSCRIPT
;                            ...
;                            VALUE CODE FOR LAST SUBSCRIPT
;                            =O$AMN
;                            NUMBER OF SUBSCRIPTS
;
;      COMPILE ERROR         =O$CER
;
;      FUNCTION CALL         (SAME CODE AS FOR VALUE CALL)
;                            =O$FNE
;
;      INDIRECTION           VALUE CODE FOR OPERAND
;                            =O$INN
;
;      KEYWORD REFERENCE     NAME CODE FOR OPERAND
;                            =O$KWN
;
;      ANY OTHER OPERAND IS AN ERROR IN A NAME POSITION
;
;      NOTE THAT IN THIS DESCRIPTION, =O$XXX REFERS TO THE
;      GENERATION OF A WORD CONTAINING THE ADDRESS OF ANOTHER
;      WORD WHICH CONTAINS THE ENTRY POINT ADDRESS O$XXX.
	.PAGE
;
;      CODE BLOCK (CONTINUED)
;
;      NOW WE CONSIDER THE OVERALL STRUCTURE OF THE CODE BLOCK
;      FOR A STATEMENT WITH POSSIBLE GOTO FIELDS.
;
;      FIRST COMES THE CODE FOR THE STATEMENT BODY.
;      THE STATEMENT BODY IS AN EXPRESSION TO BE EVALUATED
;      BY VALUE ALTHOUGH THE VALUE IS NOT ACTUALLY REQUIRED.
;      NORMAL VALUE CODE IS GENERATED FOR THE BODY OF THE
;      STATEMENT EXCEPT IN THE CASE OF A PATTERN MATCH BY
;      VALUE, IN WHICH CASE THE FOLLOWING IS GENERATED.
;
;                            VALUE CODE FOR LEFT OPERAND
;                            VALUE CODE FOR RIGHT OPERAND
;                            =O$PMS
;
;      NEXT WE HAVE THE CODE FOR THE SUCCESS GOTO. THERE ARE
;      SEVERAL CASES AS FOLLOWS.
;
;      1)   NO SUCCESS GOTO  PTR TO CDBLK FOR NEXT STATEMENT
;
;      2)   SIMPLE LABEL     PTR TO VRTRA FIELD OF VRBLK
;
;      3)   COMPLEX GOTO     (CODE BY NAME FOR GOTO OPERAND)
;                            =O$GOC
;
;      4)   DIRECT GOTO      (CODE BY VALUE FOR GOTO OPERAND)
;                            =O$GOD
;
;      FOLLOWING THIS WE GENERATE CODE FOR THE FAILURE GOTO IF
;      IT IS DIRECT OR IF IT IS COMPLEX, SIMPLE FAILURE GOTOS
;      HAVING BEEN HANDLED BY AN APPROPRIATE SETTING OF THE
;      CDFAL FIELD OF THE CDBLK. THE GENERATED CODE IS ONE
;      OF THE FOLLOWING.
;
;      1)   COMPLEX FGOTO    =O$FIF
;                            =O$GOF
;                            NAME CODE FOR GOTO OPERAND
;                            =O$GOC
;
;      2)   DIRECT FGOTO     =O$FIF
;                            =O$GOF
;                            VALUE CODE FOR GOTO OPERAND
;                            =O$GOD
;
;      AN OPTIMIZATION OCCURS IF THE SUCCESS AND FAILURE GOTOS
;      ARE IDENTICAL AND EITHER COMPLEX OR DIRECT. IN THIS CASE,
;      NO CODE IS GENERATED FOR THE SUCCESS GOTO AND CONTROL
;      IS ALLOWED TO FALL INTO THE FAILURE GOTO ON SUCCESS.
	.PAGE
;
;      COMPILER BLOCK (CMBLK)
;
;      A COMPILER BLOCK (CMBLK) IS BUILT BY EXPAN TO REPRESENT
;      ONE NODE OF A TREE STRUCTURED EXPRESSION REPRESENTATION.
;
;           +------------------------------------+
;           I                CMIDN               I
;           +------------------------------------+
;           I                CMLEN               I
;           +------------------------------------+
;           I                CMTYP               I
;           +------------------------------------+
;           I                CMOPN               I
;           +------------------------------------+
;           /           CMVLS OR CMROP           /
;           /                                    /
;           /                CMLOP               /
;           /                                    /
;           +------------------------------------+
;
	CMIDN==	0		;POINTER TO DUMMY ROUTINE B$CMT
	CMLEN==	CMIDN+1	;LENGTH OF CMBLK IN BYTES
	CMTYP==	CMLEN+1	;TYPE (C$XXX, SEE LIST BELOW)
	CMOPN==	CMTYP+1	;OPERAND POINTER (SEE BELOW)
	CMVLS==	CMOPN+1	;OPERAND VALUE POINTERS (SEE BELOW)
	CMROP==	CMVLS		;RIGHT (ONLY) OPERATOR OPERAND
	CMLOP==	CMVLS+1	;LEFT OPERATOR OPERAND
	CMSI$==	CMVLS		;NUMBER OF STANDARD FIELDS IN CMBLK
	CMUS$==	CMSI$+1	;SIZE OF UNARY OPERATOR CMBLK
	CMBS$==	CMSI$+2	;SIZE OF BINARY OPERATOR CMBLK
	CMAR1==	CMVLS+1	;ARRAY SUBSCRIPT POINTERS
;
;      THE CMOPN AND CMVLS FIELDS ARE SET AS FOLLOWS
;
;      ARRAY REFERENCE       CMOPN = PTR TO ARRAY OPERAND
;                            CMVLS = PTRS TO SUBSCRIPT OPERANDS
;
;      FUNCTION CALL         CMOPN = PTR TO VRBLK FOR FUNCTION
;                            CMVLS = PTRS TO ARGUMENT OPERANDS
;
;      SELECTION             CMOPN = ZERO
;                            CMVLS = PTRS TO ALTERNATE OPERANDS
;
;      UNARY OPERATOR        CMOPN = PTR TO OPERATOR DVBLK
;                            CMROP = PTR TO OPERAND
;
;      BINARY OPERATOR       CMOPN = PTR TO OPERATOR DVBLK
;                            CMROP = PTR TO RIGHT OPERAND
;                            CMLOP = PTR TO LEFT OPERAND
	.PAGE
;
;      CMTYP IS SET TO INDICATE THE TYPE OF EXPRESSION ELEMENT
;      AS SHOWN BY THE FOLLOWING TABLE OF DEFINITIONS.
;
	C$ARR==	0		;ARRAY REFERENCE
	C$FNC==	C$ARR+1	;FUNCTION CALL
	C$DEF==	C$FNC+1	;DEFERRED EXPRESSION (UNARY *)
	C$IND==	C$DEF+1	;INDIRECTION (UNARY $)
	C$KEY==	C$IND+1	;KEYWORD REFERENCE (UNARY AMPERSAND)
	C$UBO==	C$KEY+1	;UNDEFINED BINARY OPERATOR
	C$UUO==	C$UBO+1	;UNDEFINED UNARY OPERATOR
	C$UO$==	C$UUO+1	;TEST VALUE (=C$UUO+1=C$UBO+2)
	C$$NM==	C$UUO+1	;NUMBER OF CODES FOR NAME OPERANDS
;
;      THE REMAINING TYPES INDICATE EXPRESSION ELEMENTS WHICH
;      CAN ONLY BE EVALUATED BY VALUE (NOT BY NAME).
;
	C$BVL==	C$UUO+1	;BINARY OP WITH VALUE OPERANDS
	C$UVL==	C$BVL+1	;UNARY OPERATOR WITH VALUE OPERAND
	C$ALT==	C$UVL+1	;ALTERNATION (BINARY BAR)
	C$CNC==	C$ALT+1	;CONCATENATION
	C$CNP==	C$CNC+1	;CONCATENATION, NOT PATTERN MATCH
	C$UNM==	C$CNP+1	;UNARY OP WITH NAME OPERAND
	C$BVN==	C$UNM+1	;BINARY OP (OPERANDS BY VALUE, NAME)
	C$ASS==	C$BVN+1	;ASSIGNMENT
	C$INT==	C$ASS+1	;INTERROGATION
	C$NEG==	C$INT+1	;NEGATION (UNARY NOT)
	C$SEL==	C$NEG+1	;SELECTION
	C$PMT==	C$SEL+1	;PATTERN MATCH
;
	C$PR$==	C$BVN		;LAST PREEVALUABLE CODE
	C$$NV==	C$PMT+1	;NUMBER OF DIFFERENT CMBLK TYPES
	.PAGE
;
;      CHARACTER TABLE BLOCK (CTBLK)
;
;      A CHARACTER TABLE BLOCK IS USED TO HOLD LOGICAL CHARACTER
;      TABLES FOR USE WITH ANY,NOTANY,SPAN,BREAK,BREAKX
;      PATTERNS. EACH CHARACTER TABLE CAN BE USED TO STORE
;      CFP$N DISTINCT TABLES AS BIT COLUMNS. A BIT COLUMN
;      ALLOCATED FOR EACH ARGUMENT OF MORE THAN ONE CHARACTER
;      IN LENGTH TO ONE OF THE ABOVE LISTED PATTERN PRIMITIVES.
;
;           +------------------------------------+
;           I                CTTYP               I
;           +------------------------------------+
;           *                                    *
;           *                                    *
;           *                CTCHS               *
;           *                                    *
;           *                                    *
;           +------------------------------------+
;
	CTTYP==	0		;POINTER TO DUMMY ROUTINE B$CTT
	CTCHS==	CTTYP+1	;START OF CHARACTER TABLE WORDS
	CTSI$==	CTCHS+CFP$A	;NUMBER OF WORDS IN CTBLK
;
;      CTCHS IS CFP$A WORDS LONG AND CONSISTS OF A ONE WORD
;      BIT STRING VALUE FOR EACH POSSIBLE CHARACTER IN THE
;      INTERNAL ALPHABET. EACH OF THE CFP$N POSSIBLE BITS IN
;      A BITSTRING IS USED TO FORM A COLUMN OF BIT INDICATORS.
;      A BIT IS SET ON IF THE CHARACTER IS IN THE TABLE AND OFF
;      IF THE CHARACTER IS NOT PRESENT.
	.PAGE
;
;      DATATYPE FUNCTION BLOCK (DFBLK)
;
;      A DATATYPE FUNCTION IS USED TO CONTROL THE CONSTRUCTION
;      OF A PROGRAM DEFINED DATATYPE OBJECT. A CALL TO THE
;      SYSTEM FUNCTION DATA BUILDS A DFBLK FOR THE DATATYPE NAME
;
;      NOTE THAT THESE BLOCKS ARE BUILT IN STATIC BECAUSE PDBLK
;      LENGTH IS GOT FROM DFLEN FIELD.  IF DFBLK WAS IN DYNAMIC
;      STORE THIS WOULD CAUSE TROUBLE DURING PASS TWO OF GARBAGE
;      COLLECTION.  SCBLK REFERRED TO BY DFNAM FIELD IS ALSO PUT
;      IN STATIC SO THAT THERE ARE NO RELOC. FIELDS. THIS CUTS
;      GARBAGE COLLECTION TASK APPRECIABLY FOR PDBLKS WHICH ARE
;      LIKELY TO BE PRESENT IN LARGE NUMBERS.
;
;           +------------------------------------+
;           I                FCODE               I
;           +------------------------------------+
;           I                FARGS               I
;           +------------------------------------+
;           I                DFLEN               I
;           +------------------------------------+
;           I                DFPDL               I
;           +------------------------------------+
;           I                DFNAM               I
;           +------------------------------------+
;           /                                    /
;           /                DFFLD               /
;           /                                    /
;           +------------------------------------+
;
	DFLEN==	FARGS+1	;LENGTH OF DFBLK IN BYTES
	DFPDL==	DFLEN+1	;LENGTH OF CORRESPONDING PDBLK
	DFNAM==	DFPDL+1	;POINTER TO SCBLK FOR DATATYPE NAME
	DFFLD==	DFNAM+1	;START OF VRBLK PTRS FOR FIELD NAMES
	DFFLB==	DFFLD-1	;OFFSET BEHIND DFFLD FOR FIELD FUNC
	DFSI$==	DFFLD		;NUMBER OF STANDARD FIELDS IN DFBLK
;
;      THE FCODE FIELD POINTS TO THE ROUTINE B$DFC
;
;      FARGS (THE NUMBER OF ARGUMENTS) IS THE NUMBER OF FIELDS.
	.PAGE
;
;      DOPE VECTOR BLOCK (DVBLK)
;
;      A DOPE VECTOR IS ASSEMBLED FOR EACH POSSIBLE OPERATOR IN
;      THE SNOBOL4 LANGUAGE AS PART OF THE CONSTANT SECTION.
;
;           +------------------------------------+
;           I                DVOPN               I
;           +------------------------------------+
;           I                DVTYP               I
;           +------------------------------------+
;           I                DVLPR               I
;           +------------------------------------+
;           I                DVRPR               I
;           +------------------------------------+
;
	DVOPN==	0		;ENTRY ADDRESS (PTR TO O$XXX)
	DVTYP==	DVOPN+1	;TYPE CODE (C$XXX, SEE CMBLK)
	DVLPR==	DVTYP+1	;LEFT PRECEDENCE (LLXXX, SEE BELOW)
	DVRPR==	DVLPR+1	;RIGHT PRECEDENCE (RRXXX, SEE BELOW)
	DVUS$==	DVLPR+1	;SIZE OF UNARY OPERATOR DV
	DVBS$==	DVRPR+1	;SIZE OF BINARY OPERATOR DV
	DVUBS==	DVUS$+DVBS$	;SIZE OF UNOP + BINOP (SEE SCANE)
;
;      THE CONTENTS OF THE DVTYP FIELD IS COPIED INTO THE CMTYP
;      FIELD OF THE CMBLK FOR THE OPERATOR IF IT IS USED.
;
;      THE CMOPN FIELD OF AN OPERATOR CMBLK POINTS TO THE DVBLK
;      ITSELF, PROVIDING THE REQUIRED ENTRY ADDRESS POINTER PTR.
;
;      FOR NORMALLY UNDEFINED OPERATORS, THE DVOPN (AND CMOPN)
;      FIELDS CONTAIN A WORD OFFSET FROM R$UBA OF THE FUNCTION
;      BLOCK POINTER FOR THE OPERATOR (INSTEAD OF O$XXX PTR).
;      FOR CERTAIN SPECIAL OPERATORS, THE DVOPN FIELD IS NOT
;      REQUIRED AT ALL AND IS ASSEMBLED AS ZERO.
;
;      THE LEFT PRECEDENCE IS USED IN COMPARING AN OPERATOR TO
;      THE LEFT OF SOME OTHER OPERATOR. IT THEREFORE GOVERNS THE
;      PRECEDENCE OF THE OPERATOR TOWARDS ITS RIGHT OPERAND.
;
;      THE RIGHT PRECEDENCE IS USED IN COMPARING AN OPERATOR TO
;      THE RIGHT OF SOME OTHER OPERATOR. IT THEREFORE GOVERNS
;      THE PRECEDENCE OF THE OPERATOR TOWARDS ITS LEFT OPERAND.
;
;      HIGHER PRECEDENCE VALUES CORRESPOND TO A TIGHTER BINDING
;      CAPABILITY. THUS WE HAVE THE LEFT PRECEDENCE LOWER
;      (HIGHER) THAN THE RIGHT PRECEDENCE FOR RIGHT (LEFT)
;      ASSOCIATIVE BINARY OPERATORS.
;
;      THE LEFT PRECEDENCE OF UNARY OPERATORS IS SET TO AN
;      ARBITRARY HIGH VALUE. THE RIGHT VALUE IS NOT REQUIRED AND
;      CONSEQUENTLY THE DVRPR FIELD IS OMITTED FOR UNARY OPS.
	.PAGE
;
;      TABLE OF OPERATOR PRECEDENCE VALUES
;
	RRASS==	10		;RIGHT     EQUAL
	LLASS==	00		;LEFT      EQUAL
	RRPMT==	20		;RIGHT     QUESTION MARK
	LLPMT==	30		;LEFT      QUESTION MARK
	RRAMP==	40		;RIGHT     AMPERSAND
	LLAMP==	50		;LEFT      AMPERSAND
	RRALT==	70		;RIGHT     VERTICAL BAR
	LLALT==	60		;LEFT      VERTICAL BAR
	RRCNC==	90		;RIGHT     BLANK
	LLCNC==	80		;LEFT      BLANK
	RRATS==	110		;RIGHT     AT
	LLATS==	100		;LEFT      AT
	RRPLM==	120		;RIGHT     PLUS, MINUS
	LLPLM==	130		;LEFT      PLUS, MINUS
	RRNUM==	140		;RIGHT     NUMBER
	LLNUM==	150		;LEFT      NUMBER
	RRDVD==	160		;RIGHT     SLASH
	LLDVD==	170		;LEFT      SLASH
	RRMLT==	180		;RIGHT     ASTERISK
	LLMLT==	190		;LEFT      ASTERISK
	RRPCT==	200		;RIGHT     PERCENT
	LLPCT==	210		;LEFT      PERCENT
	RREXP==	230		;RIGHT     EXCLAMATION
	LLEXP==	220		;LEFT      EXCLAMATION
	RRDLD==	240		;RIGHT     DOLLAR, DOT
	LLDLD==	250		;LEFT      DOLLAR, DOT
	RRNOT==	270		;RIGHT     NOT
	LLNOT==	260		;LEFT      NOT
	LLUNO==	999		;LEFT      ALL UNARY OPERATORS
;
;      PRECEDENCES ARE THE SAME AS IN BTL SNOBOL4 WITH THE
;      FOLLOWING EXCEPTIONS.
;
;      1)   BINARY QUESTION MARK IS LOWERED AND MADE LEFT ASSOC-
;           IATIVE TO REFLECT ITS NEW USE FOR PATTERN MATCHING.
;
;      2)   ALTERNATION AND CONCATENATION ARE MADE RIGHT
;           ASSOCIATIVE FOR GREATER EFFICIENCY IN PATTERN
;           CONSTRUCTION AND MATCHING RESPECTIVELY. THIS CHANGE
;           IS TRANSPARENT TO THE SNOBOL4 PROGRAMMER.
;
;      3)   THE EQUAL SIGN HAS BEEN ADDED AS A LOW PRECEDENCE
;           OPERATOR WHICH IS RIGHT ASSOCIATIVE TO REFLECT ITS
;           MORE GENERAL USAGE IN THIS VERSION OF SNOBOL4.
	.PAGE
;
;      EXTERNAL FUNCTION BLOCK (EFBLK)
;
;      AN EXTERNAL FUNCTION BLOCK IS USED TO CONTROL THE CALLING
;      OF AN EXTERNAL FUNCTION. IT IS BUILT BY A CALL TO LOAD.
;
;           +------------------------------------+
;           I                FCODE               I
;           +------------------------------------+
;           I                FARGS               I
;           +------------------------------------+
;           I                EFLEN               I
;           +------------------------------------+
;           I                EFUSE               I
;           +------------------------------------+
;           I                EFCOD               I
;           +------------------------------------+
;           I                EFVAR               I
;           +------------------------------------+
;           I                EFRSL               I
;           +------------------------------------+
;           /                                    /
;           /                EFTAR               /
;           /                                    /
;           +------------------------------------+
;
	EFLEN==	FARGS+1	;LENGTH OF EFBLK IN BYTES
	EFUSE==	EFLEN+1	;USE COUNT (FOR OPSYN)
	EFCOD==	EFUSE+1	;PTR TO CODE (FROM SYSLD)
	EFVAR==	EFCOD+1	;PTR TO ASSOCIATED VRBLK
	EFRSL==	EFVAR+1	;RESULT TYPE (SEE BELOW)
	EFTAR==	EFRSL+1	;ARGUMENT TYPES (SEE BELOW)
	EFSI$==	EFTAR		;NUMBER OF STANDARD FIELDS IN EFBLK
;
;      THE FCODE FIELD POINTS TO THE ROUTINE B$EFC.
;
;      EFUSE IS USED TO KEEP TRACK OF MULTIPLE USE WHEN OPSYN
;      IS EMPLOYED. THE FUNCTION IS AUTOMATICALLY UNLOADED
;      WHEN THERE ARE NO MORE REFERENCES TO THE FUNCTION.
;
;      EFRSL AND EFTAR ARE TYPE CODES AS FOLLOWS.
;
;           0                TYPE IS UNCONVERTED
;           1                TYPE IS STRING
;           2                TYPE IS INTEGER
;           3                TYPE IS REAL
	.PAGE
;
;      EXPRESSION VARIABLE BLOCK (EVBLK)
;
;      IN THIS VERSION OF SPITBOL, AN EXPRESSION CAN BE USED IN
;      ANY POSITION WHICH WOULD NORMALLY EXPECT A NAME (FOR
;      EXAMPLE ON THE LEFT SIDE OF EQUALS OR AS THE RIGHT
;      ARGUMENT OF BINARY DOT). THIS CORRESPONDS TO THE CREATION
;      OF A PSEUDO-VARIABLE WHICH IS REPRESENTED BY A POINTER TO
;      AN EXPRESSION VARIABLE BLOCK AS FOLLOWS.
;
;           +------------------------------------+
;           I                EVTYP               I
;           +------------------------------------+
;           I                EVEXP               I
;           +------------------------------------+
;           I                EVVAR               I
;           +------------------------------------+
;
	EVTYP==	0		;POINTER TO DUMMY ROUTINE B$EVT
	EVEXP==	EVTYP+1	;POINTER TO EXBLK FOR EXPRESSION
	EVVAR==	EVEXP+1	;POINTER TO TRBEV DUMMY TRBLK
	EVSI$==	EVVAR+1	;SIZE OF EVBLK
;
;      THE NAME OF AN EXPRESSION VARIABLE IS REPRESENTED BY A
;      BASE POINTER TO THE EVBLK AND AN OFFSET OF EVVAR. THIS
;      VALUE APPEARS TO BE TRAPPED BY THE DUMMY TRBEV BLOCK.
;
;      NOTE THAT THERE IS NO NEED TO ALLOW FOR THE CASE OF AN
;      EXPRESSION VARIABLE WHICH REFERENCES AN SEBLK SINCE A
;      VARIABLE WHICH IS OF THE FORM *VAR IS EQUIVALENT TO VAR.
	.PAGE
;
;      EXPRESSION BLOCK (EXBLK)
;
;      AN EXPRESSION BLOCK IS BUILT FOR EACH EXPRESSION
;      REFERENCED IN A PROGRAM OR CREATED BY EVAL OR CONVERT
;      DURING EXECUTION OF A PROGRAM.
;
;           +------------------------------------+
;           I                EXTYP               I
;           +------------------------------------+
;           I                EXSTM               I
;           +------------------------------------+
;           I                EXLEN               I
;           +------------------------------------+
;           I                EXFLC               I
;           +------------------------------------+
;           /                                    /
;           /                EXCOD               /
;           /                                    /
;           +------------------------------------+
;
	EXTYP==	0		;PTR TO ROUTINE B$EXL TO LOAD EXPR
	EXSTM==	CDSTM		;STORES STMNT NO. DURING EVALUATION
	EXLEN==	EXSTM+1	;LENGTH OF EXBLK IN BYTES
	EXFLC==	EXLEN+1	;FAILURE CODE (=O$FEX)
	EXCOD==	EXFLC+1	;PSEUDO-CODE FOR EXPRESSION
	EXSI$==	EXCOD		;NUMBER OF STANDARD FIELDS IN EXBLK
;
;      THERE ARE TWO CASES FOR EXCOD DEPENDING ON WHETHER THE
;      EXPRESSION CAN BE EVALUATED BY NAME (SEE DESCRIPTION
;      OF CDBLK FOR DETAILS OF CODE FOR EXPRESSIONS).
;
;      IF THE EXPRESSION CAN BE EVALUATED BY NAME WE HAVE.
;
;                            (CODE FOR EXPR BY NAME)
;                            =O$RNM
;
;      IF THE EXPRESSION CAN ONLY BE EVALUATED BY VALUE.
;
;                            (CODE FOR EXPR BY VALUE)
;                            =O$RVL
	.PAGE
;
;      FIELD FUNCTION BLOCK (FFBLK)
;
;      A FIELD FUNCTION BLOCK IS USED TO CONTROL THE SELECTION
;      OF A FIELD FROM A PROGRAM DEFINED DATATYPE BLOCK.
;      A CALL TO DATA CREATES AN FFBLK FOR EACH FIELD.
;
;           +------------------------------------+
;           I                FCODE               I
;           +------------------------------------+
;           I                FARGS               I
;           +------------------------------------+
;           I                FFDFP               I
;           +------------------------------------+
;           I                FFNXT               I
;           +------------------------------------+
;           I                FFOFS               I
;           +------------------------------------+
;
	FFDFP==	FARGS+1	;POINTER TO ASSOCIATED DFBLK
	FFNXT==	FFDFP+1	;PTR TO NEXT FFBLK ON CHAIN OR ZERO
	FFOFS==	FFNXT+1	;OFFSET (BYTES) TO FIELD IN PDBLK
	FFSI$==	FFOFS+1	;SIZE OF FFBLK IN WORDS
;
;      THE FCODE FIELD POINTS TO THE ROUTINE B$FFC.
;
;      FARGS ALWAYS CONTAINS ONE.
;
;      FFDFP IS USED TO VERIFY THAT THE CORRECT PROGRAM DEFINED
;      DATATYPE IS BEING ACCESSED BY THIS CALL.
;      FFDFP IS NON-RELOC. BECAUSE DFBLK IS IN STATIC
;
;      FFOFS IS USED TO SELECT THE APPROPRIATE FIELD. NOTE THAT
;      IT IS AN ACTUAL OFFSET (NOT A FIELD NUMBER)
;
;      FFNXT IS USED TO POINT TO THE NEXT FFBLK OF THE SAME NAME
;      IN THE CASE WHERE THERE ARE SEVERAL FIELDS OF THE SAME
;      NAME FOR DIFFERENT DATATYPES. ZERO MARKS THE END OF CHAIN
	.PAGE
;
;      INTEGER CONSTANT BLOCK (ICBLK)
;
;      AN ICBLK IS CREATED FOR EVERY INTEGER REFERENCED OR
;      CREATED BY A PROGRAM. NOTE HOWEVER THAT CERTAIN INTERNAL
;      INTEGER VALUES ARE STORED AS ADDRESSES (E.G. THE LENGTH
;      FIELD IN A STRING CONSTANT BLOCK)
;
;           +------------------------------------+
;           I                ICGET               I
;           +------------------------------------+
;           *                ICVAL               *
;           +------------------------------------+
;
	ICGET==	0		;PTR TO ROUTINE B$ICL TO LOAD INT
	ICVAL==	ICGET+1	;INTEGER VALUE
	ICSI$==	ICVAL+CFP$I	;SIZE OF ICBLK
;
;      THE LENGTH OF THE ICVAL FIELD IS CFP$I.
	.PAGE
;
;      KEYWORD VARIABLE BLOCK (KVBLK)
;
;      A KVBLK IS USED TO REPRESENT A KEYWORD PSEUDO-VARIABLE.
;      A KVBLK IS BUILT FOR EACH KEYWORD REFERENCE (KWNAM).
;
;           +------------------------------------+
;           I                KVTYP               I
;           +------------------------------------+
;           I                KVVAR               I
;           +------------------------------------+
;           I                KVNUM               I
;           +------------------------------------+
;
	KVTYP==	0		;POINTER TO DUMMY ROUTINE B$KVT
	KVVAR==	KVTYP+1	;POINTER TO DUMMY BLOCK TRBKV
	KVNUM==	KVVAR+1	;KEYWORD NUMBER
	KVSI$==	KVNUM+1	;SIZE OF KVBLK
;
;      THE NAME OF A KEYWORD VARIABLE IS REPRESENTED BY A
;      BASE POINTER TO THE KVBLK AND AN OFFSET OF KVVAR. THE
;      VALUE APPEARS TO BE TRAPPED BY THE POINTER TO TRBKV.
	.PAGE
;
;      NAME BLOCK (NMBLK)
;
;      A NAME BLOCK IS USED WHEREVER A NAME MUST BE STORED AS
;      A VALUE FOLLOWING USE OF THE UNARY DOT OPERATOR.
;
;           +------------------------------------+
;           I                NMTYP               I
;           +------------------------------------+
;           I                NMBAS               I
;           +------------------------------------+
;           I                NMOFS               I
;           +------------------------------------+
;
	NMTYP==	0		;PTR TO ROUTINE B$NML TO LOAD NAME
	NMBAS==	NMTYP+1	;BASE POINTER FOR VARIABLE
	NMOFS==	NMBAS+1	;OFFSET FOR VARIABLE
	NMSI$==	NMOFS+1	;SIZE OF NMBLK
;
;      THE ACTUAL FIELD REPRESENTING THE CONTENTS OF THE NAME
;      IS FOUND NMOFS BYTES PAST THE ADDRESS IN NMBAS.
;
;      THE NAME IS SPLIT INTO BASE AND OFFSET FORM TO AVOID
;      CREATION OF A POINTER INTO THE MIDDLE OF A BLOCK WHICH
;      COULD NOT BE HANDLED PROPERLY BY THE GARBAGE COLLECTOR.
;
;      A NAME MAY BE BUILT FOR ANY VARIABLE (SEE SECTION ON
;      REPRESENTATIONS OF VARIABLES) THIS INCLUDES THE
;      CASES OF PSEUDO-VARIABLES.
	.PAGE
;
;      PATTERN BLOCK, NO PARAMETERS (P0BLK)
;
;      A P0BLK IS USED TO REPRESENT PATTERN NODES WHICH DO
;      NOT REQUIRE THE USE OF ANY PARAMETER VALUES.
;
;           +------------------------------------+
;           I                PCODE               I
;           +------------------------------------+
;           I                PTHEN               I
;           +------------------------------------+
;
	PCODE==	0		;PTR TO MATCH ROUTINE (P$XXX)
	PTHEN==	PCODE+1	;POINTER TO SUBSEQUENT NODE
	PASI$==	PTHEN+1	;SIZE OF P0BLK
;
;      PTHEN POINTS TO THE PATTERN BLOCK FOR THE SUBSEQUENT
;      NODE TO BE MATCHED. THIS IS A POINTER TO THE PATTERN
;      BLOCK NDNTH IF THERE IS NO SUBSEQUENT (END OF PATTERN)
;
;      PCODE IS A POINTER TO THE MATCH ROUTINE FOR THE NODE.
	.PAGE
;
;      PATTERN BLOCK (ONE PARAMETER)
;
;      A P1BLK IS USED TO REPRESENT PATTERN NODES WHICH
;      REQUIRE ONE PARAMETER VALUE.
;
;           +------------------------------------+
;           I                PCODE               I
;           +------------------------------------+
;           I                PTHEN               I
;           +------------------------------------+
;           I                PARM1               I
;           +------------------------------------+
;
	PARM1==	PTHEN+1	;FIRST PARAMETER VALUE
	PBSI$==	PARM1+1	;SIZE OF P1BLK IN WORDS
;
;      SEE P0BLK FOR DEFINITIONS OF PCODE, PTHEN
;
;      PARM1 CONTAINS A PARAMETER VALUE USED IN MATCHING THE
;      NODE. FOR EXAMPLE, IN A LEN PATTERN, IT IS THE INTEGER
;      ARGUMENT TO LEN. THE DETAILS OF THE USE OF THE PARAMETER
;      FIELD ARE INCLUDED IN THE DESCRIPTION OF THE INDIVIDUAL
;      MATCH ROUTINES. PARM1 IS ALWAYS AN ADDRESS POINTER WHICH
;      IS PROCESSED BY THE GARBAGE COLLECTOR.
	.PAGE
;
;      PATTERN BLOCK (TWO PARAMETERS)
;
;      A P2BLK IS USED TO REPRESENT PATTERN NODES WHICH
;      REQUIRE TWO PARAMETER VALUES.
;
;           +------------------------------------+
;           I                PCODE               I
;           +------------------------------------+
;           I                PTHEN               I
;           +------------------------------------+
;           I                PARM1               I
;           +------------------------------------+
;           I                PARM2               I
;           +------------------------------------+
;
	PARM2==	PARM1+1	;SECOND PARAMETER VALUE
	PCSI$==	PARM2+1	;SIZE OF P2BLK IN WORDS
;
;      SEE P1BLK FOR DEFINITIONS OF PCODE, PTHEN, PARM1
;
;      PARM2 IS A PARAMETER WHICH PERFORMS THE SAME SORT OF
;      FUNCTION AS PARM1 (SEE DESCRIPTION OF P1BLK).
;
;      PARM2 IS A NON-RELOCATABLE FIELD AND IS NOT
;      PROCESSED BY THE GARBAGE COLLECTOR. ACCORDINGLY, IT MAY
;      NOT CONTAIN A POINTER TO A BLOCK IN DYNAMIC MEMORY.
	.PAGE
;
;      PROGRAM-DEFINED DATATYPE BLOCK
;
;      A PDBLK REPRESENTS THE DATA ITEM FORMED BY A CALL TO A
;      DATATYPE FUNCTION AS DEFINED BY THE SYSTEM FUNCTION DATA.
;
;           +------------------------------------+
;           I                PDTYP               I
;           +------------------------------------+
;           I                IDVAL               I
;           +------------------------------------+
;           I                PDDFP               I
;           +------------------------------------+
;           /                                    /
;           /                PDFLD               /
;           /                                    /
;           +------------------------------------+
;
	PDTYP==	0		;PTR TO DUMMY ROUTINE B$PDT
	PDDFP==	IDVAL+1	;PTR TO ASSOCIATED DFBLK
	PDFLD==	PDDFP+1	;START OF FIELD VALUE POINTERS
	PDFOF==	DFFLD-PDFLD	;DIFFERENCE IN OFFSET TO FIELD PTRS
	PDSI$==	PDFLD		;SIZE OF STANDARD FIELDS IN PDBLK
	PDDFS==	DFSI$-PDSI$	;DIFFERENCE IN DFBLK, PDBLK SIZES
;
;      THE PDDFP POINTER MAY BE USED TO DETERMINE THE DATATYPE
;      AND THE NAMES OF THE FIELDS IF REQUIRED. THE DFBLK ALSO
;      CONTAINS THE LENGTH OF THE PDBLK IN BYTES (FIELD DFPDL).
;      PDDFP IS NON-RELOC. BECAUSE DFBLK IS IN STATIC
;
;      PDFLD VALUES ARE STORED IN ORDER FROM LEFT TO RIGHT.
;      THEY CONTAIN VALUES OR POINTERS TO TRBLK CHAINS.
	.PAGE
;
;      PROGRAM DEFINED FUNCTION BLOCK (PFBLK)
;
;      A PFBLK IS CREATED FOR EACH CALL TO THE DEFINE FUNCTION
;      AND A POINTER TO THE PFBLK PLACED IN THE PROPER VRBLK.
;
;           +------------------------------------+
;           I                FCODE               I
;           +------------------------------------+
;           I                FARGS               I
;           +------------------------------------+
;           I                PFLEN               I
;           +------------------------------------+
;           I                PFVBL               I
;           +------------------------------------+
;           I                PFNLO               I
;           +------------------------------------+
;           I                PFCOD               I
;           +------------------------------------+
;           I                PFCTR               I
;           +------------------------------------+
;           I                PFRTR               I
;           +------------------------------------+
;           /                                    /
;           /                PFARG               /
;           /                                    /
;           +------------------------------------+
;
	PFLEN==	FARGS+1	;LENGTH OF PFBLK IN BYTES
	PFVBL==	PFLEN+1	;POINTER TO VRBLK FOR FUNCTION NAME
	PFNLO==	PFVBL+1	;NUMBER OF LOCALS
	PFCOD==	PFNLO+1	;PTR TO CDBLK FOR FIRST STATEMENT
	PFCTR==	PFCOD+1	;TRBLK PTR IF CALL TRACED ELSE 0
	PFRTR==	PFCTR+1	;TRBLK PTR IF RETURN TRACED ELSE 0
	PFARG==	PFRTR+1	;VRBLK PTRS FOR ARGUMENTS AND LOCALS
	PFAGB==	PFARG-1	;OFFSET BEHIND PFARG FOR ARG, LOCAL
	PFSI$==	PFARG		;NUMBER OF STANDARD FIELDS IN PFBLK
;
;      THE FCODE FIELD POINTS TO THE ROUTINE B$PFC.
;
;      PFARG IS STORED IN THE FOLLOWING ORDER.
;
;           ARGUMENTS (LEFT TO RIGHT)
;           LOCALS (LEFT TO RIGHT)
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	.PAGE
;
;      REAL CONSTANT BLOCK (RCBLK)
;
;      AN RCBLK IS CREATED FOR EVERY REAL REFERENCED OR
;      CREATED BY A PROGRAM.
;
;           +------------------------------------+
;           I                RCGET               I
;           +------------------------------------+
;           *                RCVAL               *
;           +------------------------------------+
;
	RCGET==	0		;PTR TO ROUTINE B$RCL TO LOAD REAL
	RCVAL==	RCGET+1	;REAL VALUE
	RCSI$==	RCVAL+CFP$R	;SIZE OF RCBLK
;
;      THE LENGTH OF THE RCVAL FIELD IS CFP$R.
	.ENDC
	.PAGE
;
;      STRING CONSTANT BLOCK (SCBLK)
;
;      AN SCBLK IS BUILT FOR EVERY STRING REFERENCED OR CREATED
;      BY A PROGRAM.
;
;           +------------------------------------+
;           I                SCGET               I
;           +------------------------------------+
;           I                SCLEN               I
;           +------------------------------------+
;           /                                    /
;           /                SCHAR               /
;           /                                    /
;           +------------------------------------+
;
	SCGET==	0		;PTR TO ROUTINE B$SCL TO LOAD STRING
	SCLEN==	SCGET+1	;LENGTH OF STRING IN CHARACTERS
	SCHAR==	SCLEN+1	;CHARACTERS OF STRING
	SCSI$==	SCHAR		;SIZE OF STANDARD FIELDS IN SCBLK
;
;      THE CHARACTERS OF THE STRING ARE STORED LEFT JUSTIFIED.
;      THE FINAL WORD IS PADDED ON THE RIGHT WITH ZEROS.
;      (I.E. THE CHARACTER WHOSE INTERNAL CODE IS ZERO).
;
;      THE VALUE OF SCLEN MAY NOT EXCEED MXLEN. THIS ENSURES
;      THAT CHARACTER OFFSETS (E.G. THE PATTERN MATCH CURSOR)
;      CAN BE CORRECTLY PROCESSED BY THE GARBAGE COLLECTOR.
;
;      NOTE THAT THE OFFSET TO THE CHARACTERS OF THE STRING
;      IS GIVEN IN BYTES BY CFP$F AND THAT THIS VALUE IS
;      AUTOMATICALLY ALLOWED FOR IN PLC, PSC.
;      NOTE THAT FOR A SPITBOL SCBLK, THE VALUE OF CFP$F
;      IS GIVEN BY CFP$B*SCHAR.
	.PAGE
;
;      SIMPLE EXPRESSION BLOCK (SEBLK)
;
;      AN SEBLK IS USED TO REPRESENT AN EXPRESSION OF THE FORM
;      *(NATURAL VARIABLE). ALL OTHER EXPRESSIONS ARE EXBLKS.
;
;           +------------------------------------+
;           I                SETYP               I
;           +------------------------------------+
;           I                SEVAR               I
;           +------------------------------------+
;
	SETYP==	0		;PTR TO ROUTINE B$SEL TO LOAD EXPR
	SEVAR==	SETYP+1	;PTR TO VRBLK FOR VARIABLE
	SESI$==	SEVAR+1	;LENGTH OF SEBLK IN WORDS
	.PAGE
;
;      STANDARD VARIABLE BLOCK (SVBLK)
;
;      AN SVBLK IS ASSEMBLED IN THE CONSTANT SECTION FOR EACH
;      VARIABLE WHICH SATISFIES ONE OF THE FOLLOWING CONDITIONS.
;
;      1)   IT IS THE NAME OF A SYSTEM FUNCTION
;      2)   IT HAS AN INITIAL VALUE
;      3)   IT HAS A KEYWORD ASSOCIATION
;      4)   IT HAS A STANDARD I/O ASSOCIATION
;      6)   IT HAS A STANDARD LABEL ASSOCIATION
;
;      IF VRBLKS ARE CONSTRUCTED FOR ANY OF THESE VARIABLES,
;      THEN THE VRSVP FIELD POINTS TO THE SVBLK (SEE VRBLK)
;
;           +------------------------------------+
;           I                SVBIT               I
;           +------------------------------------+
;           I                SVLEN               I
;           +------------------------------------+
;           I                SVCHS               I
;           +------------------------------------+
;           I                SVKNM               I
;           +------------------------------------+
;           I                SVFNC               I
;           +------------------------------------+
;           I                SVNAR               I
;           +------------------------------------+
;           I                SVLBL               I
;           +------------------------------------+
;           I                SVVAL               I
;           +------------------------------------+
	.PAGE
;
;      STANDARD VARIABLE BLOCK (CONTINUED)
;
	SVBIT==	0		;BIT STRING INDICATING ATTRIBUTES
	SVLEN==	1		;(=SCLEN) LENGTH OF NAME IN CHARS
	SVCHS==	2		;(=SCHAR) CHARACTERS OF NAME
	SVSI$==	2		;NUMBER OF STANDARD FIELDS IN SVBLK
	SVPRE==	1		;SET IF PREEVALUATION PERMITTED
	SVFFC==	SVPRE+SVPRE	;SET ON IF FAST CALL PERMITTED
	SVCKW==	SVFFC+SVFFC	;SET ON IF KEYWORD VALUE CONSTANT
	SVPRD==	SVCKW+SVCKW	;SET ON IF PREDICATE FUNCTION
	SVNBT==	4		;NUMBER OF BITS TO RIGHT OF SVKNM
	SVKNM==	SVPRD+SVPRD	;SET ON IF KEYWORD ASSOCIATION
	SVFNC==	SVKNM+SVKNM	;SET ON IF SYSTEM FUNCTION
	SVNAR==	SVFNC+SVFNC	;SET ON IF SYSTEM FUNCTION
	SVLBL==	SVNAR+SVNAR	;SET ON IF SYSTEM LABEL
	SVVAL==	SVLBL+SVLBL	;SET ON IF PREDEFINED VALUE
;
;      NOTE THAT THE LAST FIVE BITS CORRESPOND IN ORDER
;      TO THE FIELDS WHICH ARE PRESENT (SEE PROCEDURE GTNVR).
;
;      THE FOLLOWING DEFINITIONS ARE USED IN THE SVBLK TABLE
;
	SVFNF==	SVFNC+SVNAR	;FUNCTION WITH NO FAST CALL
	SVFNN==	SVFNF+SVFFC	;FUNCTION WITH FAST CALL, NO PREEVAL
	SVFNP==	SVFNN+SVPRE	;FUNCTION ALLOWING PREEVALUATION
	SVFPR==	SVFNN+SVPRD	;PREDICATE FUNCTION
	SVFNK==	SVFNN+SVKNM	;NO PREEVAL FUNC + KEYWORD
	SVKWV==	SVKNM+SVVAL	;KEYWORD + VALUE
	SVKWC==	SVCKW+SVKNM	;KEYWORD WITH CONSTANT VALUE
	SVKVC==	SVKWV+SVCKW	;CONSTANT KEYWORD + VALUE
	SVKVL==	SVKVC+SVLBL	;CONSTANT KEYWORD + VALUE + LABEL
	SVFPK==	SVFNP+SVKVC	;PREEVAL FCN + CONST KEYWD + VAL
;
;      THE SVPRE BIT ALLOWS THE COMPILER TO PREEVALUATE A CALL
;      TO THE ASSOCIATED SYSTEM FUNCTION IF ALL THE ARGUMENTS
;      ARE THEMSELVES CONSTANTS. FUNCTIONS IN THIS CATEGORY
;      MUST HAVE NO SIDE EFFECTS AND MUST NEVER CAUSE FAILURE.
;      THE CALL MAY GENERATE AN ERROR CONDITION.
;
;      THE SVFFC BIT ALLOWS THE COMPILER TO GENERATE THE SPECIAL
;      FAST CALL AFTER ADJUSTING THE NUMBER OF ARGUMENTS. ONLY
;      THE ITEM AND APPLY FUNCTIONS FALL OUTSIDE THIS CATEGORY.
;
;      THE SVCKW BIT IS SET IF THE ASSOCIATED KEYWORD VALUE IS
;      A CONSTANT, THUS ALLOWING PREEVALUATION FOR A VALUE CALL.
;
;      THE SVPRD BIT IS SET ON FOR ALL PREDICATE FUNCTIONS TO
;      ENABLE THE SPECIAL CONCATENATION CODE OPTIMIZATION.
	.PAGE
;
;      SVBLK (CONTINUED)
;
;      SVKNM                 KEYWORD NUMBER
;
;           SVKNM IS PRESENT ONLY FOR A STANDARD KEYWORD ASSOC.
;           IT CONTAINS A KEYWORD NUMBER AS DEFINED BY THE
;           KEYWORD NUMBER TABLE GIVEN LATER ON.
;
;      SVFNC                 SYSTEM FUNCTION POINTER
;
;           SVFNC IS PRESENT ONLY FOR A SYSTEM FUNCTION ASSOC.
;           IT IS A POINTER TO THE ACTUAL CODE FOR THE SYSTEM
;           FUNCTION. THE GENERATED CODE FOR A FAST CALL IS A
;           POINTER TO THE SVFNC FIELD OF THE SVBLK FOR THE
;           FUNCTION. THE VRFNC FIELD OF THE VRBLK POINTS TO
;           THIS SAME FIELD, IN WHICH CASE, IT SERVES AS THE
;           FCODE FIELD FOR THE FUNCTION CALL.
;
;      SVNAR                 NUMBER OF FUNCTION ARGUMENTS
;
;           SVNAR IS PRESENT ONLY FOR A SYSTEM FUNCTION ASSOC.
;           IT IS THE NUMBER OF ARGUMENTS REQUIRED FOR A CALL
;           TO THE SYSTEM FUNCTION. THE COMPILER USES THIS
;           VALUE TO ADJUST THE NUMBER OF ARGUMENTS IN A FAST
;           CALL AND IN THE CASE OF A FUNCTION CALLED THROUGH
;           THE VRFNC FIELD OF THE VRBLK, THE SVNAR FIELD
;           SERVES AS THE FARGS FIELD FOR O$FNC. A SPECIAL
;           CASE OCCURS IF THIS VALUE IS SET TO 999. THIS IS
;           USED TO INDICATE THAT THE FUNCTION HAS A VARIABLE
;           NUMBER OF ARGUMENTS AND CAUSES O$FNC TO PASS CONTROL
;           WITHOUT ADJUSTING THE ARGUMENT COUNT. THE ONLY
;           PREDEFINED FUNCTIONS USING THIS ARE APPLY AND ITEM.
;
;      SVLBL                 SYSTEM LABEL POINTER
;
;           SVLBL IS PRESENT ONLY FOR A STANDARD LABEL ASSOC.
;           IT IS A POINTER TO A SYSTEM LABEL ROUTINE (L$XXX).
;           THE VRLBL FIELD OF THE CORRESPONDING VRBLK POINTS TO
;           THE SVLBL FIELD OF THE SVBLK.
;
;      SVVAL                 SYSTEM VALUE POINTER
;
;           SVVAL IS PRESENT ONLY FOR A STANDARD VALUE.
;           IT IS A POINTER TO THE PATTERN NODE (NDXXX) WHICH
;           IS THE STANDARD INITIAL VALUE OF THE VARIABLE.
;           THIS VALUE IS COPIED TO THE VRVAL FIELD OF THE VRBLK
	.PAGE
;
;      SVBLK (CONTINUED)
;
;      KEYWORD NUMBER TABLE
;
;      THE FOLLOWING TABLE GIVES SYMBOLIC NAMES FOR KEYWORD
;      NUMBERS. THESE VALUES ARE STORED IN THE SVKNM FIELD OF
;      SVBLKS AND IN THE KVNUM FIELD OF KVBLKS. SEE ALSO
;      PROCEDURES ASIGN, ACESS AND KWNAM.
;
;      UNPROTECTED KEYWORDS WITH ONE WORD INTEGER VALUES
;
	K$ABE==	0		;ABEND
	K$ANC==	K$ABE+CFP$B	;ANCHOR
	K$COD==	K$ANC+CFP$B	;CODE
	K$DMP==	K$COD+CFP$B	;DUMP
	K$ERL==	K$DMP+CFP$B	;ERRLIMIT
	K$ERT==	K$ERL+CFP$B	;ERRTYPE
	K$FTR==	K$ERT+CFP$B	;FTRACE
	K$INP==	K$FTR+CFP$B	;INPUT
	K$MXL==	K$INP+CFP$B	;MAXLENGTH
	K$OUP==	K$MXL+CFP$B	;OUTPUT
	.IF NOT_EQUAL CNPF
	K$TRA==	K$OUP+CFP$B	;TRACE
	.IF_FALSE
	K$PFL==	K$OUP+CFP$B	;PROFILE
	K$TRA==	K$PFL+CFP$B	;TRACE
	.ENDC
	K$TRM==	K$TRA+CFP$B	;TRIM
;
;      PROTECTED KEYWORDS WITH ONE WORD INTEGER VALUES
;
	K$FNC==	K$TRM+CFP$B	;FNCLEVEL
	K$LST==	K$FNC+CFP$B	;LASTNO
	K$STN==	K$LST+CFP$B	;STNO
;
;      KEYWORDS WITH CONSTANT PATTERN VALUES
;
	K$ABO==	K$STN+CFP$B	;ABORT
	K$ARB==	K$ABO+PASI$	;ARB
	K$BAL==	K$ARB+PASI$	;BAL
	K$FAL==	K$BAL+PASI$	;FAIL
	K$FEN==	K$FAL+PASI$	;FENCE
	K$REM==	K$FEN+PASI$	;REM
	K$SUC==	K$REM+PASI$	;SUCCEED
	.PAGE
;
;      KEYWORD NUMBER TABLE (CONTINUED)
;
;      SPECIAL KEYWORDS
;
	K$ALP==	K$SUC+1	;ALPHABET
	K$RTN==	K$ALP+1	;RTNTYPE
	K$STC==	K$RTN+1	;STCOUNT
	K$ETX==	K$STC+1	;ERRTEXT
	K$STL==	K$ETX+1	;STLIMIT
;
;      RELATIVE OFFSETS OF SPECIAL KEYWORDS
;
	K$$AL==	K$ALP-K$ALP	;ALPHABET
	K$$RT==	K$RTN-K$ALP	;RTNTYPE
	K$$SC==	K$STC-K$ALP	;STCOUNT
	K$$ET==	K$ETX-K$ALP	;ERRTEXT
	K$$SL==	K$STL-K$ALP	;STLIMIT
;
;      SYMBOLS USED IN ASIGN AND ACESS PROCEDURES
;
	K$P$$==	K$FNC		;FIRST PROTECTED KEYWORD
	K$V$$==	K$ABO		;FIRST KEYWORD WITH CONSTANT VALUE
	K$S$$==	K$ALP		;FIRST KEYWORD WITH SPECIAL ACESS
	.PAGE
;
;      FORMAT OF A TABLE BLOCK (TBBLK)
;
;      A TABLE BLOCK IS USED TO REPRESENT A TABLE VALUE.
;      IT IS BUILT BY A CALL TO THE TABLE OR CONVERT FUNCTIONS.
;
;           +------------------------------------+
;           I                TBTYP               I
;           +------------------------------------+
;           I                IDVAL               I
;           +------------------------------------+
;           I                TBLEN               I
;           +------------------------------------+
;           +------------------------------------+
;           I                TBINV               I
;           +------------------------------------+
;           /                                    /
;           /                TBBUK               /
;           /                                    /
;           +------------------------------------+
;
	TBTYP==	0		;POINTER TO DUMMY ROUTINE B$TBT
	TBLEN==	OFFS2		;LENGTH OF TBBLK IN BYTES
	TBINV==	OFFS3		;DEFAULT INITIAL LOOKUP VALUE
	TBBUK==	TBINV+1	;START OF HASH BUCKET POINTERS
	TBSI$==	TBBUK		;SIZE OF STANDARD FIELDS IN TBBLK
	TBNBK==	11		;DEFAULT NO. OF BUCKETS
;
;      THE TABLE BLOCK IS A HASH TABLE WHICH POINTS TO CHAINS
;      OF TABLE ELEMENT BLOCKS REPRESENTING THE ELEMENTS
;      IN THE TABLE WHICH HASH INTO THE SAME BUCKET.
;
;      TBBUK ENTRIES EITHER POINT TO THE FIRST TEBLK ON THE
;      CHAIN OR THEY POINT TO THE TBBLK ITSELF TO INDICATE THE
;      END OF THE CHAIN.
	.PAGE
;
;      TABLE ELEMENT BLOCK (TEBLK)
;
;      A TABLE ELEMENT IS USED TO REPRESENT A SINGLE ENTRY IN
;      A TABLE (SEE DESCRIPTION OF TBBLK FORMAT FOR HASH TABLE)
;
;           +------------------------------------+
;           I                TETYP               I
;           +------------------------------------+
;           I                TESUB               I
;           +------------------------------------+
;           I                TEVAL               I
;           +------------------------------------+
;           I                TENXT               I
;           +------------------------------------+
;
	TETYP==	0		;POINTER TO DUMMY ROUTINE B$TET
	TESUB==	TETYP+1	;SUBSCRIPT VALUE
	TEVAL==	TESUB+1	;(=VRVAL) TABLE ELEMENT VALUE
	TENXT==	TEVAL+1	;LINK TO NEXT TEBLK
;      SEE S$CNV WHERE RELATION IS ASSUMED WITH TENXT AND TBBUK
	TESI$==	TENXT+1	;SIZE OF TEBLK IN WORDS
;
;      TENXT POINTS TO THE NEXT TEBLK ON THE HASH CHAIN FROM THE
;      TBBUK CHAIN FOR THIS HASH INDEX. AT THE END OF THE CHAIN,
;      TENXT POINTS BACK TO THE START OF THE TBBLK.
;
;      TEVAL CONTAINS A DATA POINTER OR A TRBLK POINTER.
;
;      TESUB CONTAINS A DATA POINTER.
	.PAGE
;
;      TRAP BLOCK (TRBLK)
;
;      A TRAP BLOCK IS USED TO REPRESENT A TRACE OR INPUT OR
;      OUTPUT ASSOCIATION IN RESPONSE TO A CALL TO THE TRACE
;      INPUT OR OUTPUT SYSTEM FUNCTIONS. SEE BELOW FOR DETAILS
;
;           +------------------------------------+
;           I                TRIDN               I
;           +------------------------------------+
;           I                TRTYP               I
;           +------------------------------------+
;           I  TRVAL OR TRLBL OR TRNXT OR TRKVR  I
;           +------------------------------------+
;           I       TRTAG OR TRTER OR TRTRF      I
;           +------------------------------------+
;           I            TRFNC OR TRFPT          I
;           +------------------------------------+
;
	TRIDN==	0		;POINTER TO DUMMY ROUTINE B$TRT
	TRTYP==	TRIDN+1	;TRAP TYPE CODE
	TRVAL==	TRTYP+1	;VALUE OF TRAPPED VARIABLE (=VRVAL)
	TRNXT==	TRVAL		;PTR TO NEXT TRBLK ON TRBLK CHAIN
	TRLBL==	TRVAL		;PTR TO ACTUAL LABEL (TRACED LABEL)
	TRKVR==	TRVAL		;VRBLK POINTER FOR KEYWORD TRACE
	TRTAG==	TRVAL+1	;TRACE TAG
	TRTER==	TRTAG		;PTR TO TERMINAL VRBLK OR NULL
	TRTRF==	TRTAG		;PTR TO TRBLK HOLDING FCBLK PTR
	TRFNC==	TRTAG+1	;TRACE FUNCTION VRBLK (ZERO IF NONE)
	TRFPT==	TRFNC		;FCBLK PTR FOR SYSIO
	TRSI$==	TRFNC+1	;NUMBER OF WORDS IN TRBLK
;
	TRTIN==	0		;TRACE TYPE FOR INPUT ASSOCIATION
	TRTAC==	TRTIN+1	;TRACE TYPE FOR ACCESS TRACE
	TRTVL==	TRTAC+1	;TRACE TYPE FOR VALUE TRACE
	TRTOU==	TRTVL+1	;TRACE TYPE FOR OUTPUT ASSOCIATION
	TRTFC==	TRTOU+1	;TRACE TYPE FOR FCBLK IDENTIFICATION
	.PAGE
;
;      TRAP BLOCK (CONTINUED)
;
;      VARIABLE INPUT ASSOCIATION
;
;           THE VALUE FIELD OF THE VARIABLE POINTS TO A TRBLK
;           INSTEAD OF CONTAINING THE DATA VALUE. IN THE CASE
;           OF A NATURAL VARIABLE, THE VRGET AND VRSTO FIELDS
;           CONTAIN =B$VRA AND =B$VRV TO ACTIVATE THE CHECK.
;
;           TRTYP IS SET TO TRTIN
;           TRNXT POINTS TO NEXT TRBLK OR TRVAL HAS VARIABLE VAL
;           TRTER IS A POINTER TO SVBLK IF ASSOCIATION IS
;           FOR INPUT, TERMINAL, ELSE IT IS NULL.
;           TRTRF POINTS TO THE TRAP BLOCK WHICH IN TURN POINTS
;           TO AN FCBLK USED FOR I/O ASSOCIATION.
;           TRFPT IS THE FCBLK PTR RETURNED BY SYSIO.
;
;      VARIABLE ACCESS TRACE ASSOCIATION
;
;           THE VALUE FIELD OF THE VARIABLE POINTS TO A TRBLK
;           INSTEAD OF CONTAINING THE DATA VALUE. IN THE CASE
;           OF A NATURAL VARIABLE, THE VRGET AND VRSTO FIELDS
;           CONTAIN =B$VRA AND =B$VRV TO ACTIVATE THE CHECK.
;
;           TRTYP IS SET TO TRTAC
;           TRNXT POINTS TO NEXT TRBLK OR TRVAL HAS VARIABLE VAL
;           TRTAG IS THE TRACE TAG (0 IF NONE)
;           TRFNC IS THE TRACE FUNCTION VRBLK PTR (0 IF NONE)
;
;      VARIABLE VALUE TRACE ASSOCIATION
;
;           THE VALUE FIELD OF THE VARIABLE POINTS TO A TRBLK
;           INSTEAD OF CONTAINING THE DATA VALUE. IN THE CASE
;           OF A NATURAL VARIABLE, THE VRGET AND VRSTO FIELDS
;           CONTAIN =B$VRA AND =B$VRV TO ACTIVATE THE CHECK.
;
;           TRTYP IS SET TO TRTVL
;           TRNXT POINTS TO NEXT TRBLK OR TRVAL HAS VARIABLE VAL
;           TRTAG IS THE TRACE TAG (0 IF NONE)
;           TRFNC IS THE TRACE FUNCTION VRBLK PTR (0 IF NONE)
	.PAGE
;      TRAP BLOCK (CONTINUED)
;
;      VARIABLE OUTPUT ASSOCIATION
;
;           THE VALUE FIELD OF THE VARIABLE POINTS TO A TRBLK
;           INSTEAD OF CONTAINING THE DATA VALUE. IN THE CASE
;           OF A NATURAL VARIABLE, THE VRGET AND VRSTO FIELDS
;           CONTAIN =B$VRA AND =B$VRV TO ACTIVATE THE CHECK.
;
;           TRTYP IS SET TO TRTOU
;           TRNXT POINTS TO NEXT TRBLK OR TRVAL HAS VARIABLE VAL
;           TRTER IS A POINTER TO SVBLK IF ASSOCIATION IS
;           FOR OUTPUT, TERMINAL, ELSE IT IS NULL.
;           TRTRF POINTS TO THE TRAP BLOCK WHICH IN TURN POINTS
;           TO AN FCBLK USED FOR I/O ASSOCIATION.
;           TRFPT IS THE FCBLK PTR RETURNED BY SYSIO.
;
;      FUNCTION CALL TRACE
;
;           THE PFCTR FIELD OF THE CORRESPONDING PFBLK IS SET
;           TO POINT TO A TRBLK.
;
;           TRTYP IS SET TO TRTIN
;           TRNXT IS ZERO
;           TRTAG IS THE TRACE TAG (0 IF NONE)
;           TRFNC IS THE TRACE FUNCTION VRBLK PTR (0 IF NONE)
;
;      FUNCTION RETURN TRACE
;
;           THE PFRTR FIELD OF THE CORRESPONDING PFBLK IS SET
;           TO POINT TO A TRBLK
;
;           TRTYP IS SET TO TRTIN
;           TRNXT IS ZERO
;           TRTAG IS THE TRACE TAG (0 IF NONE)
;           TRFNC IS THE TRACE FUNCTION VRBLK PTR (0 IF NONE)
;
;      LABEL TRACE
;
;           THE VRLBL OF THE VRBLK FOR THE LABEL IS
;           CHANGED TO POINT TO A TRBLK AND THE VRTRA FIELD IS
;           SET TO B$VRT TO ACTIVATE THE CHECK.
;
;           TRTYP IS SET TO TRTIN
;           TRLBL POINTS TO THE ACTUAL LABEL (CDBLK) VALUE
;           TRTAG IS THE TRACE TAG (0 IF NONE)
;           TRFNC IS THE TRACE FUNCTION VRBLK PTR (0 IF NONE)
	.PAGE
;
;      TRAP BLOCK (CONTINUED)
;
;      KEYWORD TRACE
;
;           KEYWORDS WHICH CAN BE TRACED POSSESS A UNIQUE
;           LOCATION WHICH IS ZERO IF THERE IS NO TRACE AND
;           POINTS TO A TRBLK IF THERE IS A TRACE. THE LOCATIONS
;           ARE AS FOLLOWS.
;
;           R$ERT            ERRTYPE
;           R$FNC            FNCLEVEL
;           R$STC            STCOUNT
;
;           THE FORMAT OF THE TRBLK IS AS FOLLOWS.
;
;           TRTYP IS SET TO TRTIN
;           TRKVR IS A POINTER TO THE VRBLK FOR THE KEYWORD
;           TRTAG IS THE TRACE TAG (0 IF NONE)
;           TRFNC IS THE TRACE FUNCTION VRBLK PTR (0 IF NONE)
;
;      INPUT/OUTPUT FILE ARG1 TRAP BLOCK
;
;           THE VALUE FIELD OF THE VARIABLE POINTS TO A TRBLK
;           INSTEAD OF CONTAINING THE DATA VALUE. IN THE CASE OF
;           A NATURAL VARIABLE, THE VRGET AND VRSTO FIELDS
;           CONTAIN =B$VRA AND =B$VRV. THIS TRAP BLOCK IS USED
;           TO HOLD A POINTER TO THE FCBLK WHICH AN
;           IMPLEMENTATION MAY REQUEST TO HOLD INFORMATION
;           ABOUT A FILE.
;
;           TRTYP IS SET TO TRTFC
;           TRNEXT POINTS TO NEXT TRBLK OR TRVAL IS VARIABLE VAL
;           TRFNM IS 0
;           TRFPT IS THE FCBLK POINTER.
;
;      NOTE THAT WHEN MULTIPLE TRAPS ARE SET ON A VARIABLE
;      THE ORDER IS IN ASCENDING VALUE OF TRTYP FIELD.
;
;      INPUT ASSOCIATION (IF PRESENT)
;      ACCESS TRACE (IF PRESENT)
;      VALUE TRACE (IF PRESENT)
;      OUTPUT ASSOCIATION (IF PRESENT)
;
;      THE ACTUAL VALUE OF THE VARIABLE IS STORED IN THE TRVAL
;      FIELD OF THE LAST TRBLK ON THE CHAIN.
;
;      THIS IMPLEMENTATION DOES NOT PERMIT TRACE OR I/O
;      ASSOCIATIONS TO ANY OF THE PSEUDO-VARIABLES.
	.PAGE
;
;      VECTOR BLOCK (VCBLK)
;
;      A VCBLK IS USED TO REPRESENT AN ARRAY VALUE WHICH HAS
;      ONE DIMENSION WHOSE LOWER BOUND IS ONE. ALL OTHER ARRAYS
;      ARE REPRESENTED BY ARBLKS. A VCBLK IS CREATED BY THE
;      SYSTEM FUNCTION ARRAY (S$ARR) WHEN PASSED AN INTEGER ARG.
;
;           +------------------------------------+
;           I                VCTYP               I
;           +------------------------------------+
;           I                IDVAL               I
;           +------------------------------------+
;           I                VCLEN               I
;           +------------------------------------+
;           I                VCVLS               I
;           +------------------------------------+
;
	VCTYP==	0		;POINTER TO DUMMY ROUTINE B$VCT
	VCLEN==	OFFS2		;LENGTH OF VCBLK IN BYTES
	VCVLS==	OFFS3		;START OF VECTOR VALUES
	VCSI$==	VCVLS		;SIZE OF STANDARD FIELDS IN VCBLK
	VCVLB==	VCVLS-1	;OFFSET ONE WORD BEHIND VCVLS
	VCTBD==	TBSI$-VCSI$	;DIFFERENCE IN SIZES - SEE PRTVL
;
;      VCVLS ARE EITHER DATA POINTERS OR TRBLK POINTERS
;
;      THE DIMENSION CAN BE DEDUCED FROM VCLEN.
	.PAGE
;
;      VARIABLE BLOCK (VRBLK)
;
;      A VARIABLE BLOCK IS BUILT IN THE STATIC MEMORY AREA
;      FOR EVERY VARIABLE REFERENCED OR CREATED BY A PROGRAM.
;
;      NOTE THAT SINCE THESE BLOCKS ONLY OCCUR IN THE STATIC
;      REGION, IT IS PERMISSIBLE TO POINT TO ANY WORD IN
;      THE BLOCK AND THIS IS USED TO PROVIDE THREE DISTINCT
;      ACCESS POINTS FROM THE GENERATED CODE AS FOLLOWS.
;
;      1)   POINT TO VRGET (FIRST WORD OF VRBLK) TO LOAD THE
;           VALUE OF THE VARIABLE ONTO THE MAIN STACK.
;
;      2)   POINT TO VRSTO (SECOND WORD OF VRBLK) TO STORE THE
;           TOP STACK ELEMENT AS THE VALUE OF THE VARIABLE.
;
;      3)   POINT TO VRTRA (FOURTH WORD OF VRBLK) TO JUMP TO
;           THE LABEL ASSOCIATED WITH THE VARIABLE NAME.
;
;           +------------------------------------+
;           I                VRGET               I
;           +------------------------------------+
;           I                VRSTO               I
;           +------------------------------------+
;           I                VRVAL               I
;           +------------------------------------+
;           I                VRTRA               I
;           +------------------------------------+
;           I                VRLBL               I
;           +------------------------------------+
;           I                VRFNC               I
;           +------------------------------------+
;           I                VRNXT               I
;           +------------------------------------+
;           I                VRLEN               I
;           +------------------------------------+
;           /                                    /
;           /            VRCHS = VRSVP           /
;           /                                    /
;           +------------------------------------+
	.PAGE
;
;      VARIABLE BLOCK (CONTINUED)
;
	VRGET==	0		;POINTER TO ROUTINE TO LOAD VALUE
	VRSTO==	VRGET+1	;POINTER TO ROUTINE TO STORE VALUE
	VRVAL==	VRSTO+1	;VARIABLE VALUE
	VRVLO==	VRVAL-VRSTO	;OFFSET TO VALUE FROM STORE FIELD
	VRTRA==	VRVAL+1	;POINTER TO ROUTINE TO JUMP TO LABEL
	VRLBL==	VRTRA+1	;POINTER TO CODE FOR LABEL
	VRLBO==	VRLBL-VRTRA	;OFFSET TO LABEL FROM TRANSFER FIELD
	VRFNC==	VRLBL+1	;POINTER TO FUNCTION BLOCK
	VRNXT==	VRFNC+1	;POINTER TO NEXT VRBLK ON HASH CHAIN
	VRLEN==	VRNXT+1	;LENGTH OF NAME (OR ZERO)
	VRCHS==	VRLEN+1	;CHARACTERS OF NAME (VRLEN GT 0)
	VRSVP==	VRLEN+1	;PTR TO SVBLK (VRLEN EQ 0)
	VRSI$==	VRCHS+1	;NUMBER OF STANDARD FIELDS IN VRBLK
	VRSOF==	VRLEN-SCLEN	;OFFSET TO DUMMY SCBLK FOR NAME
	VRSVO==	VRSVP-VRSOF	;PSEUDO-OFFSET TO VRSVP FIELD
;
;      VRGET = B$VRL IF NOT INPUT ASSOCIATED OR ACCESS TRACED
;      VRGET = B$VRA IF INPUT ASSOCIATED OR ACCESS TRACED
;
;      VRSTO = B$VRS IF NOT OUTPUT ASSOCIATED OR VALUE TRACED
;      VRSTO = B$VRV IF OUTPUT ASSOCIATED OR VALUE TRACED
;      VRSTO = B$VRE IF VALUE IS PROTECTED PATTERN VALUE
;
;      VRVAL POINTS TO THE APPROPRIATE VALUE UNLESS THE
;      VARIABLE IS I/O/TRACE ASSOCIATED IN WHICH CASE, VRVAL
;      POINTS TO AN APPROPRIATE TRBLK (TRAP BLOCK) CHAIN.
;
;      VRTRA = B$VRG IF THE LABEL IS NOT TRACED
;      VRTRA = B$VRT IF THE LABEL IS TRACED
;
;      VRLBL POINTS TO A CDBLK IF THERE IS A LABEL
;      VRLBL POINTS TO THE SVBLK SVLBL FIELD FOR A SYSTEM LABEL
;      VRLBL POINTS TO STNDL FOR AN UNDEFINED LABEL
;      VRLBL POINTS TO A TRBLK IF THE LABEL IS TRACED
;
;      VRFNC POINTS TO A FFBLK FOR A FIELD FUNCTION
;      VRFNC POINTS TO A DFBLK FOR A DATATYPE FUNCTION
;      VRFNC POINTS TO A PFBLK FOR A PROGRAM DEFINED FUNCTION
;      VRFNC POINTS TO A EFBLK FOR AN EXTERNAL LOADED FUNCTION
;      VRFNC POINTS TO SVFNC (SVBLK) FOR A SYSTEM FUNCTION
;      VRFNC POINTS TO STNDF IF THE FUNCTION IS UNDEFINED
;
;      VRNXT POINTS TO THE NEXT VRBLK ON THIS CHAIN UNLESS
;      THIS IS THE END OF THE CHAIN IN WHICH CASE IT IS ZERO.
;
;      VRLEN IS THE NAME LENGTH FOR A NON-SYSTEM VARIABLE.
;      VRLEN IS ZERO FOR A SYSTEM VARIABLE.
;
;      VRCHS IS THE NAME (LJRZ) IF VRLEN IS NON-ZERO.
;      VRSVP IS A PTR TO THE SVBLK IF VRLEN IS ZERO.
	.PAGE
;
;      FORMAT OF A NON-RELOCATABLE EXTERNAL BLOCK (XNBLK)
;
;      AN XNBLK IS A BLOCK REPRESENTING AN UNKNOWN (EXTERNAL)
;      DATA VALUE. THE BLOCK CONTAINS NO POINTERS TO OTHER
;      RELOCATABLE BLOCKS. AN XNBLK IS USED BY EXTERNAL FUNCTION
;      PROCESSING OR POSSIBLY FOR SYSTEM I/O ROUTINES ETC.
;      THE MACRO-SYSTEM ITSELF DOES NOT USE XNBLKS.
;      THIS TYPE OF BLOCK MAY BE USED AS A FILE CONTROL BLOCK.
;      SEE SYSFC,SYSIN,SYSOU,S$INP,S$OUP FOR DETAILS.
;
;           +------------------------------------+
;           I                XNTYP               I
;           +------------------------------------+
;           I                XNLEN               I
;           +------------------------------------+
;           /                                    /
;           /                XNDTA               /
;           /                                    /
;           +------------------------------------+
;
	XNTYP==	0		;POINTER TO DUMMY ROUTINE B$XNT
	XNLEN==	XNTYP+1	;LENGTH OF XNBLK IN BYTES
	XNDTA==	XNLEN+1	;DATA WORDS
	XNSI$==	XNDTA		;SIZE OF STANDARD FIELDS IN XNBLK
;
;      NOTE THAT THE TERM NON-RELOCATABLE REFERS TO THE CONTENTS
;      AND NOT THE BLOCK ITSELF. AN XNBLK CAN BE MOVED AROUND IF
;      IT IS BUILT IN THE DYNAMIC MEMORY AREA.
	.PAGE
;
;      RELOCATABLE EXTERNAL BLOCK (XRBLK)
;
;      AN XRBLK IS A BLOCK REPRESENTING AN UNKNOWN (EXTERNAL)
;      DATA VALUE. THE DATA AREA IN THIS BLOCK CONSISTS ONLY
;      OF ADDRESS VALUES AND ANY ADDRESSES POINTING INTO THE
;      DYNAMIC MEMORY AREA MUST POINT TO THE START OF OTHER
;      DATA BLOCKS. SEE ALSO DESCRIPTION OF XNBLK.
;      THIS TYPE OF BLOCK MAY BE USED AS A FILE CONTROL BLOCK.
;      SEE SYSFC,SYSIN,SYSOU,S$INP,S$OUP FOR DETAILS.
;
;           +------------------------------------+
;           I                XRTYP               I
;           +------------------------------------+
;           I                XRLEN               I
;           +------------------------------------+
;           /                                    /
;           /                XRPTR               /
;           /                                    /
;           +------------------------------------+
;
	XRTYP==	0		;POINTER TO DUMMY ROUTINE B$XRT
	XRLEN==	XRTYP+1	;LENGTH OF XRBLK IN BYTES
	XRPTR==	XRLEN+1	;START OF ADDRESS POINTERS
	XRSI$==	XRPTR		;SIZE OF STANDARD FIELDS IN XRBLK
	.PAGE
;
;      INPUT IMAGE LENGTH
;
	INILN==	132		;DEFAULT IMAGE LENGTH FOR COMPILER [SGD04]
	INILS==	80		;IMAGE LENGTH IF -SEQU IN EFFECT
;
	IONMB==	2		;NAME BASE USED FOR IOCHN IN SYSIO
	IONMO==	4		;NAME OFFSET USED FOR IOCHN IN SYSIO
;
;      IN GENERAL, MEANINGFUL MNEMONICS SHOULD BE USED FOR
;      OFFSETS. HOWEVER FOR SMALL INTEGERS USED OFTEN IN
;      LITERALS THE FOLLOWING GENERAL DEFINITIONS ARE PROVIDED.
;
	NUM01==	1
	NUM02==	2
	NUM03==	3
	NUM04==	4
	NUM05==	5
	NUM06==	6
	NUM07==	7
	NUM08==	8
	NUM09==	9
	NUM10==	10
	NINI8==	998
	NINI9==	999
	THSND==	1000
;
;      NUMBERS OF UNDEFINED SPITBOL OPERATORS
;
	OPBUN==	5		;NO. OF BINARY UNDEFINED OPS
	OPUUN==	6		;NO OF UNARY UNDEFINED OPS
;
;      OFFSETS USED IN PRTSN, PRTMI AND ACESS
;
	PRSNF==	13		;OFFSET USED IN PRTSN
	PRTMF==	15		;OFFSET TO COL 15 (PRTMI)
	RILEN==	120		;BUFFER LENGTH FOR SYSRI
;
;      CODES FOR STAGES OF PROCESSING
;
	STGIC==	0		;INITIAL COMPILE
	STGXC==	STGIC+1	;EXECUTION COMPILE (CODE)
	STGEV==	STGXC+1	;EXPRESSION EVAL DURING EXECUTION
	STGXT==	STGEV+1	;EXECUTION TIME
	STGCE==	STGXT+1	;INITIAL COMPILE AFTER END LINE
	STGXE==	STGCE+1	;EXEC. COMPILE AFTER END LINE
	STGND==	STGCE-STGIC	;DIFFERENCE IN STAGE AFTER END
	STGEE==	STGXE+1	;EVAL EVALUATING EXPRESSION
	STGNO==	STGEE+1	;NUMBER OF CODES
	.PAGE
;
;
;      STATEMENT NUMBER PAD COUNT FOR LISTR
;
	CSN5=	1
	.IF NOT_EQUAL CSN6
	STNPD==	6		;STATEMENT NO. PAD COUNT
	CSN5=	0
	.ENDC
	.IF NOT_EQUAL CSN8
	STNPD==	8		;STATEMENT NO. PAD COUNT
	CSN5=	0
	.ENDC
	.IF NOT_EQUAL CSN5
	STNPD==	5		;STATEMENT NO. PAD COUNT
	.ENDC
;
;      SYNTAX TYPE CODES
;
;      THESE CODES ARE RETURNED FROM THE SCANE PROCEDURE.
;
;      THEY ARE SPACED 3 APART FOR THE BENEFIT OF EXPAN.
;
	T$UOP==	0		;UNARY OPERATOR
	T$LPR==	T$UOP+3	;LEFT PAREN
	T$LBR==	T$LPR+3	;LEFT BRACKET
	T$CMA==	T$LBR+3	;COMMA
	T$FNC==	T$CMA+3	;FUNCTION CALL
	T$VAR==	T$FNC+3	;VARIABLE
	T$CON==	T$VAR+3	;CONSTANT
	T$BOP==	T$CON+3	;BINARY OPERATOR
	T$RPR==	T$BOP+3	;RIGHT PAREN
	T$RBR==	T$RPR+3	;RIGHT BRACKET
	T$COL==	T$RBR+3	;COLON
	T$SMC==	T$COL+3	;SEMI-COLON
;
;      THE FOLLOWING DEFINITIONS ARE USED ONLY IN THE GOTO FIELD
;
	T$FGO==	T$SMC+1	;FAILURE GOTO
	T$SGO==	T$FGO+1	;SUCCESS GOTO
;
;      THE ABOVE CODES ARE GROUPED SO THAT CODES FOR ELEMENTS
;      WHICH CAN LEGITIMATELY IMMEDIATELY PRECEDE A UNARY
;      OPERATOR COME FIRST TO FACILITATE OPERATOR SYNTAX CHECK.
;
	T$UOK==	T$FNC		;LAST CODE OK BEFORE UNARY OPERATOR
	.PAGE
;
;      DEFINITIONS OF VALUES FOR EXPAN JUMP TABLE
;
	T$UO0==	T$UOP+0	;UNARY OPERATOR, STATE ZERO
	T$UO1==	T$UOP+1	;UNARY OPERATOR, STATE ONE
	T$UO2==	T$UOP+2	;UNARY OPERATOR, STATE TWO
	T$LP0==	T$LPR+0	;LEFT PAREN, STATE ZERO
	T$LP1==	T$LPR+1	;LEFT PAREN, STATE ONE
	T$LP2==	T$LPR+2	;LEFT PAREN, STATE TWO
	T$LB0==	T$LBR+0	;LEFT BRACKET, STATE ZERO
	T$LB1==	T$LBR+1	;LEFT BRACKET, STATE ONE
	T$LB2==	T$LBR+2	;LEFT BRACKET, STATE TWO
	T$CM0==	T$CMA+0	;COMMA, STATE ZERO
	T$CM1==	T$CMA+1	;COMMA, STATE ONE
	T$CM2==	T$CMA+2	;COMMA, STATE TWO
	T$FN0==	T$FNC+0	;FUNCTION CALL, STATE ZERO
	T$FN1==	T$FNC+1	;FUNCTION CALL, STATE ONE
	T$FN2==	T$FNC+2	;FUNCTION CALL, STATE TWO
	T$VA0==	T$VAR+0	;VARIABLE, STATE ZERO
	T$VA1==	T$VAR+1	;VARIABLE, STATE ONE
	T$VA2==	T$VAR+2	;VARIABLE, STATE TWO
	T$CO0==	T$CON+0	;CONSTANT, STATE ZERO
	T$CO1==	T$CON+1	;CONSTANT, STATE ONE
	T$CO2==	T$CON+2	;CONSTANT, STATE TWO
	T$BO0==	T$BOP+0	;BINARY OPERATOR, STATE ZERO
	T$BO1==	T$BOP+1	;BINARY OPERATOR, STATE ONE
	T$BO2==	T$BOP+2	;BINARY OPERATOR, STATE TWO
	T$RP0==	T$RPR+0	;RIGHT PAREN, STATE ZERO
	T$RP1==	T$RPR+1	;RIGHT PAREN, STATE ONE
	T$RP2==	T$RPR+2	;RIGHT PAREN, STATE TWO
	T$RB0==	T$RBR+0	;RIGHT BRACKET, STATE ZERO
	T$RB1==	T$RBR+1	;RIGHT BRACKET, STATE ONE
	T$RB2==	T$RBR+2	;RIGHT BRACKET, STATE TWO
	T$CL0==	T$COL+0	;COLON, STATE ZERO
	T$CL1==	T$COL+1	;COLON, STATE ONE
	T$CL2==	T$COL+2	;COLON, STATE TWO
	T$SM0==	T$SMC+0	;SEMICOLON, STATE ZERO
	T$SM1==	T$SMC+1	;SEMICOLON, STATE ONE
	T$SM2==	T$SMC+2	;SEMICOLON, STATE TWO
;
	T$NES==	T$SM2+1	;NUMBER OF ENTRIES IN BRANCH TABLE
	.PAGE
;
;       DEFINITION OF OFFSETS USED IN CONTROL CARD PROCESSING
;
	CC$DO==	0		;-DOUBLE
	CC$DU==	CC$DO+1	;-DUMP
	CC$EJ==	CC$DU+1	;-EJECT
	CC$ER==	CC$EJ+1	;-ERRORS
	CC$EX==	CC$ER+1	;-EXECUTE
	CC$FA==	CC$EX+1	;-FAIL
	CC$LI==	CC$FA+1	;-LIST
	CC$NR==	CC$LI+1	;-NOERRORS
	CC$NX==	CC$NR+1	;-NOEXECUTE
	CC$NF==	CC$NX+1	;-NOFAIL
	CC$NL==	CC$NF+1	;-NOLIST
	CC$NO==	CC$NL+1	;-NOOPT
	CC$NP==	CC$NO+1	;-NOPRINT
	CC$OP==	CC$NP+1	;-OPTIMISE
	CC$PR==	CC$OP+1	;-PRINT
	CC$SI==	CC$PR+1	;-SINGLE
	CC$SP==	CC$SI+1	;-SPACE
	CC$ST==	CC$SP+1	;-STITL
	CC$TI==	CC$ST+1	;-TITLE
	CC$TR==	CC$TI+1	;-TRACE
	CC$NC==	CC$TR+1	;NUMBER OF CONTROL CARDS
	CCNOC==	4		;NO. OF CHARS INCLUDED IN MATCH
	CCOFS==	7		;OFFSET TO START OF TITLE/SUBTITLE
	.PAGE
;
;      DEFINITIONS OF STACK OFFSETS USED IN CMPIL PROCEDURE
;
;      SEE DESCRIPTION AT START OF CMPIL PROCEDURE FOR DETAILS
;      OF USE OF THESE LOCATIONS ON THE STACK.
;
	CMSTM==	0		;TREE FOR STATEMENT BODY
	CMSGO==	CMSTM+1	;TREE FOR SUCCESS GOTO
	CMFGO==	CMSGO+1	;TREE FOR FAIL GOTO
	CMCGO==	CMFGO+1	;CONDITIONAL GOTO FLAG
	CMPCD==	CMCGO+1	;PREVIOUS CDBLK POINTER
	CMFFP==	CMPCD+1	;FAILURE FILL IN FLAG FOR PREVIOUS
	CMFFC==	CMFFP+1	;FAILURE FILL IN FLAG FOR CURRENT
	CMSOP==	CMFFC+1	;SUCCESS FILL IN OFFSET FOR PREVIOUS
	CMSOC==	CMSOP+1	;SUCCESS FILL IN OFFSET FOR CURRENT
	CMLBL==	CMSOC+1	;PTR TO VRBLK FOR CURRENT LABEL
	CMTRA==	CMLBL+1	;PTR TO ENTRY CDBLK
;
	CMNEN==	CMTRA+1	;COUNT OF STACK ENTRIES FOR CMPIL
	.IF NOT_EQUAL CNPF
	.IF_FALSE
;
;      A FEW CONSTANTS USED BY THE PROFILER
	PFPD1==	8		;PAD POSITIONS ...
	PFPD2==	20		;... FOR PROFILE ...
	PFPD3==	32		;... PRINTOUT
	PF$I2==	CFP$I+CFP$I	;SIZE OF TABLE ENTRY (2 INTS)
	.ENDC
;
	.PAGE
	.SUBTITLE S P I T B O L -- CONSTANT SECTION
;
;      THIS SECTION CONSISTS ENTIRELY OF ASSEMBLED CONSTANTS.
;
;      ALL LABEL NAMES ARE FIVE LETTERS. THE ORDER IS
;      APPROXIMATELY ALPHABETICAL, BUT IN SOME CASES (ALWAYS
;      DOCUMENTED), CONSTANTS MUST BE PLACED IN SOME SPECIAL
;      ORDER WHICH MUST NOT BE DISTURBED.
;
;      IT MUST ALSO BE REMEMBERED THAT THERE IS A REQUIREMENT
;      FOR NO FORWARD REFERENCES WHICH ALSO DISTURBS THE
;      ALPHABETICAL ORDER IN SOME CASES.
;
	SEC			;START OF CONSTANT SECTION
;
;      FREE STORE PERCENTAGE (USED BY ALLOC)
;
ALFSP::	.LONG	E$FSP		;FREE STORE PERCENTAGE
;
;      BIT CONSTANTS FOR GENERAL USE
;
BITS0::	.LONG	0		;ALL ZERO BITS
BITS1::	.LONG	1		;ONE BIT IN LOW ORDER POSITION
BITS2::	.LONG	2		;BIT IN POSITION 2
BITS3::	.LONG	4		;BIT IN POSITION 3
BITS4::	.LONG	8		;BIT IN POSITION 4
BITS5::	.LONG	16		;BIT IN POSITION 5
BITS6::	.LONG	32		;BIT IN POSITION 6
BITS7::	.LONG	64		;BIT IN POSITION 7
BITS8::	.LONG	128		;BIT IN POSITION 8
BITS9::	.LONG	256		;BIT IN POSITION 9
BIT10::	.LONG	512		;BIT IN POSITION 10
BITSM::	.LONG	CFP$M		;MASK FOR MAX INTEGER
;
;      BIT CONSTANTS FOR SVBLK (SVBIT FIELD) TESTS
;
BTFNC::	.LONG	SVFNC		;BIT TO TEST FOR FUNCTION
BTKNM::	.LONG	SVKNM		;BIT TO TEST FOR KEYWORD NUMBER
BTLBL::	.LONG	SVLBL		;BIT TO TEST FOR LABEL
BTFFC::	.LONG	SVFFC		;BIT TO TEST FOR FAST CALL
BTCKW::	.LONG	SVCKW		;BIT TO TEST FOR CONSTANT KEYWORD
BTPRD::	.LONG	SVPRD		;BIT TO TEST FOR PREDICATE FUNCTION
BTPRE::	.LONG	SVPRE		;BIT TO TEST FOR PREEVALUATION
BTVAL::	.LONG	SVVAL		;BIT TO TEST FOR VALUE
	.PAGE
;
;      LIST OF NAMES USED FOR CONTROL CARD PROCESSING
;
CCNMS::	.ASCII	/DOUB/
	.ALIGN	LONG,0
	.ASCII	/DUMP/
	.ALIGN	LONG,0
	.ASCII	/EJEC/
	.ALIGN	LONG,0
	.ASCII	/ERRO/
	.ALIGN	LONG,0
	.ASCII	/EXEC/
	.ALIGN	LONG,0
	.ASCII	/FAIL/
	.ALIGN	LONG,0
	.ASCII	/LIST/
	.ALIGN	LONG,0
	.ASCII	/NOER/
	.ALIGN	LONG,0
	.ASCII	/NOEX/
	.ALIGN	LONG,0
	.ASCII	/NOFA/
	.ALIGN	LONG,0
	.ASCII	/NOLI/
	.ALIGN	LONG,0
	.ASCII	/NOOP/
	.ALIGN	LONG,0
	.ASCII	/NOPR/
	.ALIGN	LONG,0
	.ASCII	/OPTI/
	.ALIGN	LONG,0
	.ASCII	/PRIN/
	.ALIGN	LONG,0
	.ASCII	/SING/
	.ALIGN	LONG,0
	.ASCII	/SPAC/
	.ALIGN	LONG,0
	.ASCII	/STIT/
	.ALIGN	LONG,0
	.ASCII	/TITL/
	.ALIGN	LONG,0
	.ASCII	/TRAC/
	.ALIGN	LONG,0
;
;      HEADER MESSAGES FOR DUMPR PROCEDURE (SCBLK FORMAT)
;
DMHDK::	.LONG	B$SCL		;DUMP OF KEYWORD VALUES
	.LONG	22
	.ASCII	/DUMP OF KEYWORD VALUES/
	.ALIGN	LONG,0
;
DMHDV::	.LONG	B$SCL		;DUMP OF NATURAL VARIABLES
	.LONG	25
	.ASCII	/DUMP OF NATURAL VARIABLES/
	.ALIGN	LONG,0
	.PAGE
;
;      MESSAGE TEXT FOR COMPILATION STATISTICS
;
ENCM1::	.LONG	B$SCL
	.LONG	10
	.ASCII	/STORE USED/
	.ALIGN	LONG,0
;
ENCM2::	.LONG	B$SCL
	.LONG	10
	.ASCII	/STORE LEFT/
	.ALIGN	LONG,0
;
ENCM3::	.LONG	B$SCL
	.LONG	11
	.ASCII	/COMP ERRORS/
	.ALIGN	LONG,0
;
ENCM4::	.LONG	B$SCL
	.LONG	14
	.ASCII	/COMP TIME-MSEC/
	.ALIGN	LONG,0
;
ENCM5::	.LONG	B$SCL		;EXECUTION SUPPRESSED
	.LONG	20
	.ASCII	/EXECUTION SUPPRESSED/
	.ALIGN	LONG,0
;
;      STRING CONSTANT FOR ABNORMAL END
;
ENDAB::	.LONG	B$SCL
	.LONG	12
	.ASCII	/ABNORMAL END/
	.ALIGN	LONG,0
	.PAGE
;
;      MEMORY OVERFLOW DURING INITIALISATION
;
ENDMO::	.LONG	B$SCL
ENDML::	.LONG	15
	.ASCII	/MEMORY OVERFLOW/
	.ALIGN	LONG,0
;
;      STRING CONSTANT FOR MESSAGE ISSUED BY L$END
;
ENDMS::	.LONG	B$SCL
	.LONG	10
	.ASCII	/NORMAL END/
	.ALIGN	LONG,0
;
;      FAIL MESSAGE FOR STACK FAIL SECTION
;
ENDSO::	.LONG	B$SCL		;STACK OVERFLOW IN GARBAGE COLLECTOR
	.LONG	36
	.ASCII	/STACK OVERFLOW IN GARBAGE COLLECTION/
	.ALIGN	LONG,0
;
;      STRING CONSTANT FOR TIME UP
;
ENDTU::	.LONG	B$SCL
	.LONG	15
	.ASCII	/ERROR - TIME UP/
	.ALIGN	LONG,0
	.PAGE
;
;      STRING CONSTANT FOR ERROR MESSAGE (ERROR SECTION)
;
ERMMS::	.LONG	B$SCL		;ERROR
	.LONG	5
	.ASCII	/ERROR/
	.ALIGN	LONG,0
;
ERMNS::	.LONG	B$SCL		;STRING / -- /
	.LONG	4
	.ASCII	/ -- /
	.ALIGN	LONG,0
;
;      STRING CONSTANT FOR PAGE NUMBERING
;
LSTMS::	.LONG	B$SCL		;PAGE
	.LONG	5
	.ASCII	/PAGE /
	.ALIGN	LONG,0
;
;      LISTING HEADER MESSAGE
;
HEADR::	.LONG	B$SCL
	.LONG	25
	.ASCII	/MACRO SPITBOL VERSION 3.5/
	.ALIGN	LONG,0
;
HEADV::	.LONG	B$SCL		;FOR EXIT() VERSION NO. CHECK
	.LONG	3
	.ASCII	/3.5/
	.ALIGN	LONG,0
;
;      INTEGER CONSTANTS FOR GENERAL USE
;      ICBLD OPTIMISATION USES THE FIRST THREE.
;
INT$R::	.LONG	B$ICL
INTV0::	.LONG	+0		;0
INTON::	.LONG	B$ICL
INTV1::	.LONG	+1		;1
INTTW::	.LONG	B$ICL
INTV2::	.LONG	+2		;2
INTVT::	.LONG	+10		;10
INTVH::	.LONG	+100		;100
INTTH::	.LONG	+1000		;1000
;
;      TABLE USED IN ICBLD OPTIMISATION
;
INTAB::	.LONG	INT$R		;POINTER TO 0
	.LONG	INTON		;POINTER TO 1
	.LONG	INTTW		;POINTER TO 2
	.PAGE
;
;      SPECIAL PATTERN NODES. THE FOLLOWING PATTERN NODES
;      CONSIST SIMPLY OF A PCODE POINTER, SEE MATCH ROUTINES
;      (P$XXX) FOR FULL DETAILS OF THEIR USE AND FORMAT).
;
NDABB::	.LONG	P$ABB		;ARBNO
NDABD::	.LONG	P$ABD		;ARBNO
NDARC::	.LONG	P$ARC		;ARB
NDEXB::	.LONG	P$EXB		;EXPRESSION
NDFNB::	.LONG	P$FNB		;FENCE()
NDFND::	.LONG	P$FND		;FENCE()
NDEXC::	.LONG	P$EXC		;EXPRESSION
NDIMB::	.LONG	P$IMB		;IMMEDIATE ASSIGNMENT
NDIMD::	.LONG	P$IMD		;IMMEDIATE ASSIGNMENT
NDNTH::	.LONG	P$NTH		;PATTERN END (NULL PATTERN)
NDPAB::	.LONG	P$PAB		;PATTERN ASSIGNMENT
NDPAD::	.LONG	P$PAD		;PATTERN ASSIGNMENT
NDUNA::	.LONG	P$UNA		;ANCHOR POINT MOVEMENT
;
;      KEYWORD CONSTANT PATTERN NODES. THE FOLLOWING NODES ARE
;      USED AS THE VALUES OF PATTERN KEYWORDS AND THE INITIAL
;      VALUES OF THE CORRESPONDING NATURAL VARIABLES. ALL
;      NODES ARE IN P0BLK FORMAT AND THE ORDER IS TIED TO THE
;      DEFINITIONS OF CORRESPONDING K$XXX SYMBOLS.
;
NDABO::	.LONG	P$ABO		;ABORT
	.LONG	NDNTH
NDARB::	.LONG	P$ARB		;ARB
	.LONG	NDNTH
NDBAL::	.LONG	P$BAL		;BAL
	.LONG	NDNTH
NDFAL::	.LONG	P$FAL		;FAIL
	.LONG	NDNTH
NDFEN::	.LONG	P$FEN		;FENCE
	.LONG	NDNTH
NDREM::	.LONG	P$REM		;REM
	.LONG	NDNTH
NDSUC::	.LONG	P$SUC		;SUCCEED
	.LONG	NDNTH
;
;      NULL STRING. ALL NULL VALUES POINT TO THIS STRING. THE
;      SVCHS FIELD CONTAINS A BLANK TO PROVIDE FOR EASY DEFAULT
;      PROCESSING IN TRACE, STOPTR, LPAD AND RPAD.
;      NULLW CONTAINS 10 BLANKS WHICH ENSURES AN ALL BLANK WORD
;      BUT FOR VERY EXCEPTIONAL MACHINES.
;
NULLS::	.LONG	B$SCL		;NULL STRING VALUE
	.LONG	0		;SCLEN = 0
NULLW::	.ASCII	/          /
	.ALIGN	LONG,0
	.PAGE
;
;      OPERATOR DOPE VECTORS (SEE DVBLK FORMAT)
;
OPDVC::	.LONG	O$CNC		;CONCATENATION
	.LONG	C$CNC
	.LONG	LLCNC
	.LONG	RRCNC
;
;      OPDVS IS USED WHEN SCANNING BELOW THE TOP LEVEL TO INSURE THAT
;      THE CONCATENATION WILL NOT BE LATER MISTAKEN FOR PATTERN
;      MATCHING
;
OPDVP::	.LONG	O$CNC		;CONCATENATION - NOT PATTERN MATCH
	.LONG	C$CNP
	.LONG	LLCNC
	.LONG	RRCNC
;
;      NOTE THAT THE ORDER OF THE REMAINING ENTRIES IS TIED TO
;      THE ORDER OF THE CODING IN THE SCANE PROCEDURE.
;
OPDVS::	.LONG	O$ASS		;ASSIGNMENT
	.LONG	C$ASS
	.LONG	LLASS
	.LONG	RRASS
;
	.LONG	6		;UNARY EQUAL
	.LONG	C$UUO
	.LONG	LLUNO
;
	.LONG	O$PMV		;PATTERN MATCH
	.LONG	C$PMT
	.LONG	LLPMT
	.LONG	RRPMT
;
	.LONG	O$INT		;INTERROGATION
	.LONG	C$UVL
	.LONG	LLUNO
;
	.LONG	1		;BINARY AMPERSAND
	.LONG	C$UBO
	.LONG	LLAMP
	.LONG	RRAMP
;
	.LONG	O$KWV		;KEYWORD REFERENCE
	.LONG	C$KEY
	.LONG	LLUNO
;
	.LONG	O$ALT		;ALTERNATION
	.LONG	C$ALT
	.LONG	LLALT
	.LONG	RRALT
	.PAGE
;
;      OPERATOR DOPE VECTORS (CONTINUED)
;
	.LONG	5		;UNARY VERTICAL BAR
	.LONG	C$UUO
	.LONG	LLUNO
;
	.LONG	0		;BINARY AT
	.LONG	C$UBO
	.LONG	LLATS
	.LONG	RRATS
;
	.LONG	O$CAS		;CURSOR ASSIGNMENT
	.LONG	C$UNM
	.LONG	LLUNO
;
	.LONG	2		;BINARY NUMBER SIGN
	.LONG	C$UBO
	.LONG	LLNUM
	.LONG	RRNUM
;
	.LONG	7		;UNARY NUMBER SIGN
	.LONG	C$UUO
	.LONG	LLUNO
;
	.LONG	O$DVD		;DIVISION
	.LONG	C$BVL
	.LONG	LLDVD
	.LONG	RRDVD
;
	.LONG	9		;UNARY SLASH
	.LONG	C$UUO
	.LONG	LLUNO
;
	.LONG	O$MLT		;MULTIPLICATION
	.LONG	C$BVL
	.LONG	LLMLT
	.LONG	RRMLT
	.PAGE
;
;      OPERATOR DOPE VECTORS (CONTINUED)
;
	.LONG	0		;DEFERRED EXPRESSION
	.LONG	C$DEF
	.LONG	LLUNO
;
	.LONG	3		;BINARY PERCENT
	.LONG	C$UBO
	.LONG	LLPCT
	.LONG	RRPCT
;
	.LONG	8		;UNARY PERCENT
	.LONG	C$UUO
	.LONG	LLUNO
;
	.LONG	O$EXP		;EXPONENTIATION
	.LONG	C$BVL
	.LONG	LLEXP
	.LONG	RREXP
;
	.LONG	10		;UNARY EXCLAMATION
	.LONG	C$UUO
	.LONG	LLUNO
;
	.LONG	O$IMA		;IMMEDIATE ASSIGNMENT
	.LONG	C$BVN
	.LONG	LLDLD
	.LONG	RRDLD
;
	.LONG	O$INV		;INDIRECTION
	.LONG	C$IND
	.LONG	LLUNO
;
	.LONG	4		;BINARY NOT
	.LONG	C$UBO
	.LONG	LLNOT
	.LONG	RRNOT
;
	.LONG	0		;NEGATION
	.LONG	C$NEG
	.LONG	LLUNO
	.PAGE
;
;      OPERATOR DOPE VECTORS (CONTINUED)
;
	.LONG	O$SUB		;SUBTRACTION
	.LONG	C$BVL
	.LONG	LLPLM
	.LONG	RRPLM
;
	.LONG	O$COM		;COMPLEMENTATION
	.LONG	C$UVL
	.LONG	LLUNO
;
	.LONG	O$ADD		;ADDITION
	.LONG	C$BVL
	.LONG	LLPLM
	.LONG	RRPLM
;
	.LONG	O$AFF		;AFFIRMATION
	.LONG	C$UVL
	.LONG	LLUNO
;
	.LONG	O$PAS		;PATTERN ASSIGNMENT
	.LONG	C$BVN
	.LONG	LLDLD
	.LONG	RRDLD
;
	.LONG	O$NAM		;NAME REFERENCE
	.LONG	C$UNM
	.LONG	LLUNO
;
;      SPECIAL DVS FOR GOTO OPERATORS (SEE PROCEDURE SCNGF)
;
OPDVD::	.LONG	O$GOD		;DIRECT GOTO
	.LONG	C$UVL
	.LONG	LLUNO
;
OPDVN::	.LONG	O$GOC		;COMPLEX NORMAL GOTO
	.LONG	C$UNM
	.LONG	LLUNO
	.PAGE
;
;      OPERATOR ENTRY ADDRESS POINTERS, USED IN CODE
;
OAMN$::	.LONG	O$AMN		;ARRAY REF (MULTI-SUBS BY VALUE)
OAMV$::	.LONG	O$AMV		;ARRAY REF (MULTI-SUBS BY VALUE)
OAON$::	.LONG	O$AON		;ARRAY REF (ONE SUB BY NAME)
OAOV$::	.LONG	O$AOV		;ARRAY REF (ONE SUB BY VALUE)
OCER$::	.LONG	O$CER		;COMPILATION ERROR
OFEX$::	.LONG	O$FEX		;FAILURE IN EXPRESSION EVALUATION
OFIF$::	.LONG	O$FIF		;FAILURE DURING GOTO EVALUATION
OFNC$::	.LONG	O$FNC		;FUNCTION CALL (MORE THAN ONE ARG)
OFNE$::	.LONG	O$FNE		;FUNCTION NAME ERROR
OFNS$::	.LONG	O$FNS		;FUNCTION CALL (SINGLE ARGUMENT)
OGOF$::	.LONG	O$GOF		;SET GOTO FAILURE TRAP
OINN$::	.LONG	O$INN		;INDIRECTION BY NAME
OKWN$::	.LONG	O$KWN		;KEYWORD REFERENCE BY NAME
OLEX$::	.LONG	O$LEX		;LOAD EXPRESSION BY NAME
OLPT$::	.LONG	O$LPT		;LOAD PATTERN
OLVN$::	.LONG	O$LVN		;LOAD VARIABLE NAME
ONTA$::	.LONG	O$NTA		;NEGATION, FIRST ENTRY
ONTB$::	.LONG	O$NTB		;NEGATION, SECOND ENTRY
ONTC$::	.LONG	O$NTC		;NEGATION, THIRD ENTRY
OPMN$::	.LONG	O$PMN		;PATTERN MATCH BY NAME
OPMS$::	.LONG	O$PMS		;PATTERN MATCH (STATEMENT)
OPOP$::	.LONG	O$POP		;POP TOP STACK ITEM
ORNM$::	.LONG	O$RNM		;RETURN NAME FROM EXPRESSION
ORPL$::	.LONG	O$RPL		;PATTERN REPLACEMENT
ORVL$::	.LONG	O$RVL		;RETURN VALUE FROM EXPRESSION
OSLA$::	.LONG	O$SLA		;SELECTION, FIRST ENTRY
OSLB$::	.LONG	O$SLB		;SELECTION, SECOND ENTRY
OSLC$::	.LONG	O$SLC		;SELECTION, THIRD ENTRY
OSLD$::	.LONG	O$SLD		;SELECTION, FOURTH ENTRY
OSTP$::	.LONG	O$STP		;STOP EXECUTION
OUNF$::	.LONG	O$UNF		;UNEXPECTED FAILURE
	.PAGE
;
;      TABLE OF NAMES OF UNDEFINED BINARY OPERATORS FOR OPSYN
;
OPSNB::	.LONG	CH$AT		;AT
	.LONG	CH$AM		;AMPERSAND
	.LONG	CH$NM		;NUMBER
	.LONG	CH$PC		;PERCENT
	.LONG	CH$NT		;NOT
;
;      TABLE OF NAMES OF UNDEFINED UNARY OPERATORS FOR OPSYN
;
OPNSU::	.LONG	CH$BR		;VERTICAL BAR
	.LONG	CH$EQ		;EQUAL
	.LONG	CH$NM		;NUMBER
	.LONG	CH$PC		;PERCENT
	.LONG	CH$SL		;SLASH
	.LONG	CH$EX		;EXCLAMATION
	.IF NOT_EQUAL CNPF
	.IF_FALSE
;
;      ADDRESS CONST CONTAINING PROFILE TABLE ENTRY SIZE (2 INTS)
;
PFI2A::	.LONG	PF$I2
;
;      PROFILER MESSAGE STRINGS
;
PFMS1::	.LONG	B$SCL
	.LONG	15
	.ASCII	/PROGRAM PROFILE/
	.ALIGN	LONG,0
PFMS2::	.LONG	B$SCL
	.LONG	42
	.ASCII	/STMT    NUMBER OF     -- EXECUTION TIME --/
	.ALIGN	LONG,0
PFMS3::	.LONG	B$SCL
	.LONG	47
	.ASCII	/NUMBER  EXECUTIONS  TOTAL(MSEC) PER EXCN(MCSEC)/
	.ALIGN	LONG,0
	.ENDC
;
	.IF NOT_EQUAL CNRA
	.IF_FALSE
;
;      REAL CONSTANTS FOR GENERAL USE. NOTE THAT THE CONSTANTS
;      STARTING AT REAV1 FORM A POWERS OF TEN TABLE (GTSTG)
;
REAV0::	.FLOAT	+0.0		;0.0
REAP1::	.FLOAT	+0.1		;0.1
REAP5::	.FLOAT	+0.5		;0.5
REAV1::	.FLOAT	+1.0		;10**0
REAVT::	.FLOAT	+1.0E+1	;10**1
	.FLOAT	+1.0E+2	;10**2
	.FLOAT	+1.0E+3	;10**3
	.FLOAT	+1.0E+4	;10**4
	.FLOAT	+1.0E+5	;10**5
	.FLOAT	+1.0E+6	;10**6
	.FLOAT	+1.0E+7	;10**7
	.FLOAT	+1.0E+8	;10**8
	.FLOAT	+1.0E+9	;10**9
REATT::	.FLOAT	+1.0E+10	;10**10
	.ENDC
	.PAGE
;
;      STRING CONSTANTS (SCBLK FORMAT) FOR DTYPE PROCEDURE
;
SCARR::	.LONG	B$SCL		;ARRAY
	.LONG	5
	.ASCII	/ARRAY/
	.ALIGN	LONG,0
;
SCCOD::	.LONG	B$SCL		;CODE
	.LONG	4
	.ASCII	/CODE/
	.ALIGN	LONG,0
;
SCEXP::	.LONG	B$SCL		;EXPRESSION
	.LONG	10
	.ASCII	/EXPRESSION/
	.ALIGN	LONG,0
;
SCEXT::	.LONG	B$SCL		;EXTERNAL
	.LONG	8
	.ASCII	/EXTERNAL/
	.ALIGN	LONG,0
;
SCINT::	.LONG	B$SCL		;INTEGER
	.LONG	7
	.ASCII	/INTEGER/
	.ALIGN	LONG,0
;
SCNAM::	.LONG	B$SCL		;NAME
	.LONG	4
	.ASCII	/NAME/
	.ALIGN	LONG,0
;
SCNUM::	.LONG	B$SCL		;NUMERIC
	.LONG	7
	.ASCII	/NUMERIC/
	.ALIGN	LONG,0
;
SCPAT::	.LONG	B$SCL		;PATTERN
	.LONG	7
	.ASCII	/PATTERN/
	.ALIGN	LONG,0
	.IF NOT_EQUAL CNRA
	.IF_FALSE
;
SCREA::	.LONG	B$SCL		;REAL
	.LONG	4
	.ASCII	/REAL/
	.ALIGN	LONG,0
	.ENDC
;
SCSTR::	.LONG	B$SCL		;STRING
	.LONG	6
	.ASCII	/STRING/
	.ALIGN	LONG,0
;
SCTAB::	.LONG	B$SCL		;TABLE
	.LONG	5
	.ASCII	/TABLE/
	.ALIGN	LONG,0
	.PAGE
;
;      STRING CONSTANTS (SCBLK FORMAT) FOR KVRTN (SEE RETRN)
;
SCFRT::	.LONG	B$SCL		;FRETURN
	.LONG	7
	.ASCII	/FRETURN/
	.ALIGN	LONG,0
;
SCNRT::	.LONG	B$SCL		;NRETURN
	.LONG	7
	.ASCII	/NRETURN/
	.ALIGN	LONG,0
;
SCRTN::	.LONG	B$SCL		;RETURN
	.LONG	6
	.ASCII	/RETURN/
	.ALIGN	LONG,0
;
;      DATATYPE NAME TABLE FOR DTYPE PROCEDURE. THE ORDER OF
;      THESE ENTRIES IS TIED TO THE B$XXX DEFINITIONS FOR BLOCKS
;
SCNMT::	.LONG	SCARR		;ARBLK     ARRAY
	.LONG	SCCOD		;CDBLK     CODE
	.LONG	SCEXP		;EXBLK     EXPRESSION
	.LONG	SCINT		;ICBLK     INTEGER
	.LONG	SCNAM		;NMBLK     NAME
	.LONG	SCPAT		;P0BLK     PATTERN
	.LONG	SCPAT		;P1BLK     PATTERN
	.LONG	SCPAT		;P2BLK     PATTERN
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	.LONG	SCREA		;RCBLK     REAL
	.ENDC
	.LONG	SCSTR		;SCBLK     STRING
	.LONG	SCEXP		;SEBLK     EXPRESSION
	.LONG	SCTAB		;TBBLK     TABLE
	.LONG	SCARR		;VCBLK     ARRAY
	.LONG	SCEXT		;XNBLK     EXTERNAL
	.LONG	SCEXT		;XRBLK     EXTERNAL
;
	.IF NOT_EQUAL CNRA
	.IF_FALSE
;      STRING CONSTANT FOR REAL ZERO
;
SCRE0::	.LONG	B$SCL
	.LONG	2
	.ASCII	/0./
	.ALIGN	LONG,0
	.ENDC
	.PAGE
;
;      USED TO RE-INITIALISE KVSTL
;
STLIM::	.LONG	+1000000000	;DEFAULT STATEMENT LIMIT
;
;      DUMMY FUNCTION BLOCK USED FOR UNDEFINED FUNCTIONS
;
STNDF::	.LONG	O$FUN		;PTR TO UNDEFINED FUNCTION ERR CALL
	.LONG	0		;DUMMY FARGS COUNT FOR CALL CIRCUIT
;
;      DUMMY CODE BLOCK USED FOR UNDEFINED LABELS
;
STNDL::	.LONG	L$UND		;CODE PTR POINTS TO UNDEFINED LBL
;
;      DUMMY OPERATOR BLOCK USED FOR UNDEFINED OPERATORS
;
STNDO::	.LONG	O$OUN		;PTR TO UNDEFINED OPERATOR ERR CALL
	.LONG	0		;DUMMY FARGS COUNT FOR CALL CIRCUIT
;
;      STANDARD VARIABLE BLOCK. THIS BLOCK IS USED TO INITIALIZE
;      THE FIRST SEVEN FIELDS OF A NEWLY CONSTRUCTED VRBLK.
;      ITS FORMAT IS TIED TO THE VRBLK DEFINITIONS (SEE GTNVR).
;
STNVR::	.LONG	B$VRL		;VRGET
	.LONG	B$VRS		;VRSTO
	.LONG	NULLS		;VRVAL
	.LONG	B$VRG		;VRTRA
	.LONG	STNDL		;VRLBL
	.LONG	STNDF		;VRFNC
	.LONG	0		;VRNXT
	.PAGE
;
;      MESSAGES USED IN END OF RUN PROCESSING (STOPR)
;
STPM1::	.LONG	B$SCL		;IN STATEMENT
	.LONG	12
	.ASCII	/IN STATEMENT/
	.ALIGN	LONG,0
;
STPM2::	.LONG	B$SCL
	.LONG	14
	.ASCII	/STMTS EXECUTED/
	.ALIGN	LONG,0
;
STPM3::	.LONG	B$SCL
	.LONG	13
	.ASCII	/RUN TIME-MSEC/
	.ALIGN	LONG,0
;
STPM4::	.LONG	B$SCL
	.LONG	12
	.ASCII	$MCSEC / STMT$
	.ALIGN	LONG,0
;
STPM5::	.LONG	B$SCL
	.LONG	13
	.ASCII	/REGENERATIONS/
	.ALIGN	LONG,0
;
;      CHARS FOR /TU/ ENDING CODE
;
STRTU::	.ASCII	/TU/
	.ALIGN	LONG,0
;
;      TABLE USED BY CONVERT FUNCTION TO CHECK DATATYPE NAME
;      THE ENTRIES ARE ORDERED TO CORRESPOND TO BRANCH TABLE
;      IN S$CNV
;
SVCTB::	.LONG	SCSTR		;STRING
	.LONG	SCINT		;INTEGER
	.LONG	SCNAM		;NAME
	.LONG	SCPAT		;PATTERN
	.LONG	SCARR		;ARRAY
	.LONG	SCTAB		;TABLE
	.LONG	SCEXP		;EXPRESSION
	.LONG	SCCOD		;CODE
	.LONG	SCNUM		;NUMERIC
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	.LONG	SCREA		;REAL
	.ENDC
	.LONG	0		;ZERO MARKS END OF LIST
	.PAGE
;
;      MESSAGES (SCBLK FORMAT) USED BY TRACE PROCEDURES
;
;
TMASB::	.LONG	B$SCL		;ASTERISKS FOR TRACE STATEMENT NO
	.LONG	13
	.ASCII	/************ /
	.ALIGN	LONG,0
;
TMBEB::	.LONG	B$SCL		;BLANK-EQUAL-BLANK
	.LONG	3
	.ASCII	/ = /
	.ALIGN	LONG,0
;
;      DUMMY TRBLK FOR EXPRESSION VARIABLE
;
TRBEV::	.LONG	B$TRT		;DUMMY TRBLK
;
;      DUMMY TRBLK FOR KEYWORD VARIABLE
;
TRBKV::	.LONG	B$TRT		;DUMMY TRBLK
;
;      DUMMY CODE BLOCK TO RETURN CONTROL TO TRXEQ PROCEDURE
;
TRXDR::	.LONG	O$TXR		;BLOCK POINTS TO RETURN ROUTINE
TRXDC::	.LONG	TRXDR		;POINTER TO BLOCK
	.PAGE
;
;      STANDARD VARIABLE BLOCKS
;
;      SEE SVBLK FORMAT FOR FULL DETAILS OF THE FORMAT. THE
;      VRBLKS ARE ORDERED BY LENGTH AND WITHIN EACH LENGTH THE
;      ORDER IS ALPHABETICAL BY NAME OF THE VARIABLE.
;
V$EQF::	.LONG	SVFPR		;EQ
	.LONG	2
	.ASCII	/EQ/
	.ALIGN	LONG,0
	.LONG	S$EQF
	.LONG	2
;
V$GEF::	.LONG	SVFPR		;GE
	.LONG	2
	.ASCII	/GE/
	.ALIGN	LONG,0
	.LONG	S$GEF
	.LONG	2
;
V$GTF::	.LONG	SVFPR		;GT
	.LONG	2
	.ASCII	/GT/
	.ALIGN	LONG,0
	.LONG	S$GTF
	.LONG	2
;
V$LEF::	.LONG	SVFPR		;LE
	.LONG	2
	.ASCII	/LE/
	.ALIGN	LONG,0
	.LONG	S$LEF
	.LONG	2
;
V$LTF::	.LONG	SVFPR		;LT
	.LONG	2
	.ASCII	/LT/
	.ALIGN	LONG,0
	.LONG	S$LTF
	.LONG	2
;
V$NEF::	.LONG	SVFPR		;NE
	.LONG	2
	.ASCII	/NE/
	.ALIGN	LONG,0
	.LONG	S$NEF
	.LONG	2
;
V$ANY::	.LONG	SVFNP		;ANY
	.LONG	3
	.ASCII	/ANY/
	.ALIGN	LONG,0
	.LONG	S$ANY
	.LONG	1
;
V$ARB::	.LONG	SVKVC		;ARB
	.LONG	3
	.ASCII	/ARB/
	.ALIGN	LONG,0
	.LONG	K$ARB
	.LONG	NDARB
	.PAGE
;
;      STANDARD VARIABLE BLOCKS (CONTINUED)
;
V$ARG::	.LONG	SVFNN		;ARG
	.LONG	3
	.ASCII	/ARG/
	.ALIGN	LONG,0
	.LONG	S$ARG
	.LONG	2
;
V$BAL::	.LONG	SVKVC		;BAL
	.LONG	3
	.ASCII	/BAL/
	.ALIGN	LONG,0
	.LONG	K$BAL
	.LONG	NDBAL
;
V$END::	.LONG	SVLBL		;END
	.LONG	3
	.ASCII	/END/
	.ALIGN	LONG,0
	.LONG	L$END
;
V$LEN::	.LONG	SVFNP		;LEN
	.LONG	3
	.ASCII	/LEN/
	.ALIGN	LONG,0
	.LONG	S$LEN
	.LONG	1
;
V$LEQ::	.LONG	SVFPR		;LEQ
	.LONG	3
	.ASCII	/LEQ/
	.ALIGN	LONG,0
	.LONG	S$LEQ
	.LONG	2
;
V$LGE::	.LONG	SVFPR		;LGE
	.LONG	3
	.ASCII	/LGE/
	.ALIGN	LONG,0
	.LONG	S$LGE
	.LONG	2
;
V$LGT::	.LONG	SVFPR		;LGT
	.LONG	3
	.ASCII	/LGT/
	.ALIGN	LONG,0
	.LONG	S$LGT
	.LONG	2
;
V$LLE::	.LONG	SVFPR		;LLE
	.LONG	3
	.ASCII	/LLE/
	.ALIGN	LONG,0
	.LONG	S$LLE
	.LONG	2
	.PAGE
;
;      STANDARD VARIABLE BLOCKS (CONTINUED)
;
V$LLT::	.LONG	SVFPR		;LLT
	.LONG	3
	.ASCII	/LLT/
	.ALIGN	LONG,0
	.LONG	S$LLT
	.LONG	2
;
V$LNE::	.LONG	SVFPR		;LNE
	.LONG	3
	.ASCII	/LNE/
	.ALIGN	LONG,0
	.LONG	S$LNE
	.LONG	2
;
V$POS::	.LONG	SVFNP		;POS
	.LONG	3
	.ASCII	/POS/
	.ALIGN	LONG,0
	.LONG	S$POS
	.LONG	1
;
V$REM::	.LONG	SVKVC		;REM
	.LONG	3
	.ASCII	/REM/
	.ALIGN	LONG,0
	.LONG	K$REM
	.LONG	NDREM
;
V$TAB::	.LONG	SVFNP		;TAB
	.LONG	3
	.ASCII	/TAB/
	.ALIGN	LONG,0
	.LONG	S$TAB
	.LONG	1
;
V$COD::	.LONG	SVFNK		;CODE
	.LONG	4
	.ASCII	/CODE/
	.ALIGN	LONG,0
	.LONG	K$COD
	.LONG	S$COD
	.LONG	1
;
V$COP::	.LONG	SVFNN		;COPY
	.LONG	4
	.ASCII	/COPY/
	.ALIGN	LONG,0
	.LONG	S$COP
	.LONG	1
	.PAGE
;
;      STANDARD VARIABLE BLOCKS (CONTINUED)
;
V$DAT::	.LONG	SVFNN		;DATA
	.LONG	4
	.ASCII	/DATA/
	.ALIGN	LONG,0
	.LONG	S$DAT
	.LONG	1
;
V$DTE::	.LONG	SVFNN		;DATE
	.LONG	4
	.ASCII	/DATE/
	.ALIGN	LONG,0
	.LONG	S$DTE
	.LONG	0
;
V$DMP::	.LONG	SVFNK		;DUMP
	.LONG	4
	.ASCII	/DUMP/
	.ALIGN	LONG,0
	.LONG	K$DMP
	.LONG	S$DMP
	.LONG	1
;
V$DUP::	.LONG	SVFNN		;DUPL
	.LONG	4
	.ASCII	/DUPL/
	.ALIGN	LONG,0
	.LONG	S$DUP
	.LONG	2
;
V$EVL::	.LONG	SVFNN		;EVAL
	.LONG	4
	.ASCII	/EVAL/
	.ALIGN	LONG,0
	.LONG	S$EVL
	.LONG	1
	.IF NOT_EQUAL CNEX
	.IF_FALSE
;
V$EXT::	.LONG	SVFNN		;EXIT
	.LONG	4
	.ASCII	/EXIT/
	.ALIGN	LONG,0
	.LONG	S$EXT
	.LONG	1
	.ENDC
;
V$FAL::	.LONG	SVKVC		;FAIL
	.LONG	4
	.ASCII	/FAIL/
	.ALIGN	LONG,0
	.LONG	K$FAL
	.LONG	NDFAL
;
V$HST::	.LONG	SVFNN		;HOST
	.LONG	4
	.ASCII	/HOST/
	.ALIGN	LONG,0
	.LONG	S$HST
	.LONG	3
	.PAGE
;
;      STANDARD VARIABLE BLOCKS (CONTINUED)
;
V$ITM::	.LONG	SVFNF		;ITEM
	.LONG	4
	.ASCII	/ITEM/
	.ALIGN	LONG,0
	.LONG	S$ITM
	.LONG	999
	.IF NOT_EQUAL CNLD
	.IF_FALSE
;
V$LOD::	.LONG	SVFNN		;LOAD
	.LONG	4
	.ASCII	/LOAD/
	.ALIGN	LONG,0
	.LONG	S$LOD
	.LONG	2
	.ENDC
;
V$LPD::	.LONG	SVFNP		;LPAD
	.LONG	4
	.ASCII	/LPAD/
	.ALIGN	LONG,0
	.LONG	S$LPD
	.LONG	3
;
V$RPD::	.LONG	SVFNP		;RPAD
	.LONG	4
	.ASCII	/RPAD/
	.ALIGN	LONG,0
	.LONG	S$RPD
	.LONG	3
;
V$RPS::	.LONG	SVFNP		;RPOS
	.LONG	4
	.ASCII	/RPOS/
	.ALIGN	LONG,0
	.LONG	S$RPS
	.LONG	1
;
V$RTB::	.LONG	SVFNP		;RTAB
	.LONG	4
	.ASCII	/RTAB/
	.ALIGN	LONG,0
	.LONG	S$RTB
	.LONG	1
;
V$SI$::	.LONG	SVFNP		;SIZE
	.LONG	4
	.ASCII	/SIZE/
	.ALIGN	LONG,0
	.LONG	S$SI$
	.LONG	1
;
	.IF NOT_EQUAL CNSR
	.IF_FALSE
;
V$SRT::	.LONG	SVFNN		;SORT
	.LONG	4
	.ASCII	/SORT/
	.ALIGN	LONG,0
	.LONG	S$SRT
	.LONG	2
	.ENDC
V$SPN::	.LONG	SVFNP		;SPAN
	.LONG	4
	.ASCII	/SPAN/
	.ALIGN	LONG,0
	.LONG	S$SPN
	.LONG	1
	.PAGE
;
;      STANDARD VARIABLE BLOCKS (CONTINUED)
;
V$STN::	.LONG	SVKNM		;STNO
	.LONG	4
	.ASCII	/STNO/
	.ALIGN	LONG,0
	.LONG	K$STN
;
V$TIM::	.LONG	SVFNN		;TIME
	.LONG	4
	.ASCII	/TIME/
	.ALIGN	LONG,0
	.LONG	S$TIM
	.LONG	0
;
V$TRM::	.LONG	SVFNK		;TRIM
	.LONG	4
	.ASCII	/TRIM/
	.ALIGN	LONG,0
	.LONG	K$TRM
	.LONG	S$TRM
	.LONG	1
;
V$ABE::	.LONG	SVKNM		;ABEND
	.LONG	5
	.ASCII	/ABEND/
	.ALIGN	LONG,0
	.LONG	K$ABE
;
V$ABO::	.LONG	SVKVL		;ABORT
	.LONG	5
	.ASCII	/ABORT/
	.ALIGN	LONG,0
	.LONG	K$ABO
	.LONG	L$ABO
	.LONG	NDABO
;
V$APP::	.LONG	SVFNF		;APPLY
	.LONG	5
	.ASCII	/APPLY/
	.ALIGN	LONG,0
	.LONG	S$APP
	.LONG	999
;
V$ABN::	.LONG	SVFNP		;ARBNO
	.LONG	5
	.ASCII	/ARBNO/
	.ALIGN	LONG,0
	.LONG	S$ABN
	.LONG	1
;
V$ARR::	.LONG	SVFNN		;ARRAY
	.LONG	5
	.ASCII	/ARRAY/
	.ALIGN	LONG,0
	.LONG	S$ARR
	.LONG	2
	.PAGE
;
;      STANDARD VARIABLE BLOCKS (CONTINUED)
;
V$BRK::	.LONG	SVFNP		;BREAK
	.LONG	5
	.ASCII	/BREAK/
	.ALIGN	LONG,0
	.LONG	S$BRK
	.LONG	1
;
V$CLR::	.LONG	SVFNN		;CLEAR
	.LONG	5
	.ASCII	/CLEAR/
	.ALIGN	LONG,0
	.LONG	S$CLR
	.LONG	1
;
V$EJC::	.LONG	SVFNN		;EJECT
	.LONG	5
	.ASCII	/EJECT/
	.ALIGN	LONG,0
	.LONG	S$EJC
	.LONG	1
;
V$FEN::	.LONG	SVFPK		;FENCE
	.LONG	5
	.ASCII	/FENCE/
	.ALIGN	LONG,0
	.LONG	K$FEN
	.LONG	S$FNC
	.LONG	1
	.LONG	NDFEN
;
V$FLD::	.LONG	SVFNN		;FIELD
	.LONG	5
	.ASCII	/FIELD/
	.ALIGN	LONG,0
	.LONG	S$FLD
	.LONG	2
;
V$IDN::	.LONG	SVFPR		;IDENT
	.LONG	5
	.ASCII	/IDENT/
	.ALIGN	LONG,0
	.LONG	S$IDN
	.LONG	2
;
V$INP::	.LONG	SVFNK		;INPUT
	.LONG	5
	.ASCII	/INPUT/
	.ALIGN	LONG,0
	.LONG	K$INP
	.LONG	S$INP
	.LONG	3
;
V$LOC::	.LONG	SVFNN		;LOCAL
	.LONG	5
	.ASCII	/LOCAL/
	.ALIGN	LONG,0
	.LONG	S$LOC
	.LONG	2
	.PAGE
;
;      STANDARD VARIABLE BLOCKS (CONTINUED)
;
V$OPS::	.LONG	SVFNN		;OPSYN
	.LONG	5
	.ASCII	/OPSYN/
	.ALIGN	LONG,0
	.LONG	S$OPS
	.LONG	3
;
V$RMD::	.LONG	SVFNP		;REMDR
	.LONG	5
	.ASCII	/REMDR/
	.ALIGN	LONG,0
	.LONG	S$RMD
	.LONG	2
	.IF NOT_EQUAL CNSR
	.IF_FALSE
;
V$RSR::	.LONG	SVFNN		;RSORT
	.LONG	5
	.ASCII	/RSORT/
	.ALIGN	LONG,0
	.LONG	S$RSR
	.LONG	2
	.ENDC
;
V$TBL::	.LONG	SVFNN		;TABLE
	.LONG	5
	.ASCII	/TABLE/
	.ALIGN	LONG,0
	.LONG	S$TBL
	.LONG	3
;
V$TRA::	.LONG	SVFNK		;TRACE
	.LONG	5
	.ASCII	/TRACE/
	.ALIGN	LONG,0
	.LONG	K$TRA
	.LONG	S$TRA
	.LONG	4
;
V$ANC::	.LONG	SVKNM		;ANCHOR
	.LONG	6
	.ASCII	/ANCHOR/
	.ALIGN	LONG,0
	.LONG	K$ANC
;
V$BKX::	.LONG	SVFNP		;BREAKX
	.LONG	6
	.ASCII	/BREAKX/
	.ALIGN	LONG,0
	.LONG	S$BKX
	.LONG	1
;
V$DEF::	.LONG	SVFNN		;DEFINE
	.LONG	6
	.ASCII	/DEFINE/
	.ALIGN	LONG,0
	.LONG	S$DEF
	.LONG	2
;
V$DET::	.LONG	SVFNN		;DETACH
	.LONG	6
	.ASCII	/DETACH/
	.ALIGN	LONG,0
	.LONG	S$DET
	.LONG	1
	.PAGE
;
;      STANDARD VARIABLE BLOCKS (CONTINUED)
;
V$DIF::	.LONG	SVFPR		;DIFFER
	.LONG	6
	.ASCII	/DIFFER/
	.ALIGN	LONG,0
	.LONG	S$DIF
	.LONG	2
;
V$FTR::	.LONG	SVKNM		;FTRACE
	.LONG	6
	.ASCII	/FTRACE/
	.ALIGN	LONG,0
	.LONG	K$FTR
;
V$LST::	.LONG	SVKNM		;LASTNO
	.LONG	6
	.ASCII	/LASTNO/
	.ALIGN	LONG,0
	.LONG	K$LST
;
V$NAY::	.LONG	SVFNP		;NOTANY
	.LONG	6
	.ASCII	/NOTANY/
	.ALIGN	LONG,0
	.LONG	S$NAY
	.LONG	1
;
V$OUP::	.LONG	SVFNK		;OUTPUT
	.LONG	6
	.ASCII	/OUTPUT/
	.ALIGN	LONG,0
	.LONG	K$OUP
	.LONG	S$OUP
	.LONG	3
;
V$RET::	.LONG	SVLBL		;RETURN
	.LONG	6
	.ASCII	/RETURN/
	.ALIGN	LONG,0
	.LONG	L$RTN
;
V$REW::	.LONG	SVFNN		;REWIND
	.LONG	6
	.ASCII	/REWIND/
	.ALIGN	LONG,0
	.LONG	S$REW
	.LONG	1
;
V$STT::	.LONG	SVFNN		;STOPTR
	.LONG	6
	.ASCII	/STOPTR/
	.ALIGN	LONG,0
	.LONG	S$STT
	.LONG	2
	.PAGE
;
;      STANDARD VARIABLE BLOCKS (CONTINUED)
;
V$SUB::	.LONG	SVFNN		;SUBSTR
	.LONG	6
	.ASCII	/SUBSTR/
	.ALIGN	LONG,0
	.LONG	S$SUB
	.LONG	3
;
V$UNL::	.LONG	SVFNN		;UNLOAD
	.LONG	6
	.ASCII	/UNLOAD/
	.ALIGN	LONG,0
	.LONG	S$UNL
	.LONG	1
;
V$COL::	.LONG	SVFNN		;COLLECT
	.LONG	7
	.ASCII	/COLLECT/
	.ALIGN	LONG,0
	.LONG	S$COL
	.LONG	1
;
V$CNV::	.LONG	SVFNN		;CONVERT
	.LONG	7
	.ASCII	/CONVERT/
	.ALIGN	LONG,0
	.LONG	S$CNV
	.LONG	2
;
V$ENF::	.LONG	SVFNN		;ENDFILE
	.LONG	7
	.ASCII	/ENDFILE/
	.ALIGN	LONG,0
	.LONG	S$ENF
	.LONG	1
;
V$ETX::	.LONG	SVKNM		;ERRTEXT
	.LONG	7
	.ASCII	/ERRTEXT/
	.ALIGN	LONG,0
	.LONG	K$ETX
;
V$ERT::	.LONG	SVKNM		;ERRTYPE
	.LONG	7
	.ASCII	/ERRTYPE/
	.ALIGN	LONG,0
	.LONG	K$ERT
;
V$FRT::	.LONG	SVLBL		;FRETURN
	.LONG	7
	.ASCII	/FRETURN/
	.ALIGN	LONG,0
	.LONG	L$FRT
;
V$INT::	.LONG	SVFPR		;INTEGER
	.LONG	7
	.ASCII	/INTEGER/
	.ALIGN	LONG,0
	.LONG	S$INT
	.LONG	1
;
V$NRT::	.LONG	SVLBL		;NRETURN
	.LONG	7
	.ASCII	/NRETURN/
	.ALIGN	LONG,0
	.LONG	L$NRT
	.PAGE
;
;      STANDARD VARIABLE BLOCKS (CONTINUED)
;
	.IF NOT_EQUAL CNPF
	.IF_FALSE
;
V$PFL::	.LONG	SVKNM		;PROFILE
	.LONG	7
	.ASCII	/PROFILE/
	.ALIGN	LONG,0
	.LONG	K$PFL
	.ENDC
;
V$RPL::	.LONG	SVFNP		;REPLACE
	.LONG	7
	.ASCII	/REPLACE/
	.ALIGN	LONG,0
	.LONG	S$RPL
	.LONG	3
;
V$RVS::	.LONG	SVFNP		;REVERSE
	.LONG	7
	.ASCII	/REVERSE/
	.ALIGN	LONG,0
	.LONG	S$RVS
	.LONG	1
;
V$RTN::	.LONG	SVKNM		;RTNTYPE
	.LONG	7
	.ASCII	/RTNTYPE/
	.ALIGN	LONG,0
	.LONG	K$RTN
;
V$STX::	.LONG	SVFNN		;SETEXIT
	.LONG	7
	.ASCII	/SETEXIT/
	.ALIGN	LONG,0
	.LONG	S$STX
	.LONG	1
;
V$STC::	.LONG	SVKNM		;STCOUNT
	.LONG	7
	.ASCII	/STCOUNT/
	.ALIGN	LONG,0
	.LONG	K$STC
;
V$STL::	.LONG	SVKNM		;STLIMIT
	.LONG	7
	.ASCII	/STLIMIT/
	.ALIGN	LONG,0
	.LONG	K$STL
;
V$SUC::	.LONG	SVKVC		;SUCCEED
	.LONG	7
	.ASCII	/SUCCEED/
	.ALIGN	LONG,0
	.LONG	K$SUC
	.LONG	NDSUC
;
V$ALP::	.LONG	SVKWC		;ALPHABET
	.LONG	8
	.ASCII	/ALPHABET/
	.ALIGN	LONG,0
	.LONG	K$ALP
;
V$CNT::	.LONG	SVLBL		;CONTINUE
	.LONG	8
	.ASCII	/CONTINUE/
	.ALIGN	LONG,0
	.LONG	L$CNT
	.PAGE
;
;      STANDARD VARIABLE BLOCKS (CONTINUED)
;
V$DTP::	.LONG	SVFNP		;DATATYPE
	.LONG	8
	.ASCII	/DATATYPE/
	.ALIGN	LONG,0
	.LONG	S$DTP
	.LONG	1
;
V$ERL::	.LONG	SVKNM		;ERRLIMIT
	.LONG	8
	.ASCII	/ERRLIMIT/
	.ALIGN	LONG,0
	.LONG	K$ERL
;
V$FNC::	.LONG	SVKNM		;FNCLEVEL
	.LONG	8
	.ASCII	/FNCLEVEL/
	.ALIGN	LONG,0
	.LONG	K$FNC
;
V$MXL::	.LONG	SVKNM		;MAXLNGTH
	.LONG	8
	.ASCII	/MAXLNGTH/
	.ALIGN	LONG,0
	.LONG	K$MXL
;
V$TER::	.LONG	0		;TERMINAL
	.LONG	8
	.ASCII	/TERMINAL/
	.ALIGN	LONG,0
	.LONG	0
;
V$PRO::	.LONG	SVFNN		;PROTOTYPE
	.LONG	9
	.ASCII	/PROTOTYPE/
	.ALIGN	LONG,0
	.LONG	S$PRO
	.LONG	1
;
	.LONG	0		;DUMMY ENTRY TO END LIST
	.LONG	10		;LENGTH GT 9 (PROTOTYPE)
	.PAGE
;
;      LIST OF SVBLK POINTERS FOR KEYWORDS TO BE DUMPED. THE
;      LIST IS IN THE ORDER WHICH APPEARS ON THE DUMP OUTPUT.
;
VDMKW::	.LONG	V$ANC		;ANCHOR
	.LONG	V$COD		;CODE
	.LONG	V$DMP		;DUMP
	.LONG	V$ERL		;ERRLIMIT
	.LONG	V$ETX		;ERRTEXT
	.LONG	V$ERT		;ERRTYPE
	.LONG	V$FNC		;FNCLEVEL
	.LONG	V$FTR		;FTRACE
	.LONG	V$INP		;INPUT
	.LONG	V$LST		;LASTNO
	.LONG	V$MXL		;MAXLENGTH
	.LONG	V$OUP		;OUTPUT
	.IF NOT_EQUAL CNPF
	.IF_FALSE
	.LONG	V$PFL		;PROFILE
	.ENDC
	.LONG	V$RTN		;RTNTYPE
	.LONG	V$STC		;STCOUNT
	.LONG	V$STL		;STLIMIT
	.LONG	V$STN		;STNO
	.LONG	V$TRA		;TRACE
	.LONG	V$TRM		;TRIM
	.LONG	0		;END OF LIST
;
;      TABLE USED BY GTNVR TO SEARCH SVBLK LISTS
;
VSRCH::	.LONG	0		;DUMMY ENTRY TO GET PROPER INDEXING
	.LONG	V$EQF		;START OF 1 CHAR VARIABLES (NONE)
	.LONG	V$EQF		;START OF 2 CHAR VARIABLES
	.LONG	V$ANY		;START OF 3 CHAR VARIABLES
	.LONG	V$COD		;START OF 4 CHAR VARIABLES
	.LONG	V$ABE		;START OF 5 CHAR VARIABLES
	.LONG	V$ANC		;START OF 6 CHAR VARIABLES
	.LONG	V$COL		;START OF 7 CHAR VARIABLES
	.LONG	V$ALP		;START OF 8 CHAR VARIABLES
	.LONG	V$PRO		;START OF 9 CHAR VARIABLES
	.PAGE
	.SUBTITLE S P I T B O L -- WORKING STORAGE SECTION
;
;      THE WORKING STORAGE SECTION CONTAINS AREAS WHICH ARE
;      CHANGED DURING EXECUTION OF THE PROGRAM. THE VALUE
;      ASSEMBLED IS THE INITIAL VALUE BEFORE EXECUTION STARTS.
;
;      ALL THESE AREAS ARE FIXED LENGTH AREAS. VARIABLE LENGTH
;      DATA IS STORED IN THE STATIC OR DYNAMIC REGIONS OF THE
;      ALLOCATED DATA AREAS.
;
;      THE VALUES IN THIS AREA ARE DESCRIBED EITHER AS WORK
;      AREAS OR AS GLOBAL VALUES. A WORK AREA IS USED IN AN
;      EPHEMERAL MANNER AND THE VALUE IS NOT SAVED FROM ONE
;      ENTRY INTO A ROUTINE TO ANOTHER. A GLOBAL VALUE IS A
;      LESS TEMPORARY LOCATION WHOSE VALUE IS SAVED FROM ONE
;      CALL TO ANOTHER.
;
;      A GENERAL PART OF THE APPROACH IN THIS PROGRAM IS NOT
;      TO OVERLAP WORK AREAS BETWEEN PROCEDURES EVEN THOUGH A
;      SMALL AMOUNT OF SPACE COULD BE SAVED. SUCH OVERLAP IS
;      CONSIDERED A SOURCE OF PROGRAM ERRORS AND DECREASES THE
;      INFORMATION LEFT BEHIND AFTER A SYSTEM CRASH OF ANY KIND.
;
;      THE NAMES OF THESE LOCATIONS ARE LABELS WITH FIVE LETTER
;      (A-Y,$) NAMES. AS FAR AS POSSIBLE THE ORDER IS KEPT
;      ALPHABETICAL BY THESE NAMES BUT IN SOME CASES THERE
;      ARE SLIGHT DEPARTURES CAUSED BY OTHER ORDER REQUIREMENTS.
;
;      UNLESS OTHERWISE DOCUMENTED, THE ORDER OF WORK AREAS
;      DOES NOT AFFECT THE EXECUTION OF THE SPITBOL PROGRAM.
;
	SEC			;START OF WORKING STORAGE SECTION
	.PAGE
;
;      THIS AREA IS NOT CLEARED BY INITIAL CODE
;
CMLAB::	.LONG	B$SCL		;STRING USED TO CHECK LABEL LEGALITY
	.LONG	2
	.ASCII	/  /
	.ALIGN	LONG,0
;
;      LABEL TO MARK START OF WORK AREA
;
AAAAA::	.LONG	0
;
;      WORK AREAS FOR ALLOC PROCEDURE
;
ALDYN::	.LONG	0		;AMOUNT OF DYNAMIC STORE
ALFSF::	.LONG	+0		;FACTOR IN FREE STORE PCNTAGE CHECK
ALLIA::	.LONG	+0		;DUMP IA
ALLSV::	.LONG	0		;SAVE WB IN ALLOC
;
;      WORK AREAS FOR ALOST PROCEDURE
;
ALSTA::	.LONG	0		;SAVE WA IN ALOST
;
;      SAVE AREAS FOR ARRAY FUNCTION (S$ARR)
;
ARCDM::	.LONG	0		;COUNT DIMENSIONS
ARNEL::	.LONG	+0		;COUNT ELEMENTS
ARPTR::	.LONG	0		;OFFSET PTR INTO ARBLK
ARSVL::	.LONG	+0		;SAVE INTEGER LOW BOUND
	.PAGE
;      WORK AREAS FOR ARREF ROUTINE
;
ARFSI::	.LONG	+0		;SAVE CURRENT EVOLVING SUBSCRIPT
ARFXS::	.LONG	0		;SAVE BASE STACK POINTER
;
;      WORK AREAS FOR B$EFC BLOCK ROUTINE
;
BEFOF::	.LONG	0		;SAVE OFFSET PTR INTO EFBLK
;
;      WORK AREAS FOR B$PFC BLOCK ROUTINE
;
BPFPF::	.LONG	0		;SAVE PFBLK POINTER
BPFSV::	.LONG	0		;SAVE OLD FUNCTION VALUE
BPFXT::	.LONG	0		;POINTER TO STACKED ARGUMENTS
;
;      SAVE AREAS FOR COLLECT FUNCTION (S$COL)
;
CLSVI::	.LONG	+0		;SAVE INTEGER ARGUMENT
;
;      GLOBAL VALUES FOR CMPIL PROCEDURE
;
CMERC::	.LONG	0		;COUNT OF INITIAL COMPILE ERRORS
CMPXS::	.LONG	0		;SAVE STACK PTR IN CASE OF ERRORS
CMPSN::	.LONG	1		;NUMBER OF NEXT STATEMENT TO COMPILE
CMPSS::	.LONG	0		;SAVE SUBROUTINE STACK PTR
;
;      WORK AREA FOR CNCRD
;
CNSCC::	.LONG	0		;POINTER TO CONTROL CARD STRING
CNSWC::	.LONG	0		;WORD COUNT
CNR$T::	.LONG	0		;POINTER TO R$TTL OR R$STL
CNTTL::	.LONG	0		;FLAG FOR -TITLE, -STITL
;
;      WORK AREAS FOR CONVERT FUNCTION (S$CNV)
;
CNVTP::	.LONG	0		;SAVE PTR INTO SCVTB
;
;      FLAG FOR SUPPRESSION OF COMPILATION STATISTICS.
;
CPSTS::	.LONG	0		;SUPPRESS COMP. STATS IF NON ZERO
;
;      GLOBAL VALUES FOR CONTROL CARD SWITCHES
;
CSWDB::	.LONG	0		;0/1 FOR -SINGLE/-DOUBLE
CSWER::	.LONG	0		;0/1 FOR -ERRORS/-NOERRORS
CSWEX::	.LONG	0		;0/1 FOR -EXECUTE/-NOEXECUTE
CSWFL::	.LONG	1		;0/1 FOR -NOFAIL/-FAIL
CSWIN::	.LONG	INILN		;XXX FOR -INXXX
CSWLS::	.LONG	1		;0/1 FOR -NOLIST/-LIST
CSWNO::	.LONG	0		;0/1 FOR -OPTIMISE/-NOOPT
CSWPR::	.LONG	0		;0/1 FOR -NOPRINT/-PRINT
;
;      GLOBAL LOCATION USED BY PATST PROCEDURE
;
CTMSK::	.LONG	0		;LAST BIT POSITION USED IN R$CTP
CURID::	.LONG	0		;CURRENT ID VALUE
	.PAGE
;
;      GLOBAL VALUE FOR CDWRD PROCEDURE
;
CWCOF::	.LONG	0		;NEXT WORD OFFSET IN CURRENT CCBLK
;
;      WORK AREAS FOR DATA FUNCTION (S$DAT)
;
DATDV::	.LONG	0		;SAVE VRBLK PTR FOR DATATYPE NAME
DATXS::	.LONG	0		;SAVE INITIAL STACK POINTER
;
;      WORK AREAS FOR DEFINE FUNCTION (S$DEF)
;
DEFLB::	.LONG	0		;SAVE VRBLK PTR FOR LABEL
DEFNA::	.LONG	0		;COUNT FUNCTION ARGUMENTS
DEFVR::	.LONG	0		;SAVE VRBLK PTR FOR FUNCTION NAME
DEFXS::	.LONG	0		;SAVE INITIAL STACK POINTER
;
;      WORK AREAS FOR DUMPR PROCEDURE
;
DMARG::	.LONG	0		;DUMP ARGUMENT
DMPKB::	.LONG	B$KVT		;DUMMY KVBLK FOR USE IN DUMPR
DMPKT::	.LONG	TRBKV		;KVVAR TRBLK POINTER
DMPKN::	.LONG	0		;KEYWORD NUMBER (MUST FOLLOW DMPKB)
DMPSA::	.LONG	0		;PRESERVE WA OVER PRTVL CALL
DMPSV::	.LONG	0		;GENERAL SCRATCH SAVE
DMVCH::	.LONG	0		;CHAIN POINTER FOR VARIABLE BLOCKS
DMPCH::	.LONG	0		;SAVE SORTED VRBLK CHAIN POINTER
;
;      GLOBAL LOCATIONS FOR DYNAMIC STORAGE POINTERS
;
DNAMB::	.LONG	0		;START OF DYNAMIC AREA
DNAMP::	.LONG	0		;NEXT AVAILABLE LOC IN DYNAMIC AREA
DNAME::	.LONG	0		;END OF AVAILABLE DYNAMIC AREA
;
;      WORK AREA FOR DTACH
;
DTCNB::	.LONG	0		;NAME BASE
DTCNM::	.LONG	0		;NAME PTR
;
;      WORK AREAS FOR DUPL FUNCTION (S$DUP)
;
DUPSI::	.LONG	+0		;STORE INTEGER STRING LENGTH
;
;      WORK AREA FOR ENDFILE (S$ENF)
;
ENFCH::	.LONG	0		;FOR IOCHN CHAIN HEAD
;
;      WORK AREA FOR ERROR PROCESSING.
;
ERICH::	.LONG	0		;COPY ERROR REPORTS TO INT.CHAN IF 1
ERLST::	.LONG	0		;FOR LISTR WHEN ERRORS GO TO INT.CH.
ERRFT::	.LONG	0		;FATAL ERROR FLAG
ERRSP::	.LONG	0		;ERROR SUPPRESSION FLAG
	.PAGE
;
;      DUMP AREA FOR ERTEX
;
ERTWA::	.LONG	0		;SAVE WA
ERTWB::	.LONG	0		;SAVE WB
;
;      GLOBAL VALUES FOR EVALI
;
EVLIN::	.LONG	P$LEN		;DUMMY PATTERN BLOCK PCODE
EVLIS::	.LONG	0		;POINTER TO SUBSEQUENT NODE
EVLIV::	.LONG	0		;VALUE OF PARAMETER
;      WORK AREA FOR EXPAN
;
EXPSV::	.LONG	0		;SAVE OP DOPE VECTOR POINTER
;
;      FLAG FOR SUPPRESSION OF EXECUTION STATS
;
EXSTS::	.LONG	0		;SUPPRESS EXEC STATS IF SET
;
;      GLOBAL VALUES FOR EXFAL AND RETURN
;
FLPRT::	.LONG	0		;LOCATION OF FAIL OFFSET FOR RETURN
FLPTR::	.LONG	0		;LOCATION OF FAILURE OFFSET ON STACK
;
;      WORK AREAS FOR GBCOL PROCEDURE
;
GBCFL::	.LONG	0		;GARBAGE COLLECTOR ACTIVE FLAG
GBCLM::	.LONG	0		;POINTER TO LAST MOVE BLOCK (PASS 3)
GBCNM::	.LONG	0		;DUMMY FIRST MOVE BLOCK
GBCNS::	.LONG	0		;REST OF DUMMY BLOCK (FOLLOWS GBCNM)
GBSVA::	.LONG	0		;SAVE WA
GBSVB::	.LONG	0		;SAVE WB
GBSVC::	.LONG	0		;SAVE WC
;
;      GLOBAL LOCATION TO COUNT GARBAGE COLLECTIONS (GBCOL)
;
GBCNT::	.LONG	0		;COUNT OF GARBAGE COLLECTIONS
;
;      WORK AREAS FOR GTNVR PROCEDURE
;
GNVHE::	.LONG	0		;PTR TO END OF HASH CHAIN
GNVNW::	.LONG	0		;NUMBER OF WORDS IN STRING NAME
GNVSA::	.LONG	0		;SAVE WA
GNVSB::	.LONG	0		;SAVE WB
GNVSP::	.LONG	0		;POINTER INTO VSRCH TABLE
GNVST::	.LONG	0		;POINTER TO CHARS OF STRING
;
;      GLOBAL VALUE FOR GTCOD AND GTEXP
;
GTCEF::	.LONG	0		;SAVE FAIL PTR IN CASE OF ERROR
;
;      WORK AREAS FOR GTINT
;
GTINA::	.LONG	0		;SAVE WA
GTINB::	.LONG	0		;SAVE WB
	.PAGE
;
;      WORK AREAS FOR GTNUM PROCEDURE
;
GTNNF::	.LONG	0		;ZERO/NONZERO FOR RESULT +/-
GTNSI::	.LONG	+0		;GENERAL INTEGER SAVE
	.IF NOT_EQUAL CNRA
	.IF_FALSE
GTNDF::	.LONG	0		;0/1 FOR DEC POINT SO FAR NO/YES
GTNES::	.LONG	0		;ZERO/NONZERO EXPONENT +/-
GTNEX::	.LONG	+0		;REAL EXPONENT
GTNSC::	.LONG	0		;SCALE (PLACES AFTER POINT)
GTNSR::	.FLOAT	+0.0		;GENERAL REAL SAVE
GTNRD::	.LONG	0		;FLAG FOR OK REAL NUMBER
	.ENDC
;
;      WORK AREAS FOR GTPAT PROCEDURE
;
GTPSB::	.LONG	0		;SAVE WB
;
;      WORK AREAS FOR GTSTG PROCEDURE
;
GTSSF::	.LONG	0		;0/1 FOR RESULT +/-
GTSVC::	.LONG	0		;SAVE WC
GTSVB::	.LONG	0		;SAVE WB
GTSWK::	.LONG	0		;PTR TO WORK AREA FOR GTSTG
	.IF NOT_EQUAL CNRA
	.IF_FALSE
GTSES::	.LONG	0		;CHAR + OR - FOR EXPONENT +/-
GTSRS::	.FLOAT	+0.0		;GENERAL REAL SAVE
;
;      GLOBAL LOCATIONS (CONSTANTS) FOR GTSTG PROCEDURE
;
GTSRN::	.FLOAT	+0.0		;ROUNDING FACTOR 0.5*10**-CFP$S
GTSSC::	.FLOAT	+0.0		;SCALING VALUE 10**CFP$S
	.ENDC
;
;      WORK AREAS FOR GTVAR PROCEDURE
;
GTVRC::	.LONG	0		;SAVE WC
;
;      FLAG FOR HEADER PRINTING
;
HEADP::	.LONG	0		;HEADER PRINTED FLAG
;
;      GLOBAL VALUES FOR VARIABLE HASH TABLE
;
HSHNB::	.LONG	+0		;NUMBER OF HASH BUCKETS
HSHTB::	.LONG	0		;POINTER TO START OF VRBLK HASH TABL
HSHTE::	.LONG	0		;POINTER PAST END OF VRBLK HASH TABL
;
;      WORK AREA FOR INIT
;
INISS::	.LONG	0		;SAVE SUBROUTINE STACK PTR
INITR::	.LONG	0		;SAVE TERMINAL FLAG
;
;      WORK AREAS FOR IOPUT
;
IOPTT::	.LONG	0		;TYPE OF ASSOCIATION
	.PAGE
;
;      GLOBAL VALUES FOR KEYWORD VALUES WHICH ARE STORED AS ONE
;      WORD INTEGERS. THESE VALUES MUST BE ASSEMBLED IN THE
;      FOLLOWING ORDER (AS DICTATED BY K$XXX DEFINITION VALUES).
;
KVABE::	.LONG	0		;ABEND
KVANC::	.LONG	0		;ANCHOR
KVCOD::	.LONG	0		;CODE
KVDMP::	.LONG	0		;DUMP
KVERL::	.LONG	0		;ERRLIMIT
KVERT::	.LONG	0		;ERRTYPE
KVFTR::	.LONG	0		;FTRACE
KVINP::	.LONG	1		;INPUT
KVMXL::	.LONG	5000		;MAXLENGTH
KVOUP::	.LONG	1		;OUTPUT
	.IF NOT_EQUAL CNPF
	.IF_FALSE
KVPFL::	.LONG	0		;PROFILE
	.ENDC
KVTRA::	.LONG	0		;TRACE
KVTRM::	.LONG	0		;TRIM
KVFNC::	.LONG	0		;FNCLEVEL
KVLST::	.LONG	0		;LASTNO
KVSTN::	.LONG	0		;STNO
;
;      GLOBAL VALUES FOR OTHER KEYWORDS
;
KVALP::	.LONG	0		;ALPHABET
KVRTN::	.LONG	NULLS		;RTNTYPE (SCBLK POINTER)
KVSTL::	.LONG	+1000000000	;STLIMIT
KVSTC::	.LONG	+1000000000	;STCOUNT (COUNTS DOWN FROM STLIMIT)
	.IF NOT_EQUAL CNLD
	.IF_FALSE
;
;      WORK AREAS FOR LOAD FUNCTION
;
LODFN::	.LONG	0		;POINTER TO VRBLK FOR FUNC NAME
LODNA::	.LONG	0		;COUNT NUMBER OF ARGUMENTS
	.ENDC
;
;      GLOBAL VALUES FOR LISTR PROCEDURE
;
LSTLC::	.LONG	0		;COUNT LINES ON SOURCE LIST PAGE
LSTNP::	.LONG	0		;MAX NUMBER OF LINES ON PAGE
LSTPF::	.LONG	1		;SET NONZERO IF CURRENT IMAGE LISTED
LSTPG::	.LONG	0		;CURRENT SOURCE LIST PAGE NUMBER
LSTPO::	.LONG	0		;OFFSET TO   PAGE NNN   MESSAGE
LSTSN::	.LONG	0		;REMEMBER LAST STMNUM LISTED
;
;      MAXIMUM SIZE OF SPITBOL OBJECTS
;
MXLEN::	.LONG	0		;INITIALISED BY SYSMX CALL
;
;      EXECUTION CONTROL VARIABLE
;
NOXEQ::	.LONG	0		;SET NON-ZERO TO INHIBIT EXECUTION
	.IF NOT_EQUAL CNPF
	.IF_FALSE
;
;      PROFILER GLOBAL VALUES AND WORK LOCATIONS
;
PFDMP::	.LONG	0		;SET NON-0 IF &PROFILE SET NON-0
PFFNC::	.LONG	0		;SET NON-0 IF FUNCT JUST ENTERED
PFSTM::	.LONG	+0		;TO STORE STARTING TIME OF STMT
PFETM::	.LONG	+0		;TO STORE ENDING TIME OF STMT
PFSVW::	.LONG	0		;TO SAVE A W-REG
PFTBL::	.LONG	0		;GETS ADRS OF (IMAG) TABLE BASE
PFNTE::	.LONG	0		;NR OF TABLE ENTRIES
PFSTE::	.LONG	+0		;GETS INT REP OF TABLE ENTRY SIZE
	.ENDC
;
	.PAGE
;
;      GLOBAL VALUES USED IN PATTERN MATCH ROUTINES
;
PMDFL::	.LONG	0		;PATTERN ASSIGNMENT FLAG
PMHBS::	.LONG	0		;HISTORY STACK BASE POINTER
PMSSL::	.LONG	0		;LENGTH OF SUBJECT STRING IN CHARS
;
;      FLAGS USED FOR STANDARD FILE LISTING OPTIONS
;
PRICH::	.LONG	0		;PRINTER ON INTERACTIVE CHANNEL
PRSTD::	.LONG	0		;TESTED BY PRTPG
PRSTO::	.LONG	0		;STANDARD LISTING OPTION FLAG
;
;      GLOBAL VALUE FOR PRTNM PROCEDURE
;
PRNMV::	.LONG	0		;VRBLK PTR FROM LAST NAME SEARCH
;
;      WORK AREAS FOR PRTNM PROCEDURE
;
PRNSI::	.LONG	+0		;SCRATCH INTEGER LOC
;
;      WORK AREAS FOR PRTSN PROCEDURE
;
PRSNA::	.LONG	0		;SAVE WA
;
;      GLOBAL VALUES FOR PRINT PROCEDURES
;
PRBUF::	.LONG	0		;PTR TO PRINT BFR IN STATIC
PRECL::	.LONG	0		;EXTENDED/COMPACT LISTING FLAG
PRLEN::	.LONG	0		;LENGTH OF PRINT BUFFER IN CHARS
PRLNW::	.LONG	0		;LENGTH OF PRINT BUFFER IN WORDS
PROFS::	.LONG	0		;OFFSET TO NEXT LOCATION IN PRBUF
PRTEF::	.LONG	0		;ENDFILE FLAG
;
;      WORK AREAS FOR PRTST PROCEDURE
;
PRSVA::	.LONG	0		;SAVE WA
PRSVB::	.LONG	0		;SAVE WB
PRSVC::	.LONG	0		;SAVE CHAR COUNTER
;
;      WORK AREA FOR PRTNL
;
PRTSA::	.LONG	0		;SAVE WA
PRTSB::	.LONG	0		;SAVE WB
;
;      WORK AREA FOR PRTVL
;
PRVSI::	.LONG	0		;SAVE IDVAL
;
;      WORK AREAS FOR PATTERN MATCH ROUTINES
;
PSAVE::	.LONG	0		;TEMPORARY SAVE FOR CURRENT NODE PTR
PSAVC::	.LONG	0		;SAVE CURSOR IN P$SPN, P$STR
	.PAGE
;
;      AMOUNT OF MEMORY RESERVED FOR END OF EXECUTION
;
RSMEM::	.LONG	0		;RESERVE MEMORY
;
;      WORK AREAS FOR RETRN ROUTINE
;
RTNBP::	.LONG	0		;TO SAVE A BLOCK POINTER
RTNFV::	.LONG	0		;NEW FUNCTION VALUE (RESULT)
RTNSV::	.LONG	0		;OLD FUNCTION VALUE (SAVED VALUE)
;
;      RELOCATABLE GLOBAL VALUES
;
;      ALL THE POINTERS IN THIS SECTION CAN POINT TO BLOCKS IN
;      THE DYNAMIC STORAGE AREA AND MUST BE RELOCATED BY THE
;      GARBAGE COLLECTOR. THEY ARE IDENTIFIED BY R$XXX NAMES.
;
R$AAA::	.LONG	0		;START OF RELOCATABLE VALUES
R$ARF::	.LONG	0		;ARRAY BLOCK POINTER FOR ARREF
R$CCB::	.LONG	0		;PTR TO CCBLK BEING BUILT (CDWRD)
R$CIM::	.LONG	0		;PTR TO CURRENT COMPILER INPUT STR
R$CMP::	.LONG	0		;COPY OF R$CIM USED IN CMPIL
R$CNI::	.LONG	0		;PTR TO NEXT COMPILER INPUT STRING
R$CNT::	.LONG	0		;CDBLK POINTER FOR SETEXIT CONTINUE
R$COD::	.LONG	0		;POINTER TO CURRENT CDBLK OR EXBLK
R$CTP::	.LONG	0		;PTR TO CURRENT CTBLK FOR PATST
R$ERT::	.LONG	0		;TRBLK POINTER FOR ERRTYPE TRACE
R$ETX::	.LONG	NULLS		;POINTER TO ERRTEXT STRING
R$EXS::	.LONG	0		;= SAVE XL IN EXPDM
R$FCB::	.LONG	0		;FCBLK CHAIN HEAD
R$FNC::	.LONG	0		;TRBLK POINTER FOR FNCLEVEL TRACE
R$GTC::	.LONG	0		;KEEP CODE PTR FOR GTCOD,GTEXP
R$IO1::	.LONG	0		;FILE ARG1 FOR IOPUT
R$IO2::	.LONG	0		;FILE ARG2 FOR IOPUT
R$IOF::	.LONG	0		;FCBLK PTR OR 0
R$ION::	.LONG	0		;NAME BASE PTR
R$IOP::	.LONG	0		;PREDECESSOR BLOCK PTR FOR IOPUT
R$IOT::	.LONG	0		;TRBLK PTR FOR IOPUT
R$PMS::	.LONG	0		;SUBJECT STRING PTR IN PATTERN MATCH
R$RA2::	.LONG	0		;REPLACE SECOND ARGUMENT LAST TIME
R$RA3::	.LONG	0		;REPLACE THIRD ARGUMENT LAST TIME
R$RPT::	.LONG	0		;PTR TO CTBLK REPLACE TABLE LAST USD
R$SCP::	.LONG	0		;SAVE POINTER FROM LAST SCANE CALL
R$SXL::	.LONG	0		;PRESERVE XL IN SORTC
R$SXR::	.LONG	0		;PRESERVE XR IN SORTA/SORTC
R$STC::	.LONG	0		;TRBLK POINTER FOR STCOUNT TRACE
R$STL::	.LONG	0		;SOURCE LISTING SUB-TITLE
R$SXC::	.LONG	0		;CODE (CDBLK) PTR FOR SETEXIT TRAP
R$TTL::	.LONG	NULLS		;SOURCE LISTING TITLE
R$XSC::	.LONG	0		;STRING POINTER FOR XSCAN
	.PAGE
;
;      THE REMAINING POINTERS IN THIS LIST ARE USED TO POINT
;      TO FUNCTION BLOCKS FOR NORMALLY UNDEFINED OPERATORS.
;
R$UBA::	.LONG	STNDO		;BINARY AT
R$UBM::	.LONG	STNDO		;BINARY AMPERSAND
R$UBN::	.LONG	STNDO		;BINARY NUMBER SIGN
R$UBP::	.LONG	STNDO		;BINARY PERCENT
R$UBT::	.LONG	STNDO		;BINARY NOT
R$UUB::	.LONG	STNDO		;UNARY VERTICAL BAR
R$UUE::	.LONG	STNDO		;UNARY EQUAL
R$UUN::	.LONG	STNDO		;UNARY NUMBER SIGN
R$UUP::	.LONG	STNDO		;UNARY PERCENT
R$UUS::	.LONG	STNDO		;UNARY SLASH
R$UUX::	.LONG	STNDO		;UNARY EXCLAMATION
R$YYY::	.LONG	0		;LAST RELOCATABLE LOCATION
;
;      WORK AREAS FOR SUBSTR FUNCTION (S$SUB)
;
SBSSV::	.LONG	0		;SAVE THIRD ARGUMENT
;
;      GLOBAL LOCATIONS USED IN SCAN PROCEDURE
;
SCNBL::	.LONG	0		;SET NON-ZERO IF SCANNED PAST BLANKS
SCNCC::	.LONG	0		;NON-ZERO TO SCAN CONTROL CARD NAME
SCNGO::	.LONG	0		;SET NON-ZERO TO SCAN GOTO FIELD
SCNIL::	.LONG	0		;LENGTH OF CURRENT INPUT IMAGE
SCNPT::	.LONG	0		;POINTER TO NEXT LOCATION IN R$CIM
SCNRS::	.LONG	0		;SET NON-ZERO TO SIGNAL RESCAN
SCNTP::	.LONG	0		;SAVE SYNTAX TYPE FROM LAST CALL
;
;      WORK AREAS FOR SCAN PROCEDURE
;
SCNSA::	.LONG	0		;SAVE WA
SCNSB::	.LONG	0		;SAVE WB
SCNSC::	.LONG	0		;SAVE WC
SCNSE::	.LONG	0		;START OF CURRENT ELEMENT
SCNOF::	.LONG	0		;SAVE OFFSET
	.IF NOT_EQUAL CNSR
	.IF_FALSE
	.PAGE
;
;      WORK AREA USED BY SORTA, SORTC, SORTF, SORTH
;
SRTDF::	.LONG	0		;DATATYPE FIELD NAME
SRTFD::	.LONG	0		;FOUND DFBLK ADDRESS
SRTFF::	.LONG	0		;FOUND FIELD NAME
SRTFO::	.LONG	0		;OFFSET TO FIELD NAME
SRTNR::	.LONG	0		;NUMBER OF ROWS
SRTOF::	.LONG	0		;OFFSET WITHIN ROW TO SORT KEY
SRTRT::	.LONG	0		;ROOT OFFSET
SRTS1::	.LONG	0		;SAVE OFFSET 1
SRTS2::	.LONG	0		;SAVE OFFSET 2
SRTSC::	.LONG	0		;SAVE WC
SRTSF::	.LONG	0		;SORT ARRAY FIRST ROW OFFSET
SRTSN::	.LONG	0		;SAVE N
SRTSO::	.LONG	0		;OFFSET TO A(0)
SRTSR::	.LONG	0		;0 , NON-ZERO FOR SORT, RSORT
SRTST::	.LONG	0		;STRIDE FROM ONE ROW TO NEXT
SRTWC::	.LONG	0		;DUMP WC
	.ENDC
;
;      GLOBAL VALUE FOR INDICATING STAGE (SEE ERROR SECTION)
;
STAGE::	.LONG	0		;INITIAL VALUE = INITIAL COMPILE
;
;      GLOBAL VALUES DEFINING EXTENT OF STATIC AREA (ALOST)
;
STATB::	.LONG	0		;START OF STATIC AREA
STATE::	.LONG	0		;END OF STATIC AREA
	.PAGE
;
;      GLOBAL STACK POINTER
;
STBAS::	.LONG	0		;POINTER PAST STACK BASE
;
;      WORK AREAS FOR STOPR ROUTINE
;
STPSI::	.LONG	+0		;SAVE VALUE OF STCOUNT
STPTI::	.LONG	+0		;SAVE TIME ELAPSED
;
;      GLOBAL VALUES FOR SETEXIT FUNCTION (S$STX)
;
STXOF::	.LONG	0		;FAILURE OFFSET
STXVR::	.LONG	NULLS		;VRBLK POINTER OR NULL
;
;      WORK AREAS FOR TFIND PROCEDURE
;
TFNSI::	.LONG	+0		;NUMBER OF HEADERS
;
;      GLOBAL VALUE FOR TIME KEEPING
;
TIMSX::	.LONG	+0		;TIME AT START OF EXECUTION
TIMUP::	.LONG	0		;SET WHEN TIME UP OCCURS
;
;      WORK AREAS FOR XSCAN PROCEDURE
;
XSCRT::	.LONG	0		;SAVE RETURN CODE
XSCWB::	.LONG	0		;SAVE REGISTER WB
;
;      GLOBAL VALUES FOR XSCAN AND XSCNI PROCEDURES
;
XSOFS::	.LONG	0		;OFFSET TO CURRENT LOCATION IN R$XSC
;
;      LABEL TO MARK END OF WORK AREA
;
YYYYY::	.LONG	0
	.PAGE
	.SUBTITLE S P I T B O L -- INITIALIZATION
;
;      INITIALISATION
;      THE FOLLOWING SECTION RECEIVES CONTROL FROM THE SYSTEM
;      AT THE START OF A RUN WITH THE REGISTERS SET AS FOLLOWS.
;
;      (XS)                  POINTS PAST STACK BASE
;      (XR)                  POINTS TO FIRST WORD OF DATA AREA
;      (XL)                  POINTS TO LAST WORD OF DATA AREA
;
	SEC			;START OF PROGRAM SECTION
	JSB	SYSTM		;INITIALISE TIMER
	.IF NOT_EQUAL CNBT
	MOVL	R5,TIMSX	;STORE TIME
	MOVL	R9,STATB	;START ADDRESS OF STATIC
	.IF_FALSE
;
;      INITIALISE WORK AREA (ESSENTIAL FOR BATCHED RUNS)
;
	MOVL	R9,R7		;PRESERVE XR
	MOVL	#YYYYY,R6	;POINT TO END OF WORK AREA
	SUBL2	#AAAAA,R6	;GET LENGTH OF WORK AREA
	ASHL	#-2,R6,R6	;CONVERT TO WORDS
				;COUNT FOR LOOP
	MOVL	#AAAAA,R9	;SET UP INDEX REGISTER
;
;      CLEAR WORK SPACE
;
INI01::	CLRL	(R9)+		;CLEAR A WORD
	SOBGTR	R6,INI01	;LOOP TILL DONE
	MOVL	#STNDO,R6	;UNDEFINED OPERATORS POINTER
	MOVL	#R$YYY,R8	;POINT TO TABLE END
	SUBL2	#R$UBA,R8	;LENGTH OF UNDEF. OPERATORS TABLE
	ASHL	#-2,R8,R8	;CONVERT TO WORDS
				;LOOP COUNTER
	MOVL	#R$UBA,R9	;SET UP XR
;
;      SET CORRECT VALUE INTO UNDEFINED OPERATORS TABLE
;
INI02::	MOVL	R6,(R9)+	;STORE VALUE
	SOBGTR	R8,INI02	;LOOP TILL ALL DONE
	MOVL	#NUM01,R6	;GET A 1
	MOVL	R6,CMPSN	;STATEMENT NO
	MOVL	R6,CSWFL	;NOFAIL
	MOVL	R6,CSWLS	;LIST
	MOVL	R6,KVINP	;INPUT
	MOVL	R6,KVOUP	;OUTPUT
	MOVL	R6,LSTPF	;NOTHING FOR LISTR YET
	MOVL	#INILN,R6	;INPUT IMAGE LENGTH
	MOVL	R6,CSWIN	;-IN72
	MOVL	#B$KVT,DMPKB	;DUMP
	MOVL	#TRBKV,DMPKT	;DUMP
	MOVL	#P$LEN,EVLIN	;EVAL
	.PAGE
	MOVL	#NULLS,R6	;GET NULLSTRING POINTER
	MOVL	R6,KVRTN	;RETURN
	MOVL	R6,R$ETX	;ERRTEXT
	MOVL	R6,R$TTL	;TITLE FOR LISTING
	MOVL	R6,STXVR	;SETEXIT
	MOVL	R5,TIMSX	;STORE TIME IN CORRECT PLACE
	MOVL	STLIM,R5	;GET DEFAULT STLIMIT
	MOVL	R5,KVSTL	;STATEMENT LIMIT
	MOVL	R5,KVSTC	;STATEMENT COUNT
	MOVL	R7,STATB	;STORE START ADRS OF STATIC
	.ENDC
	MOVL	#4*E$SRS,RSMEM	;RESERVE MEMORY
	MOVL	SP,STBAS	;STORE STACK BASE
	;SSS	INISS		;SAVE S-R STACK PTR
;
;      NOW CONVERT FREE STORE PERCENTAGE TO A SUITABLE FACTOR
;      FOR EASY TESTING IN ALLOC ROUTINE.
;
	MOVL	INTVH,R5	;GET 100
	DIVL2	ALFSP,R5	;FORM 100 / ALFSP
	MOVL	R5,ALFSF	;STORE THE FACTOR
	.IF NOT_EQUAL CNRA
	.IF_FALSE
;
;      INITIALIZE VALUES FOR REAL CONVERSION ROUTINE
;
	MOVL	#CFP$S,R7	;LOAD COUNTER FOR SIGNIFICANT DIGITS
	MOVF	REAV1,R2	;LOAD 1.0
;
;      LOOP TO COMPUTE 10**(MAX NUMBER SIGNIFICANT DIGITS)
;
INI03::	MULF2	REAVT,R2	;* 10.0
	SOBGTR	R7,INI03	;LOOP TILL DONE
	MOVF	R2,GTSSC	;STORE 10**(MAX SIG DIGITS)
	MOVF	REAP5,R2	;LOAD 0.5
	DIVF2	GTSSC,R2	;COMPUTE 0.5*10**(MAX SIG DIGITS)
	MOVF	R2,GTSRN	;STORE AS ROUNDING BIAS
	.ENDC
	CLRL	R8		;SET TO READ PARAMETERS
	JSB	PRPAR		;READ THEM
	.PAGE
;
;      NOW COMPUTE STARTING ADDRESS FOR DYNAMIC STORE AND IF
;      NECESSARY REQUEST MORE MEMORY.
;
	SUBL2	#4*E$SRS,R10	;ALLOW FOR RESERVE MEMORY
	MOVL	PRLEN,R6	;GET PRINT BUFFER LENGTH
	ADDL2	#CFP$A,R6	;ADD NO. OF CHARS IN ALPHABET
	ADDL2	#NSTMX,R6	;ADD CHARS FOR GTSTG BFR
	MOVAB	3+<4*8>(R6),R6	;CONVERT TO BYTES, ALLOWING A MARGIN
	BICL2	#3,R6
	MOVL	STATB,R9	;POINT TO STATIC BASE
	ADDL2	R6,R9		;INCREMENT FOR ABOVE BUFFERS
	ADDL2	#4*E$HNB,R9	;INCREMENT FOR HASH TABLE
	ADDL2	#4*E$STS,R9	;BUMP FOR INITIAL STATIC BLOCK
	JSB	SYSMX		;GET MXLEN
	MOVL	R6,KVMXL	;PROVISIONALLY STORE AS MAXLNGTH
	MOVL	R6,MXLEN	;AND AS MXLEN
	CMPL	R9,R6		;SKIP IF STATIC HI EXCEEDS MXLEN
	BGTRU	INI06
	MOVL	R6,R9		;USE MXLEN INSTEAD
	ADDL2	#4,R9		;MAKE BIGGER THAN MXLEN
;
;      HERE TO STORE VALUES WHICH MARK INITIAL DIVISION
;      OF DATA AREA INTO STATIC AND DYNAMIC
;
INI06::	MOVL	R9,DNAMB	;DYNAMIC BASE ADRS
	MOVL	R9,DNAMP	;DYNAMIC PTR
	TSTL	R6		;SKIP IF NON-ZERO MXLEN
	BNEQU	INI07
	SUBL2	#4,R9		;POINT A WORD IN FRONT
	MOVL	R9,KVMXL	;USE AS MAXLNGTH
	MOVL	R9,MXLEN	;AND AS MXLEN
	.PAGE
;
;      LOOP HERE IF NECESSARY TILL ENOUGH MEMORY OBTAINED
;      SO THAT DNAME IS ABOVE DNAMB
;
INI07::	MOVL	R10,DNAME	;STORE DYNAMIC END ADDRESS
	CMPL	DNAMB,R10	;SKIP IF HIGH ENOUGH
	BLSSU	INI09
	JSB	SYSMM		;REQUEST MORE MEMORY
	MOVAL	0[R9],R9	;GET AS BAUS [SGD05]
	ADDL2	R9,R10		;BUMP BY AMOUNT OBTAINED
	TSTL	R9		;TRY AGAIN
	BNEQU	INI07
	MOVL	#ENDMO,R9	;POINT TO FAILURE MESSAGE
	MOVL	ENDML,R6	;MESSAGE LENGTH
	JSB	SYSPR		;PRINT IT (PRTST NOT YET USABLE)
	.ADDRESS INVALID$	;SHOULD NOT FAIL
	JSB	SYSEJ		;PACK UP (STOPR NOT YET USABLE)
;
;      INITIALISE PRINT BUFFER WITH BLANK WORDS
;
INI09::	MOVL	PRLEN,R8	;NO. OF CHARS IN PRINT BFR
	MOVL	STATB,R9	;POINT TO STATIC AGAIN
	MOVL	R9,PRBUF	;PRINT BFR IS PUT AT STATIC START
	MOVL	#B$SCL,(R9)+	;STORE STRING TYPE CODE
	MOVL	R8,(R9)+	;AND STRING LENGTH
	MOVAB	3+<4*0>(R8),R8	;GET NUMBER OF WORDS IN BUFFER
	ASHL	#-2,R8,R8
	MOVL	R8,PRLNW	;STORE FOR BUFFER CLEAR
				;WORDS TO CLEAR
;
;      LOOP TO CLEAR BUFFER
;
INI10::	MOVL	NULLW,(R9)+	;STORE BLANK
	SOBGTR	R8,INI10	;LOOP
;
;      INITIALIZE NUMBER OF HASH HEADERS
;
	MOVL	#E$HNB,R6	;GET NUMBER OF HASH HEADERS
	MOVL	R6,R5		;CONVERT TO INTEGER
	MOVL	R5,HSHNB	;STORE FOR USE BY GTNVR PROCEDURE
				;COUNTER FOR CLEARING HASH TABLE
	MOVL	R9,HSHTB	;POINTER TO HASH TABLE
;
;      LOOP TO CLEAR HASH TABLE
;
INI11::	CLRL	(R9)+		;BLANK A WORD
	SOBGTR	R6,INI11	;LOOP
	MOVL	R9,HSHTE	;END OF HASH TABLE ADRS IS KEPT
;
;      ALLOCATE WORK AREA FOR GTSTG CONVERSION PROCEDURE
;
	MOVL	#NSTMX,R6	;GET MAX NUM CHARS IN OUTPUT NUMBER
	MOVAB	3+<4*SCSI$>(R6),R6 ;NO OF BYTES NEEDED
	BICL2	#3,R6
	MOVL	R9,GTSWK	;STORE BFR ADRS
	ADDL2	R6,R9		;BUMP FOR WORK BFR
	.PAGE
;
;      BUILD ALPHABET STRING FOR ALPHABET KEYWORD AND REPLACE
;
	MOVL	R9,KVALP	;SAVE ALPHABET POINTER
	MOVL	#B$SCL,(R9)	;STRING BLK TYPE
	MOVL	#CFP$A,R8	;NO OF CHARS IN ALPHABET
	MOVL	R8,4*SCLEN(R9)	;STORE AS STRING LENGTH
	MOVL	R8,R7		;COPY CHAR COUNT
	MOVAB	3+<4*SCSI$>(R7),R7 ;NO. OF BYTES NEEDED
	BICL2	#3,R7
	ADDL2	R9,R7		;CURRENT END ADDRESS FOR STATIC
	MOVL	R7,STATE	;STORE STATIC END ADRS
				;LOOP COUNTER
	MOVAB	CFP$F(R9),R9	;POINT TO CHARS OF STRING
	CLRL	R7		;SET INITIAL CHARACTER VALUE
;
;      LOOP TO ENTER CHARACTER CODES IN ORDER
;
INI12::	MOVB	R7,(R9)+	;STORE NEXT CODE
	INCL	R7		;BUMP CODE VALUE
	SOBGTR	R8,INI12	;LOOP TILL ALL STORED
	;CSC	R9		;COMPLETE STORE CHARACTERS
;
;      INITIALIZE VARIABLE BLOCKS FOR INPUT AND OUTPUT
;
	MOVL	#V$INP,R10	;POINT TO STRING /INPUT/
	MOVL	#TRTIN,R7	;TRBLK TYPE FOR INPUT
	JSB	INOUT		;PERFORM INPUT ASSOCIATION
	MOVL	#V$OUP,R10	;POINT TO STRING /OUTPUT/
	MOVL	#TRTOU,R7	;TRBLK TYPE FOR OUTPUT
	JSB	INOUT		;PERFORM OUTPUT ASSOCIATION
	MOVL	INITR,R8	;TERMINAL FLAG
	BEQLU	INI13
	JSB	PRPAR		;ASSOCIATE TERMINAL
	.PAGE
;
;      CHECK FOR EXPIRY DATE
;
INI13::	JSB	SYSDC		;CALL DATE CHECK
	MOVL	SP,FLPTR	;IN CASE STACK OVERFLOWS IN COMPILER
;
;      NOW COMPILE SOURCE INPUT CODE
;
	JSB	CMPIL		;CALL COMPILER
	MOVL	R9,R$COD	;SET PTR TO FIRST CODE BLOCK
	CLRL	R$TTL		;FORGET TITLE
	CLRL	R$STL		;FORGET SUB-TITLE
	CLRL	R$CIM		;FORGET COMPILER INPUT IMAGE
	CLRL	R10		;CLEAR DUD VALUE
	CLRL	R7		;DONT SHIFT DYNAMIC STORE UP
	JSB	GBCOL		;CLEAR GARBAGE LEFT FROM COMPILE
	TSTL	CPSTS		;SKIP IF NO LISTING OF COMP STATS
	BEQLU	5001$
	JMP	INIX0
5001$:
	JSB	PRTPG		;EJECT PAGE
;
;      PRINT COMPILE STATISTICS
;
	MOVL	DNAMP,R6	;NEXT AVAILABLE LOC
	SUBL2	STATB,R6	;MINUS START
	ASHL	#-2,R6,R6	;CONVERT TO WORDS
	MOVL	R6,R5		;CONVERT TO INTEGER
	MOVL	#ENCM1,R9	;POINT TO /MEMORY USED (WORDS)/
	JSB	PRTMI		;PRINT MESSAGE
	MOVL	DNAME,R6	;END OF MEMORY
	SUBL2	DNAMP,R6	;MINUS NEXT AVAILABLE LOC
	ASHL	#-2,R6,R6	;CONVERT TO WORDS
	MOVL	R6,R5		;CONVERT TO INTEGER
	MOVL	#ENCM2,R9	;POINT TO /MEMORY AVAILABLE (WORDS)/
	JSB	PRTMI		;PRINT LINE
	MOVL	CMERC,R5	;GET COUNT OF ERRORS AS INTEGER
	MOVL	#ENCM3,R9	;POINT TO /COMPILE ERRORS/
	JSB	PRTMI		;PRINT IT
	MOVL	GBCNT,R5	;GARBAGE COLLECTION COUNT
	SUBL2	INTV1,R5	;ADJUST FOR UNAVOIDABLE COLLECT
	MOVL	#STPM5,R9	;POINT TO /STORAGE REGENERATIONS/
	JSB	PRTMI		;PRINT GBCOL COUNT
	JSB	SYSTM		;GET TIME
	SUBL2	TIMSX,R5	;GET COMPILATION TIME
	MOVL	#ENCM4,R9	;POINT TO COMPILATION TIME (MSEC)/
	JSB	PRTMI		;PRINT MESSAGE
	ADDL2	#NUM05,LSTLC	;BUMP LINE COUNT
	.PAGE
;
;      PREPARE NOW TO START EXECUTION
;
;      SET DEFAULT INPUT RECORD LENGTH
;
INIX0::	CMPL	CSWIN,#INILN	;SKIP IF NOT DEFAULT -IN72 USED
	BGTRU	INIX1
	MOVL	#INILS,CSWIN	;ELSE USE DEFAULT RECORD LENGTH
;
;      RESET TIMER
;
INIX1::	JSB	SYSTM		;GET TIME AGAIN
	MOVL	R5,TIMSX	;STORE FOR END RUN PROCESSING
	ADDL2	CSWEX,NOXEQ	;ADD -NOEXECUTE FLAG
	TSTL	NOXEQ		;JUMP IF EXECUTION SUPPRESSED
	BNEQU	INIX2
	CLRL	GBCNT		;INITIALISE COLLECT COUNT
	JSB	SYSBX		;CALL BEFORE STARTING EXECUTION
	TSTL	HEADP		;NO EJECT IF NOTHING PRINTED [SGD11]
	BEQLU	INIY0
	JSB	PRTPG		;EJECT PRINTER
;
;      MERGE WHEN LISTING FILE SET FOR EXECUTION
;
INIY0::	MOVL	SP,HEADP	;MARK HEADERS OUT REGARDLESS
	CLRL	-(SP)		;SET FAILURE LOCATION ON STACK
	MOVL	SP,FLPTR	;SAVE PTR TO FAILURE OFFSET WORD
	MOVL	R$COD,R9	;LOAD PTR TO ENTRY CODE BLOCK
	MOVL	#STGXT,STAGE	;SET STAGE FOR EXECUTE TIME
	.IF NOT_EQUAL CNPF
	.IF_FALSE
	MOVL	CMPSN,PFNTE	;COPY STMTS COMPILED COUNT IN CASE
	JSB	SYSTM		;TIME YET AGAIN
	MOVL	R5,PFSTM
	.ENDC
	MOVL	(R9),R11	;START XEQ WITH FIRST STATEMENT
	JMP	(R11)
;
;      HERE IF EXECUTION IS SUPPRESSED
;
INIX2::	JSB	PRTNL		;PRINT A BLANK LINE
	MOVL	#ENCM5,R9	;POINT TO /EXECUTION SUPPRESSED/
	JSB	PRTST		;PRINT STRING
	JSB	PRTNL		;OUTPUT LINE
	CLRL	R6		;SET ABEND VALUE TO ZERO
	MOVL	#NINI9,R7	;SET SPECIAL CODE VALUE
	JSB	SYSEJ		;END OF JOB, EXIT TO SYSTEM
	.PAGE
	.SUBTITLE S P I T B O L -- SNOBOL4 OPERATOR ROUTINES
;
;      THIS SECTION INCLUDES ALL ROUTINES WHICH CAN BE ACCESSED
;      DIRECTLY FROM THE GENERATED CODE EXCEPT SYSTEM FUNCTIONS.
;
;      ALL ROUTINES IN THIS SECTION START WITH A LABEL OF THE
;      FORM O$XXX WHERE XXX IS THREE LETTERS. THE GENERATED CODE
;      CONTAINS A POINTER TO THE APPROPRIATE ENTRY LABEL.
;
;      SINCE THE GENERAL FORM OF THE GENERATED CODE CONSISTS OF
;      POINTERS TO BLOCKS WHOSE FIRST WORD IS THE ADDRESS OF THE
;      ACTUAL ENTRY POINT LABEL (O$XXX).
;
;      THESE ROUTINES ARE IN ALPHABETICAL ORDER BY THEIR
;      ENTRY LABEL NAMES (I.E. BY THE XXX OF THE O$XXX NAME)
;
;      THESE ROUTINES RECEIVE CONTROL AS FOLLOWS
;
;      (CP)                  POINTER TO NEXT CODE WORD
;      (XS)                  CURRENT STACK POINTER
	.PAGE
;
;      BINARY PLUS (ADDITION)
;
O$ADD::				;ENTRY POINT
	JSB	ARITH		;FETCH ARITHMETIC OPERANDS
	.ADDRESS ERROR_001	;ADDITION LEFT OPERAND IS NOT NUMERIC
	.ADDRESS ERROR_002	;ADDITION RIGHT OPERAND IS NOT NUMERIC
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	.ADDRESS OADD1		;JUMP IF REAL OPERANDS
	.ENDC
;
;      HERE TO ADD TWO INTEGERS
;
	ADDL2	4*ICVAL(R10),R5	;ADD RIGHT OPERAND TO LEFT
	BVS	5002$
	JMP	EXINT
5002$:
	JMP	ERROR_003	;ADDITION CAUSED INTEGER OVERFLOW
	.IF NOT_EQUAL CNRA
	.IF_FALSE
;
;      HERE TO ADD TWO REALS
;
OADD1::	ADDF2	4*RCVAL(R10),R2	;ADD RIGHT OPERAND TO LEFT
	BVS	5003$
	JMP	EXREA
5003$:
	JMP	ERROR_261	;ADDITION CAUSED REAL OVERFLOW
	.ENDC
	.PAGE
;
;      UNARY PLUS (AFFIRMATION)
;
O$AFF::				;ENTRY POINT
	MOVL	(SP)+,R9	;LOAD OPERAND
	JSB	GTNUM		;CONVERT TO NUMERIC
	.ADDRESS ERROR_004	;AFFIRMATION OPERAND IS NOT NUMERIC
	JMP	EXIXR		;RETURN IF CONVERTED TO NUMERIC
	.PAGE
;
;      BINARY BAR (ALTERNATION)
;
O$ALT::				;ENTRY POINT
	MOVL	(SP)+,R9	;LOAD RIGHT OPERAND
	JSB	GTPAT		;CONVERT TO PATTERN
	.ADDRESS ERROR_005	;ALTERNATION RIGHT OPERAND IS NOT PATTERN
;
;      MERGE HERE FROM SPECIAL (LEFT ALTERNATION) CASE
;
OALT1::	MOVL	#P$ALT,R7	;SET PCODE FOR ALTERNATIVE NODE
	JSB	PBILD		;BUILD ALTERNATIVE NODE
	MOVL	R9,R10		;SAVE ADDRESS OF ALTERNATIVE NODE
	MOVL	(SP)+,R9	;LOAD LEFT OPERAND
	JSB	GTPAT		;CONVERT TO PATTERN
	.ADDRESS ERROR_006	;ALTERNATION LEFT OPERAND IS NOT PATTERN
	CMPL	R9,#P$ALT	;JUMP IF LEFT ARG IS ALTERNATION
	BEQLU	OALT2
	MOVL	R9,4*PTHEN(R10)	;SET LEFT OPERAND AS SUCCESSOR
	MOVL	R10,R9		;MOVE RESULT TO PROPER REGISTER
	JMP	EXIXR		;JUMP FOR NEXT CODE WORD
;
;      COME HERE IF LEFT ARGUMENT IS ITSELF AN ALTERNATION
;
;      THE RESULT IS MORE EFFICIENT IF WE MAKE THE REPLACEMENT
;
;      (A / B) / C = A / (B / C)
;
OALT2::	MOVL	4*PARM1(R9),4*PTHEN(R10) ;BUILD THE (B / C) NODE
	MOVL	4*PTHEN(R9),-(SP);SET A AS NEW LEFT ARG
	MOVL	R10,R9		;SET (B / C) AS NEW RIGHT ARG
	JMP	OALT1		;MERGE BACK TO BUILD A / (B / C)
	.PAGE
;
;      ARRAY REFERENCE (MULTIPLE SUBSCRIPTS, BY NAME)
;
O$AMN::				;ENTRY POINT
	MOVL	(R3)+,R9	;LOAD NUMBER OF SUBSCRIPTS
	MOVL	R9,R7		;SET FLAG FOR BY NAME
	JMP	ARREF		;JUMP TO ARRAY REFERENCE ROUTINE
	.PAGE
;
;      ARRAY REFERENCE (MULTIPLE SUBSCRIPTS, BY VALUE)
;
O$AMV::				;ENTRY POINT
	MOVL	(R3)+,R9	;LOAD NUMBER OF SUBSCRIPTS
	CLRL	R7		;SET FLAG FOR BY VALUE
	JMP	ARREF		;JUMP TO ARRAY REFERENCE ROUTINE
	.PAGE
;
;      ARRAY REFERENCE (ONE SUBSCRIPT, BY NAME)
;
O$AON::				;ENTRY POINT
	MOVL	(SP),R9		;LOAD SUBSCRIPT VALUE
	MOVL	4*1(SP),R10	;LOAD ARRAY VALUE
	MOVL	(R10),R6	;LOAD FIRST WORD OF ARRAY OPERAND
	CMPL	R6,#B$VCT	;JUMP IF VECTOR REFERENCE
	BEQLU	OAON2
	CMPL	R6,#B$TBT	;JUMP IF TABLE REFERENCE
	BEQLU	OAON3
;
;      HERE TO USE CENTRAL ARRAY REFERENCE ROUTINE
;
OAON1::	MOVL	#NUM01,R9	;SET NUMBER OF SUBSCRIPTS TO ONE
	MOVL	R9,R7		;SET FLAG FOR BY NAME
	JMP	ARREF		;JUMP TO ARRAY REFERENCE ROUTINE
;
;      HERE IF WE HAVE A VECTOR REFERENCE
;
OAON2::	CMPL	(R9),#B$ICL	;USE LONG ROUTINE IF NOT INTEGER
	BNEQU	OAON1
	MOVL	4*ICVAL(R9),R5	;LOAD INTEGER SUBSCRIPT VALUE
	MFI	R6,EXFAL	;COPY AS ADDRESS INT, FAIL IF OVFLO
	TSTL	R6		;FAIL IF ZERO
	BNEQU	5004$
	JMP	EXFAL
5004$:
	ADDL2	#VCVLB,R6	;COMPUTE OFFSET IN WORDS
	MOVAL	0[R6],R6	;CONVERT TO BYTES
	MOVL	R6,(SP)		;COMPLETE NAME ON STACK
	CMPL	R6,4*VCLEN(R10)	;EXIT IF SUBSCRIPT NOT TOO LARGE
	BGEQU	5005$
	JMP	EXITS
5005$:
	JMP	EXFAL		;ELSE FAIL
;
;      HERE FOR TABLE REFERENCE
;
OAON3::	MOVL	SP,R7		;SET FLAG FOR NAME REFERENCE
	JSB	TFIND		;LOCATE/CREATE TABLE ELEMENT
	.ADDRESS EXFAL		;FAIL IF ACCESS FAILS
	MOVL	R10,4*1(SP)	;STORE NAME BASE ON STACK
	MOVL	R6,(SP)		;STORE NAME OFFSET ON STACK
	JMP	EXITS		;EXIT WITH RESULT ON STACK
	.PAGE
;
;      ARRAY REFERENCE (ONE SUBSCRIPT, BY VALUE)
;
O$AOV::				;ENTRY POINT
	MOVL	(SP)+,R9	;LOAD SUBSCRIPT VALUE
	MOVL	(SP)+,R10	;LOAD ARRAY VALUE
	MOVL	(R10),R6	;LOAD FIRST WORD OF ARRAY OPERAND
	CMPL	R6,#B$VCT	;JUMP IF VECTOR REFERENCE
	BEQLU	OAOV2
	CMPL	R6,#B$TBT	;JUMP IF TABLE REFERENCE
	BEQLU	OAOV3
;
;      HERE TO USE CENTRAL ARRAY REFERENCE ROUTINE
;
OAOV1::	MOVL	R10,-(SP)	;RESTACK ARRAY VALUE
	MOVL	R9,-(SP)	;RESTACK SUBSCRIPT
	MOVL	#NUM01,R9	;SET NUMBER OF SUBSCRIPTS TO ONE
	CLRL	R7		;SET FLAG FOR VALUE CALL
	JMP	ARREF		;JUMP TO ARRAY REFERENCE ROUTINE
;
;      HERE IF WE HAVE A VECTOR REFERENCE
;
OAOV2::	CMPL	(R9),#B$ICL	;USE LONG ROUTINE IF NOT INTEGER
	BNEQU	OAOV1
	MOVL	4*ICVAL(R9),R5	;LOAD INTEGER SUBSCRIPT VALUE
	MFI	R6,EXFAL	;MOVE AS ONE WORD INT, FAIL IF OVFLO
	TSTL	R6		;FAIL IF ZERO
	BNEQU	5006$
	JMP	EXFAL
5006$:
	ADDL2	#VCVLB,R6	;COMPUTE OFFSET IN WORDS
	MOVAL	0[R6],R6	;CONVERT TO BYTES
	CMPL	R6,4*VCLEN(R10)	;FAIL IF SUBSCRIPT TOO LARGE
	BLSSU	5007$
	JMP	EXFAL
5007$:
	JSB	ACESS		;ACCESS VALUE
	.ADDRESS EXFAL		;FAIL IF ACCESS FAILS
	JMP	EXIXR		;ELSE RETURN VALUE TO CALLER
;
;      HERE FOR TABLE REFERENCE BY VALUE
;
OAOV3::	CLRL	R7		;SET FLAG FOR VALUE REFERENCE
	JSB	TFIND		;CALL TABLE SEARCH ROUTINE
	.ADDRESS EXFAL		;FAIL IF ACCESS FAILS
	JMP	EXIXR		;EXIT WITH RESULT IN XR
	.PAGE
;
;      ASSIGNMENT
;
O$ASS::				;ENTRY POINT
;
;      O$RPL (PATTERN REPLACEMENT) MERGES HERE
;
OASS0::	MOVL	(SP)+,R7	;LOAD VALUE TO BE ASSIGNED
	MOVL	(SP)+,R6	;LOAD NAME OFFSET
	MOVL	(SP),R10	;LOAD NAME BASE
	MOVL	R7,(SP)		;STORE ASSIGNED VALUE AS RESULT
	JSB	ASIGN		;PERFORM ASSIGNMENT
	.ADDRESS EXFAL		;FAIL IF ASSIGNMENT FAILS
	JMP	EXITS		;EXIT WITH RESULT ON STACK
	.PAGE
;
;      COMPILATION ERROR
;
O$CER::				;ENTRY POINT
	JMP	ERROR_007	;COMPILATION ERROR ENCOUNTERED DURING EXECUTION
	.PAGE
;
;      UNARY AT (CURSOR ASSIGNMENT)
;
O$CAS::				;ENTRY POINT
	MOVL	(SP)+,R8	;LOAD NAME OFFSET (PARM2)
	MOVL	(SP)+,R9	;LOAD NAME BASE (PARM1)
	MOVL	#P$CAS,R7	;SET PCODE FOR CURSOR ASSIGNMENT
	JSB	PBILD		;BUILD NODE
	JMP	EXIXR		;JUMP FOR NEXT CODE WORD
	.PAGE
;
;      CONCATENATION
;
O$CNC::				;ENTRY POINT
	MOVL	(SP),R9		;LOAD RIGHT ARGUMENT
	CMPL	R9,#NULLS	;JUMP IF RIGHT ARG IS NULL
	BNEQU	5008$
	JMP	OCNC3
5008$:
	MOVL	4*1(SP),R10	;LOAD LEFT ARGUMENT
	CMPL	R10,#NULLS	;JUMP IF LEFT ARGUMENT IS NULL
	BNEQU	5009$
	JMP	OCNC4
5009$:
	MOVL	#B$SCL,R6	;GET CONSTANT TO TEST FOR STRING
	CMPL	R6,(R10)	;JUMP IF LEFT ARG NOT A STRING
	BEQLU	5010$
	JMP	OCNC2
5010$:
	CMPL	R6,(R9)		;JUMP IF RIGHT ARG NOT A STRING
	BEQLU	5011$
	JMP	OCNC2
5011$:
;
;      MERGE HERE TO CONCATENATE TWO STRINGS
;
OCNC1::	MOVL	4*SCLEN(R10),R6	;LOAD LEFT ARGUMENT LENGTH
	ADDL2	4*SCLEN(R9),R6	;COMPUTE RESULT LENGTH
	JSB	ALOCS		;ALLOCATE SCBLK FOR RESULT
	MOVL	R9,4*1(SP)	;STORE RESULT PTR OVER LEFT ARGUMENT
	MOVAB	CFP$F(R9),R9	;PREPARE TO STORE CHARS OF RESULT
	MOVL	4*SCLEN(R10),R6	;GET NUMBER OF CHARS IN LEFT ARG
	MOVAB	CFP$F(R10),R10	;PREPARE TO LOAD LEFT ARG CHARS
	MVC			;MOVE CHARACTERS OF LEFT ARGUMENT
	MOVL	(SP)+,R10	;LOAD RIGHT ARG POINTER, POP STACK
	MOVL	4*SCLEN(R10),R6	;LOAD NUMBER OF CHARS IN RIGHT ARG
	MOVAB	CFP$F(R10),R10	;PREPARE TO LOAD RIGHT ARG CHARS
	MVC			;MOVE CHARACTERS OF RIGHT ARGUMENT
	JMP	EXITS		;EXIT WITH RESULT ON STACK
;
;      COME HERE IF ARGUMENTS ARE NOT BOTH STRINGS
;
OCNC2::	JSB	GTSTG		;CONVERT RIGHT ARG TO STRING
	.ADDRESS OCNC5		;JUMP IF RIGHT ARG IS NOT STRING
	MOVL	R9,R10		;SAVE RIGHT ARG PTR
	JSB	GTSTG		;CONVERT LEFT ARG TO STRING
	.ADDRESS OCNC6		;JUMP IF LEFT ARG IS NOT A STRING
	MOVL	R9,-(SP)	;STACK LEFT ARGUMENT
	MOVL	R10,-(SP)	;STACK RIGHT ARGUMENT
	MOVL	R9,R10		;MOVE LEFT ARG TO PROPER REG
	MOVL	(SP),R9		;MOVE RIGHT ARG TO PROPER REG
	JMP	OCNC1		;MERGE BACK TO CONCATENATE STRINGS
	.PAGE
;
;      CONCATENATION (CONTINUED)
;
;      COME HERE FOR NULL RIGHT ARGUMENT
;
OCNC3::	ADDL2	#4,SP		;REMOVE RIGHT ARG FROM STACK
	JMP	EXITS		;RETURN WITH LEFT ARGUMENT ON STACK
;
;      HERE FOR NULL LEFT ARGUMENT
;
OCNC4::	ADDL2	#4,SP		;UNSTACK ONE ARGUMENT
	MOVL	R9,(SP)		;STORE RIGHT ARGUMENT
	JMP	EXITS		;EXIT WITH RESULT ON STACK
;
;      HERE IF RIGHT ARGUMENT IS NOT A STRING
;
OCNC5::	MOVL	R9,R10		;MOVE RIGHT ARGUMENT PTR
	MOVL	(SP)+,R9	;LOAD LEFT ARG POINTER
;
;      MERGE HERE WHEN LEFT ARGUMENT IS NOT A STRING
;
OCNC6::	JSB	GTPAT		;CONVERT LEFT ARG TO PATTERN
	.ADDRESS ERROR_008	;CONCATENATION LEFT OPND IS NOT STRING OR PATTERN
	MOVL	R9,-(SP)	;SAVE RESULT ON STACK
	MOVL	R10,R9		;POINT TO RIGHT OPERAND
	JSB	GTPAT		;CONVERT TO PATTERN
	.ADDRESS ERROR_009	;CONCATENATION RIGHT OPD IS NOT STRING OR PATTERN
	MOVL	R9,R10		;MOVE FOR PCONC
	MOVL	(SP)+,R9	;RELOAD LEFT OPERAND PTR
	JSB	PCONC		;CONCATENATE PATTERNS
	JMP	EXIXR		;EXIT WITH RESULT IN XR
	.PAGE
;
;      COMPLEMENTATION
;
O$COM::				;ENTRY POINT
	MOVL	(SP)+,R9	;LOAD OPERAND
	MOVL	(R9),R6		;LOAD TYPE WORD
;
;      MERGE BACK HERE AFTER CONVERSION
;
OCOM1::	CMPL	R6,#B$ICL	;JUMP IF INTEGER
	BEQLU	OCOM2
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	CMPL	R6,#B$RCL	;JUMP IF REAL
	BEQLU	OCOM3
	.ENDC
	JSB	GTNUM		;ELSE CONVERT TO NUMERIC
	.ADDRESS ERROR_010	;COMPLEMENTATION OPERAND IS NOT NUMERIC
	JMP	OCOM1		;BACK TO CHECK CASES
;
;      HERE TO COMPLEMENT INTEGER
;
OCOM2::	MOVL	4*ICVAL(R9),R5	;LOAD INTEGER VALUE
	MNEGL	R5,R5		;NEGATE
	BVS	5012$
	JMP	EXINT
5012$:
	JMP	ERROR_011	;COMPLEMENTATION CAUSED INTEGER OVERFLOW
	.IF NOT_EQUAL CNRA
	.IF_FALSE
;
;      HERE TO COMPLEMENT REAL
;
OCOM3::	MOVF	4*RCVAL(R9),R2	;LOAD REAL VALUE
	MNEGF	R2,R2		;NEGATE
	JMP	EXREA		;RETURN REAL RESULT
	.ENDC
	.PAGE
;
;      BINARY SLASH (DIVISION)
;
O$DVD::				;ENTRY POINT
	JSB	ARITH		;FETCH ARITHMETIC OPERANDS
	.ADDRESS ERROR_012	;DIVISION LEFT OPERAND IS NOT NUMERIC
	.ADDRESS ERROR_013	;DIVISION RIGHT OPERAND IS NOT NUMERIC
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	.ADDRESS ODVD2		;JUMP IF REAL OPERANDS
	.ENDC
;
;      HERE TO DIVIDE TWO INTEGERS
;
	DIVL2	4*ICVAL(R10),R5	;DIVIDE LEFT OPERAND BY RIGHT
	BVS	5013$
	JMP	EXINT
5013$:
	JMP	ERROR_014	;DIVISION CAUSED INTEGER OVERFLOW
	.IF NOT_EQUAL CNRA
	.IF_FALSE
;
;      HERE TO DIVIDE TWO REALS
;
ODVD2::	DIVF2	4*RCVAL(R10),R2	;DIVIDE LEFT OPERAND BY RIGHT
	BVS	5014$
	JMP	EXREA
5014$:
	JMP	ERROR_262	;DIVISION CAUSED REAL OVERFLOW
	.ENDC
	.PAGE
;
;      EXPONENTIATION
;
O$EXP::				;ENTRY POINT
	MOVL	(SP)+,R9	;LOAD EXPONENT
	JSB	GTNUM		;CONVERT TO NUMBER
	.ADDRESS ERROR_015	;EXPONENTIATION RIGHT OPERAND IS NOT NUMERIC
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	CMPL	R6,#B$ICL	;JUMP IF REAL
	BEQLU	5015$
	JMP	OEXP7
5015$:
	.ENDC
	MOVL	R9,R10		;MOVE EXPONENT
	MOVL	(SP)+,R9	;LOAD BASE
	JSB	GTNUM		;CONVERT TO NUMERIC
	.ADDRESS ERROR_016	;EXPONENTIATION LEFT OPERAND IS NOT NUMERIC
	MOVL	4*ICVAL(R10),R5	;LOAD EXPONENT
	BGEQ	5016$
	JMP	OEXP8
5016$:
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	CMPL	R6,#B$RCL	;JUMP IF BASE IS REAL
	BEQLU	OEXP3
	.ENDC
;
;      HERE TO EXPONENTIATE AN INTEGER
;
	MFI	R6,OEXP2	;CONVERT EXPONENT TO 1 WORD INTEGER
				;SET LOOP COUNTER
	MOVL	INTV1,R5	;LOAD INITIAL VALUE OF 1
	TSTL	R6		;JUMP IF NON-ZERO EXPONENT
	BNEQU	OEXP1
	TSTL	R5		;GIVE ZERO AS RESULT FOR NONZERO**0
	BEQL	5017$
	JMP	EXINT
5017$:
	JMP	OEXP4		;ELSE ERROR OF 0**0
;
;      LOOP TO PERFORM EXPONENTIATION
;
OEXP1::	MULL2	4*ICVAL(R9),R5	;MULTIPLY BY BASE
	BVS	OEXP2
	SOBGTR	R6,OEXP1	;LOOP BACK TILL COMPUTATION COMPLETE
	JMP	EXINT		;THEN RETURN INTEGER RESULT
;
;      HERE IF INTEGER OVERFLOW
;
OEXP2::	JMP	ERROR_017	;EXPONENTIATION CAUSED INTEGER OVERFLOW
	.PAGE
;
;      EXPONENTIATION (CONTINUED)
	.IF NOT_EQUAL CNRA
	.IF_FALSE
;
;      HERE TO EXPONENTIATE A REAL
;
OEXP3::	MFI	R6,OEXP6	;CONVERT EXPONENT TO ONE WORD
				;SET LOOP COUNTER
	MOVF	REAV1,R2	;LOAD 1.0 AS INITIAL VALUE
	TSTL	R6		;JUMP IF NON-ZERO EXPONENT
	BNEQU	OEXP5
	TSTF	R2		;RETURN 1.0 IF NONZERO**ZERO
	BEQL	5018$
	JMP	EXREA
5018$:
	.ENDC
;
;      HERE FOR ERROR OF 0**0 OR 0.0**0
;
OEXP4::	JMP	ERROR_018	;EXPONENTIATION RESULT IS UNDEFINED
	.IF NOT_EQUAL CNRA
	.IF_FALSE
;
;      LOOP TO PERFORM EXPONENTIATION
;
OEXP5::	MULF2	4*RCVAL(R9),R2	;MULTIPLY BY BASE
	BVS	OEXP6
	SOBGTR	R6,OEXP5	;LOOP TILL COMPUTATION COMPLETE
	JMP	EXREA		;THEN RETURN REAL RESULT
;
;      HERE IF REAL OVERFLOW
;
OEXP6::	JMP	ERROR_266	;EXPONENTIATION CAUSED REAL OVERFLOW
;
;      HERE IF REAL EXPONENT
;
OEXP7::	JMP	ERROR_267	;EXPONENTIATION RIGHT OPERAND IS REAL NOT INTEGER
	.ENDC
;
;      HERE FOR NEGATIVE EXPONENT
;
OEXP8::	JMP	ERROR_019	;EXPONENTIATION RIGHT OPERAND IS NEGATIVE
	.PAGE
;
;      FAILURE IN EXPRESSION EVALUATION
;
;      THIS ENTRY POINT IS USED IF THE EVALUATION OF AN
;      EXPRESSION, INITIATED BY THE EVALX PROCEDURE, FAILS.
;      CONTROL IS RETURNED TO AN APPROPRIATE POINT IN EVALX.
;
O$FEX::				;ENTRY POINT
	JMP	EVLX6		;JUMP TO FAILURE LOC IN EVALX
	.PAGE
;
;      FAILURE DURING EVALUATION OF A COMPLEX OR DIRECT GOTO
;
O$FIF::				;ENTRY POINT
	JMP	ERROR_020	;GOTO EVALUATION FAILURE
	.PAGE
;
;      FUNCTION CALL (MORE THAN ONE ARGUMENT)
;
O$FNC::				;ENTRY POINT
	MOVL	(R3)+,R6	;LOAD NUMBER OF ARGUMENTS
	MOVL	(R3)+,R9	;LOAD FUNCTION VRBLK POINTER
	MOVL	4*VRFNC(R9),R10	;LOAD FUNCTION POINTER
	CMPL	R6,4*FARGS(R10)	;USE CENTRAL ROUTINE IF WRONG NUM
	BEQLU	5019$
	JMP	CFUNC
5019$:
	MOVL	(R10),R11	;JUMP TO FUNCTION IF ARG COUNT OK
	JMP	(R11)
	.PAGE
;
;      FUNCTION NAME ERROR
;
O$FNE::				;ENTRY POINT
	MOVL	(R3)+,R6	;GET NEXT CODE WORD
	CMPL	R6,#ORNM$	;FAIL IF NOT EVALUATING EXPRESSION
	BNEQU	OFNE1
	TSTL	4*2(SP)	;OK IF EXPR. WAS WANTED BY VALUE
	BNEQU	5020$
	JMP	EVLX3
5020$:
;
;      HERE FOR ERROR
;
OFNE1::	JMP	ERROR_021	;FUNCTION CALLED BY NAME RETURNED A VALUE
	.PAGE
;
;      FUNCTION CALL (SINGLE ARGUMENT)
;
O$FNS::				;ENTRY POINT
	MOVL	(R3)+,R9	;LOAD FUNCTION VRBLK POINTER
	MOVL	#NUM01,R6	;SET NUMBER OF ARGUMENTS TO ONE
	MOVL	4*VRFNC(R9),R10	;LOAD FUNCTION POINTER
	CMPL	R6,4*FARGS(R10)	;USE CENTRAL ROUTINE IF WRONG NUM
	BEQLU	5021$
	JMP	CFUNC
5021$:
	MOVL	(R10),R11	;JUMP TO FUNCTION IF ARG COUNT OK
	JMP	(R11)
	.PAGE
;      CALL TO UNDEFINED FUNCTION
;
O$FUN::				;ENTRY POINT
	JMP	ERROR_022	;UNDEFINED FUNCTION CALLED
	.PAGE
;
;      EXECUTE COMPLEX GOTO
;
O$GOC::				;ENTRY POINT
	MOVL	4*1(SP),R9	;LOAD NAME BASE POINTER
	CMPL	R9,STATE	;JUMP IF NOT NATURAL VARIABLE
	BGEQU	OGOC1
	ADDL2	#4*VRTRA,R9	;ELSE POINT TO VRTRA FIELD
	MOVL	(R9),R11	;AND JUMP THROUGH IT
	JMP	(R11)
;
;      HERE IF GOTO OPERAND IS NOT NATURAL VARIABLE
;
OGOC1::	JMP	ERROR_023	;GOTO OPERAND IS NOT A NATURAL VARIABLE
	.PAGE
;
;      EXECUTE DIRECT GOTO
;
O$GOD::				;ENTRY POINT
	MOVL	(SP),R9		;LOAD OPERAND
	MOVL	(R9),R6		;LOAD FIRST WORD
	CMPL	R6,#B$CDS	;JUMP IF CODE BLOCK TO CODE ROUTINE
	BNEQU	5022$
	JMP	BCDS0
5022$:
	CMPL	R6,#B$CDC	;JUMP IF CODE BLOCK TO CODE ROUTINE
	BNEQU	5023$
	JMP	BCDC0
5023$:
	JMP	ERROR_024	;GOTO OPERAND IN DIRECT GOTO IS NOT CODE
	.PAGE
;
;      SET GOTO FAILURE TRAP
;
;      THIS ROUTINE IS EXECUTED AT THE START OF A COMPLEX OR
;      DIRECT FAILURE GOTO TO TRAP A SUBSEQUENT FAIL (SEE EXFAL)
;
O$GOF::				;ENTRY POINT
	MOVL	FLPTR,R9	;POINT TO FAIL OFFSET ON STACK
	ADDL2	#4,(R9)		;POINT FAILURE TO O$FIF WORD
	TSTL	(R3)+		;POINT TO NEXT CODE WORD
	JMP	EXITS		;EXIT TO CONTINUE
	.PAGE
;
;      BINARY DOLLAR (IMMEDIATE ASSIGNMENT)
;
;      THE PATTERN BUILT BY BINARY DOLLAR IS A COMPOUND PATTERN.
;      SEE DESCRIPTION AT START OF PATTERN MATCH SECTION FOR
;      DETAILS OF THE STRUCTURE WHICH IS CONSTRUCTED.
;
O$IMA::				;ENTRY POINT
	MOVL	#P$IMC,R7	;SET PCODE FOR LAST NODE
	MOVL	(SP)+,R8	;POP NAME OFFSET (PARM2)
	MOVL	(SP)+,R9	;POP NAME BASE (PARM1)
	JSB	PBILD		;BUILD P$IMC NODE
	MOVL	R9,R10		;SAVE PTR TO NODE
	MOVL	(SP),R9		;LOAD LEFT ARGUMENT
	JSB	GTPAT		;CONVERT TO PATTERN
	.ADDRESS ERROR_025	;IMMEDIATE ASSIGNMENT LEFT OPERAND IS NOT PATTERN
	MOVL	R9,(SP)		;SAVE PTR TO LEFT OPERAND PATTERN
	MOVL	#P$IMA,R7	;SET PCODE FOR FIRST NODE
	JSB	PBILD		;BUILD P$IMA NODE
	MOVL	(SP)+,4*PTHEN(R9);SET LEFT OPERAND AS P$IMA SUCCESSOR
	JSB	PCONC		;CONCATENATE TO FORM FINAL PATTERN
	JMP	EXIXR		;ALL DONE
	.PAGE
;
;      INDIRECTION (BY NAME)
;
O$INN::				;ENTRY POINT
	MOVL	SP,R7		;SET FLAG FOR RESULT BY NAME
	JMP	INDIR		;JUMP TO COMMON ROUTINE
	.PAGE
;
;      INTERROGATION
;
O$INT::				;ENTRY POINT
	MOVL	#NULLS,(SP)	;REPLACE OPERAND WITH NULL
	JMP	EXITS		;EXIT FOR NEXT CODE WORD
	.PAGE
;
;      INDIRECTION (BY VALUE)
;
O$INV::				;ENTRY POINT
	CLRL	R7		;SET FLAG FOR BY VALUE
	JMP	INDIR		;JUMP TO COMMON ROUTINE
	.PAGE
;
;      KEYWORD REFERENCE (BY NAME)
;
O$KWN::				;ENTRY POINT
	JSB	KWNAM		;GET KEYWORD NAME
	JMP	EXNAM		;EXIT WITH RESULT NAME
	.PAGE
;
;      KEYWORD REFERENCE (BY VALUE)
;
O$KWV::				;ENTRY POINT
	JSB	KWNAM		;GET KEYWORD NAME
	MOVL	R9,DNAMP	;DELETE KVBLK
	JSB	ACESS		;ACCESS VALUE
	.ADDRESS EXNUL		;DUMMY (UNUSED) FAILURE RETURN
	JMP	EXIXR		;JUMP WITH VALUE IN XR
	.PAGE
;
;      LOAD EXPRESSION BY NAME
;
O$LEX::				;ENTRY POINT
	MOVL	#4*EVSI$,R6	;SET SIZE OF EVBLK
	JSB	ALLOC		;ALLOCATE SPACE FOR EVBLK
	MOVL	#B$EVT,(R9)	;SET TYPE WORD
	MOVL	#TRBEV,4*EVVAR(R9) ;SET DUMMY TRBLK POINTER
	MOVL	(R3)+,R6	;LOAD EXBLK POINTER
	MOVL	R6,4*EVEXP(R9)	;SET EXBLK POINTER
	MOVL	R9,R10		;MOVE NAME BASE TO PROPER REG
	MOVL	#4*EVVAR,R6	;SET NAME OFFSET = ZERO
	JMP	EXNAM		;EXIT WITH NAME IN (XL,WA)
	.PAGE
;
;      LOAD PATTERN VALUE
;
O$LPT::				;ENTRY POINT
	MOVL	(R3)+,R9	;LOAD PATTERN POINTER
	JMP	EXIXR		;STACK PTR AND OBEY NEXT CODE WORD
	.PAGE
;
;      LOAD VARIABLE NAME
;
O$LVN::				;ENTRY POINT
	MOVL	(R3)+,R6	;LOAD VRBLK POINTER
	MOVL	R6,-(SP)	;STACK VRBLK PTR (NAME BASE)
	MOVL	#4*VRVAL,-(SP)	;STACK NAME OFFSET
	JMP	EXITS		;EXIT WITH RESULT ON STACK
	.PAGE
;
;      BINARY ASTERISK (MULTIPLICATION)
;
O$MLT::				;ENTRY POINT
	JSB	ARITH		;FETCH ARITHMETIC OPERANDS
	.ADDRESS ERROR_026	;MULTIPLICATION LEFT OPERAND IS NOT NUMERIC
	.ADDRESS ERROR_027	;MULTIPLICATION RIGHT OPERAND IS NOT NUMERIC
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	.ADDRESS OMLT1		;JUMP IF REAL OPERANDS
	.ENDC
;
;      HERE TO MULTIPLY TWO INTEGERS
;
	MULL2	4*ICVAL(R10),R5	;MULTIPLY LEFT OPERAND BY RIGHT
	BVS	5024$
	JMP	EXINT
5024$:
	JMP	ERROR_028	;MULTIPLICATION CAUSED INTEGER OVERFLOW
	.IF NOT_EQUAL CNRA
	.IF_FALSE
;
;      HERE TO MULTIPLY TWO REALS
;
OMLT1::	MULF2	4*RCVAL(R10),R2	;MULTIPLY LEFT OPERAND BY RIGHT
	BVS	5025$
	JMP	EXREA
5025$:
	JMP	ERROR_263	;MULTIPLICATION CAUSED REAL OVERFLOW
	.ENDC
	.PAGE
;
;      NAME REFERENCE
;
O$NAM::				;ENTRY POINT
	MOVL	#4*NMSI$,R6	;SET LENGTH OF NMBLK
	JSB	ALLOC		;ALLOCATE NMBLK
	MOVL	#B$NML,(R9)	;SET NAME BLOCK CODE
	MOVL	(SP)+,4*NMOFS(R9);SET NAME OFFSET FROM OPERAND
	MOVL	(SP)+,4*NMBAS(R9);SET NAME BASE FROM OPERAND
	JMP	EXIXR		;EXIT WITH RESULT IN XR
	.PAGE
;
;      NEGATION
;
;      INITIAL ENTRY
;
O$NTA::				;ENTRY POINT
	MOVL	(R3)+,R6	;LOAD NEW FAILURE OFFSET
	MOVL	FLPTR,-(SP)	;STACK OLD FAILURE POINTER
	MOVL	R6,-(SP)	;STACK NEW FAILURE OFFSET
	MOVL	SP,FLPTR	;SET NEW FAILURE POINTER
	JMP	EXITS		;JUMP TO CONTINUE EXECUTION
;
;      ENTRY AFTER SUCCESSFUL EVALUATION OF OPERAND
;
O$NTB::				;ENTRY POINT
	MOVL	4*2(SP),FLPTR	;RESTORE OLD FAILURE POINTER
	JMP	EXFAL		;AND FAIL
;
;      ENTRY FOR FAILURE DURING OPERAND EVALUATION
;
O$NTC::				;ENTRY POINT
	ADDL2	#4,SP		;POP FAILURE OFFSET
	MOVL	(SP)+,FLPTR	;RESTORE OLD FAILURE POINTER
	JMP	EXNUL		;EXIT GIVING NULL RESULT
	.PAGE
;
;      USE OF UNDEFINED OPERATOR
;
O$OUN::				;ENTRY POINT
	JMP	ERROR_029	;UNDEFINED OPERATOR REFERENCED
	.PAGE
;
;      BINARY DOT (PATTERN ASSIGNMENT)
;
;      THE PATTERN BUILT BY BINARY DOT IS A COMPOUND PATTERN.
;      SEE DESCRIPTION AT START OF PATTERN MATCH SECTION FOR
;      DETAILS OF THE STRUCTURE WHICH IS CONSTRUCTED.
;
O$PAS::				;ENTRY POINT
	MOVL	#P$PAC,R7	;LOAD PCODE FOR P$PAC NODE
	MOVL	(SP)+,R8	;LOAD NAME OFFSET (PARM2)
	MOVL	(SP)+,R9	;LOAD NAME BASE (PARM1)
	JSB	PBILD		;BUILD P$PAC NODE
	MOVL	R9,R10		;SAVE PTR TO NODE
	MOVL	(SP),R9		;LOAD LEFT OPERAND
	JSB	GTPAT		;CONVERT TO PATTERN
	.ADDRESS ERROR_030	;PATTERN ASSIGNMENT LEFT OPERAND IS NOT PATTERN
	MOVL	R9,(SP)		;SAVE PTR TO LEFT OPERAND PATTERN
	MOVL	#P$PAA,R7	;SET PCODE FOR P$PAA NODE
	JSB	PBILD		;BUILD P$PAA NODE
	MOVL	(SP)+,4*PTHEN(R9);SET LEFT OPERAND AS P$PAA SUCCESSOR
	JSB	PCONC		;CONCATENATE TO FORM FINAL PATTERN
	JMP	EXIXR		;JUMP FOR NEXT CODE WORD
	.PAGE
;
;      PATTERN MATCH (BY NAME, FOR REPLACEMENT)
;
O$PMN::				;ENTRY POINT
	CLRL	R7		;SET TYPE CODE FOR MATCH BY NAME
	JMP	MATCH		;JUMP TO ROUTINE TO START MATCH
	.PAGE
;
;      PATTERN MATCH (STATEMENT)
;
;      O$PMS IS USED IN PLACE OF O$PMV WHEN THE PATTERN MATCH
;      OCCURS AT THE OUTER (STATEMENT) LEVEL SINCE IN THIS
;      CASE THE SUBSTRING VALUE NEED NOT BE CONSTRUCTED.
;
O$PMS::				;ENTRY POINT
	MOVL	#NUM02,R7	;SET FLAG FOR STATEMENT TO MATCH
	JMP	MATCH		;JUMP TO ROUTINE TO START MATCH
	.PAGE
;
;      PATTERN MATCH (BY VALUE)
;
O$PMV::				;ENTRY POINT
	MOVL	#NUM01,R7	;SET TYPE CODE FOR VALUE MATCH
	JMP	MATCH		;JUMP TO ROUTINE TO START MATCH
	.PAGE
;
;      POP TOP ITEM ON STACK
;
O$POP::				;ENTRY POINT
	ADDL2	#4,SP		;POP TOP STACK ENTRY
	JMP	EXITS		;OBEY NEXT CODE WORD
	.PAGE
;
;      TERMINATE EXECUTION (CODE COMPILED FOR END STATEMENT)
;
O$STP::				;ENTRY POINT
	JMP	LEND0		;JUMP TO END CIRCUIT
	.PAGE
;
;      RETURN NAME FROM EXPRESSION
;      THIS ENTRY POINTS IS USED IF THE EVALUATION OF AN
;      EXPRESSION, INITIATED BY THE EVALX PROCEDURE, RETURNS
;      A NAME. CONTROL IS RETURNED TO THE PROPER POINT IN EVALX.
;
O$RNM::				;ENTRY POINT
	JMP	EVLX4		;RETURN TO EVALX PROCEDURE
	.PAGE
;
;      PATTERN REPLACEMENT
;
;      WHEN THIS ROUTINE GETS CONTROL, THE FOLLOWING STACK
;      ENTRIES HAVE BEEN MADE (SEE END OF MATCH ROUTINE P$NTH)
;
;                            SUBJECT NAME BASE
;                            SUBJECT NAME OFFSET
;                            INITIAL CURSOR VALUE
;                            FINAL CURSOR VALUE
;                            SUBJECT STRING POINTER
;      (XS) ---------------- REPLACEMENT VALUE
;
O$RPL::				;ENTRY POINT
	JSB	GTSTG		;CONVERT REPLACEMENT VAL TO STRING
	.ADDRESS ERROR_031	;PATTERN REPLACEMENT RIGHT OPERAND IS NOT STRING
;
;      GET RESULT LENGTH AND ALLOCATE RESULT SCBLK
;
	MOVL	(SP),R10	;LOAD SUBJECT STRING POINTER
	ADDL2	4*SCLEN(R10),R6	;ADD SUBJECT STRING LENGTH
	ADDL2	4*2(SP),R6	;ADD STARTING CURSOR
	SUBL2	4*1(SP),R6	;MINUS FINAL CURSOR = TOTAL LENGTH
	TSTL	R6		;JUMP IF RESULT IS NULL
	BNEQU	5026$
	JMP	ORPL3
5026$:
	MOVL	R9,-(SP)	;RESTACK REPLACEMENT STRING
	JSB	ALOCS		;ALLOCATE SCBLK FOR RESULT
	MOVL	4*3(SP),R6	;GET INITIAL CURSOR (PART 1 LEN)
	MOVL	R9,4*3(SP)	;STACK RESULT POINTER
	MOVAB	CFP$F(R9),R9	;POINT TO CHARACTERS OF RESULT
;
;      MOVE PART 1 (START OF SUBJECT) TO RESULT
;
	TSTL	R6		;JUMP IF FIRST PART IS NULL
	BEQLU	ORPL1
	MOVL	4*1(SP),R10	;ELSE POINT TO SUBJECT STRING
	MOVAB	CFP$F(R10),R10	;POINT TO SUBJECT STRING CHARS
	MVC			;MOVE FIRST PART TO RESULT
	.PAGE
;      PATTERN REPLACEMENT (CONTINUED)
;
;      NOW MOVE IN REPLACEMENT VALUE
;
ORPL1::	MOVL	(SP)+,R10	;LOAD REPLACEMENT STRING, POP
	MOVL	4*SCLEN(R10),R6	;LOAD LENGTH
	TSTL	R6		;JUMP IF NULL REPLACEMENT
	BEQLU	ORPL2
	MOVAB	CFP$F(R10),R10	;ELSE POINT TO CHARS OF REPLACEMENT
	MVC			;MOVE IN CHARS (PART 2)
;
;      NOW MOVE IN REMAINDER OF STRING (PART 3)
;
ORPL2::	MOVL	(SP)+,R10	;LOAD SUBJECT STRING POINTER, POP
	MOVL	(SP)+,R8	;LOAD FINAL CURSOR, POP
	MOVL	4*SCLEN(R10),R6	;LOAD SUBJECT STRING LENGTH
	SUBL2	R8,R6		;MINUS FINAL CURSOR = PART 3 LENGTH
	TSTL	R6		;JUMP TO ASSIGN IF PART 3 IS NULL
	BNEQU	5027$
	JMP	OASS0
5027$:
	MOVAB	CFP$F(R10)[R8],R10 ;ELSE POINT TO LAST PART OF STRING
	MVC			;MOVE PART 3 TO RESULT
	JMP	OASS0		;JUMP TO PERFORM ASSIGNMENT
;
;      HERE IF RESULT IS NULL
;
ORPL3::	ADDL2	#4*NUM02,SP	;POP SUBJECT STR PTR, FINAL CURSOR
	MOVL	#NULLS,(SP)	;SET NULL RESULT
	JMP	OASS0		;JUMP TO ASSIGN NULL VALUE
	.PAGE
;
;      RETURN VALUE FROM EXPRESSION
;
;      THIS ENTRY POINTS IS USED IF THE EVALUATION OF AN
;      EXPRESSION, INITIATED BY THE EVALX PROCEDURE, RETURNS
;      A VALUE. CONTROL IS RETURNED TO THE PROPER POINT IN EVALX
;
O$RVL::				;ENTRY POINT
	JMP	EVLX3		;RETURN TO EVALX PROCEDURE
	.PAGE
;
;      SELECTION
;
;      INITIAL ENTRY
;
O$SLA::				;ENTRY POINT
	MOVL	(R3)+,R6	;LOAD NEW FAILURE OFFSET
	MOVL	FLPTR,-(SP)	;STACK OLD FAILURE POINTER
	MOVL	R6,-(SP)	;STACK NEW FAILURE OFFSET
	MOVL	SP,FLPTR	;SET NEW FAILURE POINTER
	JMP	EXITS		;JUMP TO EXECUTE FIRST ALTERNATIVE
;
;      ENTRY AFTER SUCCESSFUL EVALUATION OF ALTERNATIVE
;
O$SLB::				;ENTRY POINT
	MOVL	(SP)+,R9	;LOAD RESULT
	ADDL2	#4,SP		;POP FAIL OFFSET
	MOVL	(SP),FLPTR	;RESTORE OLD FAILURE POINTER
	MOVL	R9,(SP)		;RESTACK RESULT
	MOVL	(R3)+,R6	;LOAD NEW CODE OFFSET
	ADDL2	R$COD,R6	;POINT TO ABSOLUTE CODE LOCATION
	MOVL	R6,R3		;SET NEW CODE POINTER
	JMP	EXITS		;JUMP TO CONTINUE PAST SELECTION
;
;      ENTRY AT START OF SUBSEQUENT ALTERNATIVES
;
O$SLC::				;ENTRY POINT
	MOVL	(R3)+,R6	;LOAD NEW FAIL OFFSET
	MOVL	R6,(SP)		;STORE NEW FAIL OFFSET
	JMP	EXITS		;JUMP TO EXECUTE NEXT ALTERNATIVE
;
;      ENTRY AT START OF LAST ALTERNATIVE
;
O$SLD::				;ENTRY POINT
	ADDL2	#4,SP		;POP FAILURE OFFSET
	MOVL	(SP)+,FLPTR	;RESTORE OLD FAILURE POINTER
	JMP	EXITS		;JUMP TO EXECUTE LAST ALTERNATIVE
	.PAGE
;
;      BINARY MINUS (SUBTRACTION)
;
O$SUB::				;ENTRY POINT
	JSB	ARITH		;FETCH ARITHMETIC OPERANDS
	.ADDRESS ERROR_032	;SUBTRACTION LEFT OPERAND IS NOT NUMERIC
	.ADDRESS ERROR_033	;SUBTRACTION RIGHT OPERAND IS NOT NUMERIC
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	.ADDRESS OSUB1		;JUMP IF REAL OPERANDS
	.ENDC
;
;      HERE TO SUBTRACT TWO INTEGERS
;
	SUBL2	4*ICVAL(R10),R5	;SUBTRACT RIGHT OPERAND FROM LEFT
	BVS	5028$
	JMP	EXINT
5028$:
	JMP	ERROR_034	;SUBTRACTION CAUSED INTEGER OVERFLOW
	.IF NOT_EQUAL CNRA
	.IF_FALSE
;
;      HERE TO SUBTRACT TWO REALS
;
OSUB1::	SUBF2	4*RCVAL(R10),R2	;SUBTRACT RIGHT OPERAND FROM LEFT
	BVS	5029$
	JMP	EXREA
5029$:
	JMP	ERROR_264	;SUBTRACTION CAUSED REAL OVERFLOW
	.ENDC
	.PAGE
;
;      DUMMY OPERATOR TO RETURN CONTROL TO TRXEQ PROCEDURE
;
O$TXR::				;ENTRY POINT
	JMP	TRXQ1		;JUMP INTO TRXEQ PROCEDURE
	.PAGE
;
;      UNEXPECTED FAILURE
;
;      NOTE THAT IF A SETEXIT TRAP IS OPERATING THEN
;      TRANSFER TO SYSTEM LABEL CONTINUE
;      WILL RESULT IN LOOPING HERE.  DIFFICULT TO AVOID EXCEPT
;      WITH A CONSIDERABLE OVERHEAD WHICH IS NOT WORTHWHILE OR
;      ELSE BY A TECHNIQUE SUCH AS SETTING KVERL TO ZERO.
;
O$UNF::				;ENTRY POINT
	JMP	ERROR_035	;UNEXPECTED FAILURE IN -NOFAIL MODE
	.PAGE
	.SUBTITLE S P I T B O L -- SNOBOL4 BUILTIN LABEL ROUTINES
;
;      THE FOLLOWING SECTION CONTAINS THE ROUTINES FOR LABELS
;      WHICH HAVE A PREDEFINED MEANING IN SNOBOL4.
;
;      CONTROL IS PASSED DIRECTLY TO THE LABEL NAME ENTRY POINT.
;
;      ENTRY NAMES ARE OF THE FORM L$XXX WHERE XXX IS THE THREE
;      LETTER VARIABLE NAME IDENTIFIER.
;
;      ENTRIES ARE IN ALPHABETICAL ORDER
	.PAGE
;
;      ABORT
;
L$ABO::				;ENTRY POINT
;
;      MERGE HERE IF EXECUTION TERMINATES IN ERROR
;
LABO1::	MOVL	KVERT,R6	;LOAD ERROR CODE
	BEQLU	LABO2
	JSB	PRTPG		;ELSE EJECT PRINTER
	JSB	ERMSG		;PRINT ERROR MESSAGE
	CLRL	R9		;INDICATE NO MESSAGE TO PRINT
	JMP	STOPR		;JUMP TO ROUTINE TO STOP RUN
;
;      HERE IF NO ERROR HAD OCCURED
;
LABO2::	JMP	ERROR_036	;GOTO ABORT WITH NO PRECEDING ERROR
	.PAGE
;
;      CONTINUE
;
L$CNT::				;ENTRY POINT
;
;      MERGE HERE AFTER EXECUTION ERROR
;
LCNT1::	MOVL	R$CNT,R9	;LOAD CONTINUATION CODE BLOCK PTR
	BEQLU	LCNT2
	CLRL	R$CNT		;CLEAR FLAG
	MOVL	R9,R$COD	;ELSE STORE AS NEW CODE BLOCK PTR
	ADDL2	STXOF,R9	;ADD FAILURE OFFSET
	MOVL	R9,R3		;LOAD CODE POINTER
	MOVL	FLPTR,SP	;RESET STACK POINTER
	JMP	EXITS		;JUMP TO TAKE INDICATED FAILURE
;
;      HERE IF NO PREVIOUS ERROR
;
LCNT2::	JMP	ERROR_037	;GOTO CONTINUE WITH NO PRECEDING ERROR
	.PAGE
;
;      END
;
L$END::				;ENTRY POINT
;
;      MERGE HERE FROM END CODE CIRCUIT
;
LEND0::	MOVL	#ENDMS,R9	;POINT TO MESSAGE /NORMAL TERM../
	JMP	STOPR		;JUMP TO ROUTINE TO STOP RUN
	.PAGE
;
;      FRETURN
;
L$FRT::				;ENTRY POINT
	MOVL	#SCFRT,R6	;POINT TO STRING /FRETURN/
	JMP	RETRN		;JUMP TO COMMON RETURN ROUTINE
	.PAGE
;
;      NRETURN
;
L$NRT::				;ENTRY POINT
	MOVL	#SCNRT,R6	;POINT TO STRING /NRETURN/
	JMP	RETRN		;JUMP TO COMMON RETURN ROUTINE
	.PAGE
;
;      RETURN
;
L$RTN::				;ENTRY POINT
	MOVL	#SCRTN,R6	;POINT TO STRING /RETURN/
	JMP	RETRN		;JUMP TO COMMON RETURN ROUTINE
	.PAGE
;
;      UNDEFINED LABEL
;
L$UND::				;ENTRY POINT
	JMP	ERROR_038	;GOTO UNDEFINED LABEL
	.PAGE
	.SUBTITLE S P I T B O L -- BLOCK ACTION ROUTINES
;
;      THE FIRST WORD OF EVERY BLOCK IN DYNAMIC STORAGE AND THE
;      VRGET, VRSTO AND VRTRA FIELDS OF A VRBLK CONTAIN A
;      POINTER TO AN ENTRY POINT IN THE PROGRAM. ALL SUCH ENTRY
;      POINTS ARE IN THE FOLLOWING SECTION EXCEPT THOSE FOR
;      PATTERN BLOCKS WHICH ARE IN THE PATTERN MATCHING SEGMENT
;      LATER ON (LABELS OF THE FORM P$XXX), AND DOPE VECTORS
;      (D$XXX) WHICH ARE IN THE DOPE VECTOR SECTION FOLLOWING
;      THE PATTERN ROUTINES (DOPE VECTORS ARE USED FOR CMBLKS).
;
;      THE ENTRY POINTS IN THIS SECTION HAVE LABELS OF THE
;      FORM B$XXY WHERE XX IS THE TWO CHARACTER BLOCK TYPE FOR
;      THE CORRESPONDING BLOCK AND Y IS ANY LETTER.
;
;      IN SOME CASES, THE POINTERS SERVE NO OTHER PURPOSE THAN
;      TO IDENTIFY THE BLOCK TYPE. IN THIS CASE THE ROUTINE
;      IS NEVER EXECUTED AND THUS NO CODE IS ASSEMBLED.
;
;      FOR EACH OF THESE ENTRY POINTS CORRESPONDING TO A BLOCK
;      AN ENTRY POINT IDENTIFICATION IS ASSEMBLED (BL$XX).
;
;      THE EXACT ENTRY CONDITIONS DEPEND ON THE MANNER IN
;      WHICH THE ROUTINE IS ACCESSED AND ARE DOCUMENTED WITH
;      THE INDIVIDUAL ROUTINES AS REQUIRED.
;
;      THE ORDER OF THESE ROUTINES IS ALPHABETICAL WITH THE
;      FOLLOWING EXCEPTIONS.
;
;      THE ROUTINES FOR SEBLK AND EXBLK ENTRIES OCCUR FIRST SO
;      THAT EXPRESSIONS CAN BE QUICKLY IDENTIFIED FROM THE FACT
;      THAT THEIR ROUTINES LIE BEFORE THE SYMBOL B$E$$.
;
;      THESE ARE IMMEDIATELY FOLLOWED BY THE ROUTINE FOR A TRBLK
;      SO THAT THE TEST AGAINST THE SYMBOL B$T$$ CHECKS FOR
;      TRAPPED VALUES OR EXPRESSION VALUES (SEE PROCEDURE EVALP)
;
;      THE PATTERN ROUTINES LIE AFTER THIS SECTION SO THAT
;      PATTERNS ARE IDENTIFIED WITH ROUTINES STARTING AT OR
;      AFTER THE INITIAL INSTRUCTION IN THESE ROUTINES (P$AAA).
;
;      THE SYMBOL B$AAA DEFINES THE FIRST LOCATION FOR BLOCK
;      ROUTINES AND THE SYMBOL P$YYY (AT THE END OF THE PATTERN
;      MATCH ROUTINES SECTION) DEFINES THE LAST SUCH ENTRY POINT
;
	.ALIGN	WORD
	.WORD	BL$$I
B$AAA::				;ENTRY POINT OF FIRST BLOCK ROUTINE
	.PAGE
;
;      EXBLK
;
;      THE ROUTINE FOR AN EXBLK LOADS THE EXPRESSION ONTO
;      THE STACK AS A VALUE.
;
;      (XR)                  POINTER TO EXBLK
;
	.ALIGN	WORD
	.WORD	BL$EX
B$EXL::				;ENTRY POINT (EXBLK)
	JMP	EXIXR		;STACK XR AND OBEY NEXT CODE WORD
	.PAGE
;
;      SEBLK
;
;      THE ROUTINE FOR SEBLK IS ACCESSED FROM THE GENERATED
;      CODE TO LOAD THE EXPRESSION VALUE ONTO THE STACK.
;
	.ALIGN	WORD
	.WORD	BL$SE
B$SEL::				;ENTRY POINT (SEBLK)
	JMP	EXIXR		;STACK XR AND OBEY NEXT CODE WORD
;
;      DEFINE SYMBOL WHICH MARKS END OF ENTRIES FOR EXPRESSIONS
;
	.ALIGN	WORD
	.WORD	BL$$I
B$E$$::				;ENTRY POINT
	.PAGE
;
;      TRBLK
;
;      THE ROUTINE FOR A TRBLK IS NEVER EXECUTED
;
	.ALIGN	WORD
	.WORD	BL$TR
B$TRT::				;ENTRY POINT (TRBLK)
;
;      DEFINE SYMBOL MARKING END OF TRAP AND EXPRESSION BLOCKS
;
	.ALIGN	WORD
	.WORD	BL$$I
B$T$$::				;END OF TRBLK,SEBLK,EXBLK ENTRIES
	.PAGE
;
;      ARBLK
;
;      THE ROUTINE FOR ARBLK IS NEVER EXECUTED
;
	.ALIGN	WORD
	.WORD	BL$AR
B$ART::				;ENTRY POINT (ARBLK)
	.PAGE
;
;      CCBLK
;
;      THE ROUTINE FOR CCBLK IS NEVER ENTERED
;
	.ALIGN	WORD
	.WORD	BL$CC
B$CCT::				;ENTRY POINT (CCBLK)
	.PAGE
;
;      CDBLK
;
;      THE CDBLK ROUTINES ARE EXECUTED FROM THE GENERATED CODE.
;      THERE ARE TWO CASES DEPENDING ON THE FORM OF CDFAL.
;
;      ENTRY FOR COMPLEX FAILURE CODE AT CDFAL
;
;      (XR)                  POINTER TO CDBLK
;
	.ALIGN	WORD
	.WORD	BL$CD
B$CDC::				;ENTRY POINT (CDBLK)
BCDC0::	MOVL	FLPTR,SP	;POP GARBAGE OFF STACK
	MOVL	4*CDFAL(R9),(SP);SET FAILURE OFFSET
	JMP	STMGO		;ENTER STMT
	.PAGE
;
;      CDBLK (CONTINUED)
;
;      ENTRY FOR SIMPLE FAILURE CODE AT CDFAL
;
;      (XR)                  POINTER TO CDBLK
;
	.ALIGN	WORD
	.WORD	BL$CD
B$CDS::				;ENTRY POINT (CDBLK)
BCDS0::	MOVL	FLPTR,SP	;POP GARBAGE OFF STACK
	MOVL	#4*CDFAL,(SP)	;SET FAILURE OFFSET
	JMP	STMGO		;ENTER STMT
	.PAGE
;
;      CMBLK
;
;      THE ROUTINE FOR A CMBLK IS NEVER EXECUTED
;
	.ALIGN	WORD
	.WORD	BL$CM
B$CMT::				;ENTRY POINT (CMBLK)
	.PAGE
;
;      CTBLK
;
;      THE ROUTINE FOR A CTBLK IS NEVER EXECUTED
;
	.ALIGN	WORD
	.WORD	BL$CT
B$CTT::				;ENTRY POINT (CTBLK)
	.PAGE
;
;      DFBLK
;
;      THE ROUTINE FOR A DFBLK IS ACCESSED FROM THE O$FNC ENTRY
;      TO CALL A DATATYPE FUNCTION AND BUILD A PDBLK.
;
;      (XL)                  POINTER TO DFBLK
;
	.ALIGN	WORD
	.WORD	BL$DF
B$DFC::				;ENTRY POINT
	MOVL	4*DFPDL(R10),R6	;LOAD LENGTH OF PDBLK
	JSB	ALLOC		;ALLOCATE PDBLK
	MOVL	#B$PDT,(R9)	;STORE TYPE WORD
	MOVL	R10,4*PDDFP(R9)	;STORE DFBLK POINTER
	MOVL	R9,R8		;SAVE POINTER TO PDBLK
	ADDL2	R6,R9		;POINT PAST PDBLK
	MOVL	4*FARGS(R10),R6	;SET TO COUNT FIELDS
;
;      LOOP TO ACQUIRE FIELD VALUES FROM STACK
;
BDFC1::	MOVL	(SP)+,-(R9)	;MOVE A FIELD VALUE
	SOBGTR	R6,BDFC1	;LOOP TILL ALL MOVED
	MOVL	R8,R9		;RECALL POINTER TO PDBLK
	JMP	EXSID		;EXIT SETTING ID FIELD
	.PAGE
;
;      EFBLK
;
;      THE ROUTINE FOR AN EFBLK IS PASSED CONTROL FORM THE O$FNC
;      ENTRY TO CALL AN EXTERNAL FUNCTION.
;
;      (XL)                  POINTER TO EFBLK
;
	.ALIGN	WORD
	.WORD	BL$EF
B$EFC::				;ENTRY POINT (EFBLK)
	.IF NOT_EQUAL CNLD
	.IF_FALSE
	MOVL	4*FARGS(R10),R8	;LOAD NUMBER OF ARGUMENTS
	MOVAL	0[R8],R8	;CONVERT TO OFFSET
	MOVL	R10,-(SP)	;SAVE POINTER TO EFBLK
	MOVL	SP,R10		;COPY POINTER TO ARGUMENTS
;
;      LOOP TO CONVERT ARGUMENTS
;
BEFC1::	ADDL2	#4,R10		;POINT TO NEXT ENTRY
	MOVL	(SP),R9		;LOAD POINTER TO EFBLK
	SUBL2	#4,R8		;DECREMENT EFTAR OFFSET
	ADDL2	R8,R9		;POINT TO NEXT EFTAR ENTRY
	MOVL	4*EFTAR(R9),R9	;LOAD EFTAR ENTRY
	.IF NOT_EQUAL CNRA
	BSW	R9,3		;SWITCH ON TYPE
	.IF_FALSE
	BSW	R9,4		;SWITCH ON TYPE
	.ENDC
	IFF	0,BEFC7		;NO CONVERSION NEEDED
	IFF	1,BEFC2		;STRING
	IFF	2,BEFC3		;INTEGER
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	IFF	3,BEFC4		;REAL
	.ENDC
	ESW			;END OF SWITCH ON TYPE
;
;      HERE TO CONVERT TO STRING
;
BEFC2::	MOVL	(R10),-(SP)	;STACK ARG PTR
	JSB	GTSTG		;CONVERT ARGUMENT TO STRING
	.ADDRESS ERROR_039	;EXTERNAL FUNCTION ARGUMENT IS NOT STRING
	JMP	BEFC6		;JUMP TO MERGE
	.PAGE
;
;      EFBLK (CONTINUED)
;
;      HERE TO CONVERT AN INTEGER
;
BEFC3::	MOVL	(R10),R9	;LOAD NEXT ARGUMENT
	MOVL	R8,BEFOF	;SAVE OFFSET
	JSB	GTINT		;CONVERT TO INTEGER
	.ADDRESS ERROR_040	;EXTERNAL FUNCTION ARGUMENT IS NOT INTEGER
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	JMP	BEFC5		;MERGE WITH REAL CASE
;
;      HERE TO CONVERT A REAL
;
BEFC4::	MOVL	(R10),R9	;LOAD NEXT ARGUMENT
	MOVL	R8,BEFOF	;SAVE OFFSET
	JSB	GTREA		;CONVERT TO REAL
	.ADDRESS ERROR_265	;EXTERNAL FUNCTION ARGUMENT IS NOT REAL
	.ENDC
;
;      INTEGER CASE MERGES HERE
;
BEFC5::	MOVL	BEFOF,R8	;RESTORE OFFSET
;
;      STRING MERGES HERE
;
BEFC6::	MOVL	R9,(R10)	;STORE CONVERTED RESULT
;
;      NO CONVERSION MERGES HERE
;
BEFC7::	TSTL	R8		;LOOP BACK IF MORE TO GO
	BNEQU	BEFC1
;
;      HERE AFTER CONVERTING ALL THE ARGUMENTS
;
	MOVL	(SP)+,R10	;RESTORE EFBLK POINTER
	MOVL	4*FARGS(R10),R6	;GET NUMBER OF ARGS
	JSB	SYSEX		;CALL ROUTINE TO CALL EXTERNAL FNC
	.ADDRESS EXFAL		;FAIL IF FAILURE
	.PAGE
;
;      EFBLK (CONTINUED)
;
;      RETURN HERE WITH RESULT IN XR
;
;      FIRST DEFEND AGAINST NON-STANDARD NULL STRING RETURNED
;
	MOVL	4*EFRSL(R10),R7	;GET RESULT TYPE ID
	BNEQU	BEFA8
	CMPL	(R9),#B$SCL	;JUMP IF NOT A STRING
	BNEQU	BEFC8
	TSTL	4*SCLEN(R9)	;RETURN NULL IF NULL
	BNEQU	5030$
	JMP	EXNUL
5030$:
;
;      HERE IF CONVERTED RESULT TO CHECK FOR NULL STRING
;
BEFA8::	CMPL	R7,#NUM01	;JUMP IF NOT A STRING
	BNEQU	BEFC8
	TSTL	4*SCLEN(R9)	;RETURN NULL IF NULL
	BNEQU	5031$
	JMP	EXNUL
5031$:
;
;      RETURN IF RESULT IS IN DYNAMIC STORAGE
;
BEFC8::	CMPL	R9,DNAMB	;JUMP IF NOT IN DYNAMIC STORAGE
	BLSSU	BEFC9
	CMPL	R9,DNAMP	;RETURN RESULT IF ALREADY DYNAMIC
	BGTRU	5032$
	JMP	EXIXR
5032$:
;
;      HERE WE COPY A RESULT INTO THE DYNAMIC REGION
;
BEFC9::	MOVL	(R9),R6		;GET POSSIBLE TYPE WORD
	TSTL	R7		;JUMP IF UNCONVERTED RESULT
	BEQLU	BEF11
	MOVL	#B$SCL,R6	;STRING
	CMPL	R7,#NUM01	;YES JUMP
	BEQLU	BEF10
	MOVL	#B$ICL,R6	;INTEGER
	CMPL	R7,#NUM02	;YES JUMP
	BEQLU	BEF10
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	MOVL	#B$RCL,R6	;REAL
	.ENDC
;
;      STORE TYPE WORD IN RESULT
;
BEF10::	MOVL	R6,(R9)		;STORED BEFORE COPYING TO DYNAMIC
;
;      MERGE FOR UNCONVERTED RESULT
;
BEF11::	JSB	BLKLN		;GET LENGTH OF BLOCK
	MOVL	R9,R10		;COPY ADDRESS OF OLD BLOCK
	JSB	ALLOC		;ALLOCATE DYNAMIC BLOCK SAME SIZE
	MOVL	R9,-(SP)	;SET POINTER TO NEW BLOCK AS RESULT
	MVW			;COPY OLD BLOCK TO DYNAMIC BLOCK
	JMP	EXITS		;EXIT WITH RESULT ON STACK
	.ENDC
	.PAGE
;
;      EVBLK
;
;      THE ROUTINE FOR AN EVBLK IS NEVER EXECUTED
;
	.ALIGN	WORD
	.WORD	BL$EV
B$EVT::				;ENTRY POINT (EVBLK)
	.PAGE
;
;      FFBLK
;
;      THE ROUTINE FOR AN FFBLK IS EXECUTED FROM THE O$FNC ENTRY
;      TO CALL A FIELD FUNCTION AND EXTRACT A FIELD VALUE/NAME.
;
;      (XL)                  POINTER TO FFBLK
;
	.ALIGN	WORD
	.WORD	BL$FF
B$FFC::				;ENTRY POINT (FFBLK)
	MOVL	R10,R9		;COPY FFBLK POINTER
	MOVL	(R3)+,R8	;LOAD NEXT CODE WORD
	MOVL	(SP),R10	;LOAD PDBLK POINTER
	CMPL	(R10),#B$PDT	;JUMP IF NOT PDBLK AT ALL
	BNEQU	BFFC2
	MOVL	4*PDDFP(R10),R6	;LOAD DFBLK POINTER FROM PDBLK
;
;      LOOP TO FIND CORRECT FFBLK FOR THIS PDBLK
;
BFFC1::	CMPL	R6,4*FFDFP(R9)	;JUMP IF THIS IS THE CORRECT FFBLK
	BEQLU	BFFC3
	MOVL	4*FFNXT(R9),R9	;ELSE LINK TO NEXT FFBLK ON CHAIN
	BNEQU	BFFC1
;
;      HERE FOR BAD ARGUMENT
;
BFFC2::	JMP	ERROR_041	;FIELD FUNCTION ARGUMENT IS WRONG DATATYPE
	.PAGE
;
;      FFBLK (CONTINUED)
;
;      HERE AFTER LOCATING CORRECT FFBLK
;
BFFC3::	MOVL	4*FFOFS(R9),R6	;LOAD FIELD OFFSET
	CMPL	R8,#OFNE$	;JUMP IF CALLED BY NAME
	BEQLU	BFFC5
	ADDL2	R6,R10		;ELSE POINT TO VALUE FIELD
	MOVL	(R10),R9	;LOAD VALUE
	CMPL	(R9),#B$TRT	;JUMP IF NOT TRAPPED
	BNEQU	BFFC4
	SUBL2	R6,R10		;ELSE RESTORE NAME BASE,OFFSET
	MOVL	R8,(SP)		;SAVE NEXT CODE WORD OVER PDBLK PTR
	JSB	ACESS		;ACCESS VALUE
	.ADDRESS EXFAL		;FAIL IF ACCESS FAILS
	MOVL	(SP),R8		;RESTORE NEXT CODE WORD
;
;      HERE AFTER GETTING VALUE IN (XR)
;
BFFC4::	MOVL	R9,(SP)		;STORE VALUE ON STACK (OVER PDBLK)
	MOVL	R8,R9		;COPY NEXT CODE WORD
	MOVL	(R9),R10	;LOAD ENTRY ADDRESS
	MOVL	R10,R11		;JUMP TO ROUTINE FOR NEXT CODE WORD
	JMP	(R11)
;
;      HERE IF CALLED BY NAME
;
BFFC5::	MOVL	R6,-(SP)	;STORE NAME OFFSET (BASE IS SET)
	JMP	EXITS		;EXIT WITH NAME ON STACK
	.PAGE
;
;      ICBLK
;
;      THE ROUTINE FOR ICBLK IS EXECUTED FROM THE GENERATED
;      CODE TO LOAD AN INTEGER VALUE ONTO THE STACK.
;
;      (XR)                  POINTER TO ICBLK
;
	.ALIGN	WORD
	.WORD	BL$IC
B$ICL::				;ENTRY POINT (ICBLK)
	JMP	EXIXR		;STACK XR AND OBEY NEXT CODE WORD
	.PAGE
;
;      KVBLK
;
;      THE ROUTINE FOR A KVBLK IS NEVER EXECUTED.
;
	.ALIGN	WORD
	.WORD	BL$KV
B$KVT::				;ENTRY POINT (KVBLK)
	.PAGE
;
;      NMBLK
;
;      THE ROUTINE FOR A NMBLK IS EXECUTED FROM THE GENERATED
;      CODE FOR THE CASE OF LOADING A NAME ONTO THE STACK
;      WHERE THE NAME IS THAT OF A NATURAL VARIABLE WHICH CAN
;      BE PREEVALUATED AT COMPILE TIME.
;
;      (XR)                  POINTER TO NMBLK
;
	.ALIGN	WORD
	.WORD	BL$NM
B$NML::				;ENTRY POINT (NMBLK)
	JMP	EXIXR		;STACK XR AND OBEY NEXT CODE WORD
	.PAGE
;
;      PDBLK
;
;      THE ROUTINE FOR A PDBLK IS NEVER EXECUTED
;
	.ALIGN	WORD
	.WORD	BL$PD
B$PDT::				;ENTRY POINT (PDBLK)
	.PAGE
;
;      PFBLK
;
;      THE ROUTINE FOR A PFBLK IS EXECUTED FROM THE ENTRY O$FNC
;      TO CALL A PROGRAM DEFINED FUNCTION.
;
;      (XL)                  POINTER TO PFBLK
;
;      THE FOLLOWING STACK ENTRIES ARE MADE BEFORE PASSING
;      CONTROL TO THE PROGRAM DEFINED FUNCTION.
;
;                            SAVED VALUE OF FIRST ARGUMENT
;                            .
;                            SAVED VALUE OF LAST ARGUMENT
;                            SAVED VALUE OF FIRST LOCAL
;                            .
;                            SAVED VALUE OF LAST LOCAL
;                            SAVED VALUE OF FUNCTION NAME
;                            SAVED CODE BLOCK PTR (R$COD)
;                            SAVED CODE POINTER (-R$COD)
;                            SAVED VALUE OF FLPRT
;                            SAVED VALUE OF FLPTR
;                            POINTER TO PFBLK
;      FLPTR --------------- ZERO (TO BE OVERWRITTEN WITH OFFS)
;
	.ALIGN	WORD
	.WORD	BL$PF
B$PFC::				;ENTRY POINT (PFBLK)
	MOVL	R10,BPFPF	;SAVE PFBLK PTR (NEED NOT BE RELOC)
	MOVL	R10,R9		;COPY FOR THE MOMENT
	MOVL	4*PFVBL(R9),R10	;POINT TO VRBLK FOR FUNCTION
;
;      LOOP TO FIND OLD VALUE OF FUNCTION
;
BPF01::	MOVL	R10,R7		;SAVE POINTER
	MOVL	4*VRVAL(R10),R10;LOAD VALUE
	CMPL	(R10),#B$TRT	;LOOP IF TRBLK
	BEQLU	BPF01
;
;      SET VALUE TO NULL AND SAVE OLD FUNCTION VALUE
;
	MOVL	R10,BPFSV	;SAVE OLD VALUE
	MOVL	R7,R10		;POINT BACK TO BLOCK WITH VALUE
	MOVL	#NULLS,4*VRVAL(R10) ;SET VALUE TO NULL
	MOVL	4*FARGS(R9),R6	;LOAD NUMBER OF ARGUMENTS
	ADDL2	#4*PFARG,R9	;POINT TO PFARG ENTRIES
	TSTL	R6		;JUMP IF NO ARGUMENTS
	BEQLU	BPF04
	MOVL	SP,R10		;PTR TO LAST ARG
	MOVAL	0[R6],R6	;CONVERT NO. OF ARGS TO BYTES OFFSET
	ADDL2	R6,R10		;POINT BEFORE FIRST ARG
	MOVL	R10,BPFXT	;REMEMBER ARG POINTER
	.PAGE
;
;      PFBLK (CONTINUED)
;
;      LOOP TO SAVE OLD ARGUMENT VALUES AND SET NEW ONES
;
BPF02::	MOVL	(R9)+,R10	;LOAD VRBLK PTR FOR NEXT ARGUMENT
;
;      LOOP THROUGH POSSIBLE TRBLK CHAIN TO FIND VALUE
;
BPF03::	MOVL	R10,R8		;SAVE POINTER
	MOVL	4*VRVAL(R10),R10;LOAD NEXT VALUE
	CMPL	(R10),#B$TRT	;LOOP BACK IF TRBLK
	BEQLU	BPF03
;
;      SAVE OLD VALUE AND GET NEW VALUE
;
	MOVL	R10,R6		;KEEP OLD VALUE
	MOVL	BPFXT,R10	;POINT BEFORE NEXT STACKED ARG
	MOVL	-(R10),R7	;LOAD ARGUMENT (NEW VALUE)
	MOVL	R6,(R10)	;SAVE OLD VALUE
	MOVL	R10,BPFXT	;KEEP ARG PTR FOR NEXT TIME
	MOVL	R8,R10		;POINT BACK TO BLOCK WITH VALUE
	MOVL	R7,4*VRVAL(R10)	;SET NEW VALUE
	CMPL	SP,BPFXT	;LOOP IF NOT ALL DONE
	BNEQU	BPF02
;
;      NOW PROCESS LOCALS
;
BPF04::	MOVL	BPFPF,R10	;RESTORE PFBLK POINTER
	MOVL	4*PFNLO(R10),R6	;LOAD NUMBER OF LOCALS
	TSTL	R6		;JUMP IF NO LOCALS
	BEQLU	BPF07
	MOVL	#NULLS,R7	;GET NULL CONSTANT
				;SET LOCAL COUNTER
;
;      LOOP TO PROCESS LOCALS
;
BPF05::	MOVL	(R9)+,R10	;LOAD VRBLK PTR FOR NEXT LOCAL
;
;      LOOP THROUGH POSSIBLE TRBLK CHAIN TO FIND VALUE
;
BPF06::	MOVL	R10,R8		;SAVE POINTER
	MOVL	4*VRVAL(R10),R10;LOAD NEXT VALUE
	CMPL	(R10),#B$TRT	;LOOP BACK IF TRBLK
	BEQLU	BPF06
;
;      SAVE OLD VALUE AND SET NULL AS NEW VALUE
;
	MOVL	R10,-(SP)	;STACK OLD VALUE
	MOVL	R8,R10		;POINT BACK TO BLOCK WITH VALUE
	MOVL	R7,4*VRVAL(R10)	;SET NULL AS NEW VALUE
	SOBGTR	R6,BPF05	;LOOP TILL ALL LOCALS PROCESSED
	.PAGE
;
;      PFBLK (CONTINUED)
;
;      HERE AFTER PROCESSING ARGUMENTS AND LOCALS
;
	.IF NOT_EQUAL CNPF
BPF07::	MOVL	R$COD,R6	;LOAD OLD CODE BLOCK POINTER
	.IF_FALSE
BPF07::	CLRL	R9		;ZERO REG XR IN CASE
	TSTL	KVPFL		;SKIP IF PROFILING IS OFF
	BEQLU	BPF7C
	CMPL	KVPFL,#NUM02	;BRANCH ON TYPE OF PROFILE
	BEQLU	BPF7A
;
;      HERE IF &PROFILE = 1
;
	JSB	SYSTM		;GET CURRENT TIME
	MOVL	R5,PFETM	;SAVE FOR A SEC
	SUBL2	PFSTM,R5	;FIND TIME USED BY CALLER
	JSB	ICBLD		;BUILD INTO AN ICBLK
	MOVL	PFETM,R5	;RELOAD CURRENT TIME
	JMP	BPF7B		;MERGE
;
;       HERE IF &PROFILE = 2
;
BPF7A::	MOVL	PFSTM,R5	;GET START TIME OF CALLING STMT
	JSB	ICBLD		;ASSEMBLE AN ICBLK ROUND IT
	JSB	SYSTM		;GET NOW TIME
;
;      BOTH TYPES OF PROFILE MERGE HERE
;
BPF7B::	MOVL	R5,PFSTM	;SET START TIME OF 1ST FUNC STMT
	MOVL	SP,PFFNC	;FLAG FUNCTION ENTRY
;
;      NO PROFILING MERGES HERE
;
BPF7C::	MOVL	R9,-(SP)	;STACK ICBLK PTR (OR ZERO)
	MOVL	R$COD,R6	;LOAD OLD CODE BLOCK POINTER
	.ENDC
	MOVL	R3,R7		;GET CODE POINTER
	SUBL2	R6,R7		;MAKE CODE POINTER INTO OFFSET
	MOVL	BPFPF,R10	;RECALL PFBLK POINTER
	MOVL	BPFSV,-(SP)	;STACK OLD VALUE OF FUNCTION NAME
	MOVL	R6,-(SP)	;STACK CODE BLOCK POINTER
	MOVL	R7,-(SP)	;STACK CODE OFFSET
	MOVL	FLPRT,-(SP)	;STACK OLD FLPRT
	MOVL	FLPTR,-(SP)	;STACK OLD FAILURE POINTER
	MOVL	R10,-(SP)	;STACK POINTER TO PFBLK
	CLRL	-(SP)		;DUMMY ZERO ENTRY FOR FAIL RETURN
	;CHK			;CHECK FOR STACK OVERFLOW
	MOVL	SP,FLPTR	;SET NEW FAIL RETURN VALUE
	MOVL	SP,FLPRT	;SET NEW FLPRT
	MOVL	KVTRA,R6	;LOAD TRACE VALUE
	ADDL2	KVFTR,R6	;ADD FTRACE VALUE
	TSTL	R6		;JUMP IF TRACING POSSIBLE
	BNEQU	BPF09
	INCL	KVFNC		;ELSE BUMP FNCLEVEL
;
;      HERE TO ACTUALLY JUMP TO FUNCTION
;
BPF08::	MOVL	4*PFCOD(R10),R9	;POINT TO CODE
	MOVL	(R9),R11	;OFF TO EXECUTE FUNCTION
	JMP	(R11)
;
;      HERE IF TRACING IS POSSIBLE
;
BPF09::	MOVL	4*PFCTR(R10),R9	;LOAD POSSIBLE CALL TRACE TRBLK
	MOVL	4*PFVBL(R10),R10;LOAD VRBLK POINTER FOR FUNCTION
	MOVL	#4*VRVAL,R6	;SET NAME OFFSET FOR VARIABLE
	TSTL	KVTRA		;JUMP IF TRACE MODE IS OFF
	BEQLU	BPF10
	TSTL	R9		;OR IF THERE IS NO CALL TRACE
	BEQLU	BPF10
;
;      HERE IF CALL TRACED
;
	DECL	KVTRA		;DECREMENT TRACE COUNT
	TSTL	4*TRFNC(R9)	;JUMP IF PRINT TRACE
	BEQLU	BPF11
	JSB	TRXEQ		;EXECUTE FUNCTION TYPE TRACE
	.PAGE
;
;      PFBLK (CONTINUED)
;
;      HERE TO TEST FOR FTRACE TRACE
;
BPF10::	TSTL	KVFTR		;JUMP IF FTRACE IS OFF
	BEQLU	BPF16
	DECL	KVFTR		;ELSE DECREMENT FTRACE
;
;      HERE FOR PRINT TRACE
;
BPF11::	JSB	PRTSN		;PRINT STATEMENT NUMBER
	JSB	PRTNM		;PRINT FUNCTION NAME
	MOVL	#CH$PP,R6	;LOAD LEFT PAREN
	JSB	PRTCH		;PRINT LEFT PAREN
	MOVL	4*1(SP),R10	;RECOVER PFBLK POINTER
	TSTL	4*FARGS(R10)	;SKIP IF NO ARGUMENTS
	BEQLU	BPF15
	CLRL	R7		;ELSE SET ARGUMENT COUNTER
	JMP	BPF13		;JUMP INTO LOOP
;
;      LOOP TO PRINT ARGUMENT VALUES
;
BPF12::	MOVL	#CH$CM,R6	;LOAD COMMA
	JSB	PRTCH		;PRINT TO SEPARATE FROM LAST ARG
;
;      MERGE HERE FIRST TIME (NO COMMA REQUIRED)
;
BPF13::	MOVL	R7,(SP)		;SAVE ARG CTR (OVER FAILOFFS IS OK)
	MOVAL	0[R7],R7	;CONVERT TO BYTE OFFSET
	ADDL2	R7,R10		;POINT TO NEXT ARGUMENT POINTER
	MOVL	4*PFARG(R10),R9	;LOAD NEXT ARGUMENT VRBLK PTR
	SUBL2	R7,R10		;RESTORE PFBLK POINTER
	MOVL	4*VRVAL(R9),R9	;LOAD NEXT VALUE
	JSB	PRTVL		;PRINT ARGUMENT VALUE
	.PAGE
;
;      HERE AFTER DEALING WITH ONE ARGUMENT
;
	MOVL	(SP),R7		;RESTORE ARGUMENT COUNTER
	INCL	R7		;INCREMENT ARGUMENT COUNTER
	CMPL	R7,4*FARGS(R10)	;LOOP IF MORE TO PRINT
	BLSSU	BPF12
;
;      MERGE HERE IN NO ARGS CASE TO PRINT PAREN
;
BPF15::	MOVL	#CH$RP,R6	;LOAD RIGHT PAREN
	JSB	PRTCH		;PRINT TO TERMINATE OUTPUT
	JSB	PRTNL		;TERMINATE PRINT LINE
;
;      MERGE HERE TO EXIT WITH TEST FOR FNCLEVEL TRACE
;
BPF16::	INCL	KVFNC		;INCREMENT FNCLEVEL
	MOVL	R$FNC,R10	;LOAD PTR TO POSSIBLE TRBLK
	JSB	KTREX		;CALL KEYWORD TRACE ROUTINE
;
;      CALL FUNCTION AFTER TRACE TESTS COMPLETE
;
	MOVL	4*1(SP),R10	;RESTORE PFBLK POINTER
	JMP	BPF08		;JUMP BACK TO EXECUTE FUNCTION
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	.PAGE
;
;      RCBLK
;
;      THE ROUTINE FOR AN RCBLK IS EXECUTED FROM THE GENERATED
;      CODE TO LOAD A REAL VALUE ONTO THE STACK.
;
;      (XR)                  POINTER TO RCBLK
;
	.ALIGN	WORD
	.WORD	BL$RC
B$RCL::				;ENTRY POINT (RCBLK)
	JMP	EXIXR		;STACK XR AND OBEY NEXT CODE WORD
	.ENDC
	.PAGE
;
;      SCBLK
;
;      THE ROUTINE FOR AN SCBLK IS EXECUTED FROM THE GENERATED
;      CODE TO LOAD A STRING VALUE ONTO THE STACK.
;
;      (XR)                  POINTER TO SCBLK
;
	.ALIGN	WORD
	.WORD	BL$SC
B$SCL::				;ENTRY POINT (SCBLK)
	JMP	EXIXR		;STACK XR AND OBEY NEXT CODE WORD
	.PAGE
;
;      TBBLK
;
;      THE ROUTINE FOR A TBBLK IS NEVER EXECUTED
;
	.ALIGN	WORD
	.WORD	BL$TB
B$TBT::				;ENTRY POINT (TBBLK)
	.PAGE
;
;      TEBLK
;
;      THE ROUTINE FOR A TEBLK IS NEVER EXECUTED
;
	.ALIGN	WORD
	.WORD	BL$TE
B$TET::				;ENTRY POINT (TEBLK)
	.PAGE
;
;      VCBLK
;
;      THE ROUTINE FOR A VCBLK IS NEVER EXECUTED
;
	.ALIGN	WORD
	.WORD	BL$VC
B$VCT::				;ENTRY POINT (VCBLK)
	.PAGE
;
;      VRBLK
;
;      THE VRBLK ROUTINES ARE EXECUTED FROM THE GENERATED CODE.
;      THERE ARE SIX ENTRIES FOR VRBLK COVERING VARIOUS CASES
;
	.ALIGN	WORD
	.WORD	BL$$I
B$VR$::				;MARK START OF VRBLK ENTRY POINTS
;
;      ENTRY FOR VRGET (TRAPPED CASE). THIS ROUTINE IS CALLED
;      FROM THE GENERATED CODE TO LOAD THE VALUE OF A VARIABLE.
;      THIS ENTRY POINT IS USED IF AN ACCESS TRACE OR INPUT
;      ASSOCIATION IS CURRENTLY ACTIVE.
;
;      (XR)                  POINTER TO VRGET FIELD OF VRBLK
;
	.ALIGN	WORD
	.WORD	BL$$I
B$VRA::				;ENTRY POINT
	MOVL	R9,R10		;COPY NAME BASE (VRGET = 0)
	MOVL	#4*VRVAL,R6	;SET NAME OFFSET
	JSB	ACESS		;ACCESS VALUE
	.ADDRESS EXFAL		;FAIL IF ACCESS FAILS
	JMP	EXIXR		;ELSE EXIT WITH RESULT IN XR
	.PAGE
;
;      VRBLK (CONTINUED)
;
;      ENTRY FOR VRSTO (ERROR CASE. THIS ROUTINE IS CALLED FROM
;      THE EXECUTED CODE FOR AN ATTEMPT TO MODIFY THE VALUE
;      OF A PROTECTED (PATTERN VALUED) NATURAL VARIABLE.
;
B$VRE::				;ENTRY POINT
	JMP	ERROR_042	;ATTEMPT TO CHANGE VALUE OF PROTECTED VARIABLE
	.PAGE
;
;      VRBLK (CONTINUED)
;
;      ENTRY FOR VRTRA (UNTRAPPED CASE). THIS ROUTINE IS CALLED
;      FROM THE EXECUTED CODE TO TRANSFER TO A LABEL.
;
;      (XR)                  POINTER TO VRTRA FIELD OF VRBLK
;
B$VRG::				;ENTRY POINT
	MOVL	4*VRLBO(R9),R9	;LOAD CODE POINTER
	MOVL	(R9),R10	;LOAD ENTRY ADDRESS
	MOVL	R10,R11		;JUMP TO ROUTINE FOR NEXT CODE WORD
	JMP	(R11)
	.PAGE
;
;      VRBLK (CONTINUED)
;
;      ENTRY FOR VRGET (UNTRAPPED CASE). THIS ROUTINE IS CALLED
;      FROM THE GENERATED CODE TO LOAD THE VALUE OF A VARIABLE.
;
;      (XR)                  POINTS TO VRGET FIELD OF VRBLK
;
B$VRL::				;ENTRY POINT
	MOVL	4*VRVAL(R9),-(SP);LOAD VALUE ONTO STACK (VRGET = 0)
	JMP	EXITS		;OBEY NEXT CODE WORD
	.PAGE
;
;      VRBLK (CONTINUED)
;
;      ENTRY FOR VRSTO (UNTRAPPED CASE). THIS ROUTINE IS CALLED
;      FROM THE GENERATED CODE TO STORE THE VALUE OF A VARIABLE.
;
;      (XR)                  POINTER TO VRSTO FIELD OF VRBLK
;
B$VRS::				;ENTRY POINT
	MOVL	(SP),4*VRVLO(R9);STORE VALUE, LEAVE ON STACK
	JMP	EXITS		;OBEY NEXT CODE WORD
	.PAGE
;
;      VRBLK (CONTINUED)
;
;      VRTRA (TRAPPED CASE). THIS ROUTINE IS CALLED FROM THE
;      GENERATED CODE TO TRANSFER TO A LABEL WHEN A LABEL
;      TRACE IS CURRENTLY ACTIVE.
;
B$VRT::				;ENTRY POINT
	SUBL2	#4*VRTRA,R9	;POINT BACK TO START OF VRBLK
	MOVL	R9,R10		;COPY VRBLK POINTER
	MOVL	#4*VRVAL,R6	;SET NAME OFFSET
	MOVL	4*VRLBL(R10),R9	;LOAD POINTER TO TRBLK
	TSTL	KVTRA		;JUMP IF TRACE IS OFF
	BEQLU	BVRT2
	DECL	KVTRA		;ELSE DECREMENT TRACE COUNT
	TSTL	4*TRFNC(R9)	;JUMP IF PRINT TRACE CASE
	BEQLU	BVRT1
	JSB	TRXEQ		;ELSE EXECUTE FULL TRACE
	JMP	BVRT2		;MERGE TO JUMP TO LABEL
;
;      HERE FOR PRINT TRACE -- PRINT COLON ( LABEL NAME )
;
BVRT1::	JSB	PRTSN		;PRINT STATEMENT NUMBER
	MOVL	R10,R9		;COPY VRBLK POINTER
	MOVL	#CH$CL,R6	;COLON
	JSB	PRTCH		;PRINT IT
	MOVL	#CH$PP,R6	;LEFT PAREN
	JSB	PRTCH		;PRINT IT
	JSB	PRTVN		;PRINT LABEL NAME
	MOVL	#CH$RP,R6	;RIGHT PAREN
	JSB	PRTCH		;PRINT IT
	JSB	PRTNL		;TERMINATE LINE
	MOVL	4*VRLBL(R10),R9	;POINT BACK TO TRBLK
;
;      MERGE HERE TO JUMP TO LABEL
;
BVRT2::	MOVL	4*TRLBL(R9),R9	;LOAD POINTER TO ACTUAL CODE
	MOVL	(R9),R11	;EXECUTE STATEMENT AT LABEL
	JMP	(R11)
	.PAGE
;
;      VRBLK (CONTINUED)
;
;      ENTRY FOR VRSTO (TRAPPED CASE). THIS ROUTINE IS CALLED
;      FROM THE GENERATED CODE TO STORE THE VALUE OF A VARIABLE.
;      THIS ENTRY IS USED WHEN A VALUE TRACE OR OUTPUT
;      ASSOCIATION IS CURRENTLY ACTIVE.
;
;      (XR)                  POINTER TO VRSTO FIELD OF VRBLK
;
B$VRV::				;ENTRY POINT
	MOVL	(SP),R7		;LOAD VALUE (LEAVE COPY ON STACK)
	SUBL2	#4*VRSTO,R9	;POINT TO VRBLK
	MOVL	R9,R10		;COPY VRBLK POINTER
	MOVL	#4*VRVAL,R6	;SET OFFSET
	JSB	ASIGN		;CALL ASSIGNMENT ROUTINE
	.ADDRESS EXFAL		;FAIL IF ASSIGNMENT FAILS
	JMP	EXITS		;ELSE RETURN WITH RESULT ON STACK
	.PAGE
;
;      XNBLK
;
;      THE ROUTINE FOR AN XNBLK IS NEVER EXECUTED
;
	.ALIGN	WORD
	.WORD	BL$XN
B$XNT::				;ENTRY POINT (XNBLK)
	.PAGE
;
;      XRBLK
;
;      THE ROUTINE FOR AN XRBLK IS NEVER EXECUTED
;
	.ALIGN	WORD
	.WORD	BL$XR
B$XRT::				;ENTRY POINT (XRBLK)
;
;      MARK ENTRY ADDRESS PAST LAST BLOCK ACTION ROUTINE
;
	.ALIGN	WORD
	.WORD	BL$$I
B$YYY::				;LAST BLOCK ROUTINE ENTRY POINT
	.PAGE
	.SUBTITLE S P I T B O L -- PATTERN MATCHING ROUTINES
;
;      THE FOLLOWING SECTION CONSISTS OF THE PATTERN MATCHING
;      ROUTINES. ALL PATTERN NODES CONTAIN A POINTER (PCODE)
;      TO ONE OF THE ROUTINES IN THIS SECTION (P$XXX).
;
;      NOTE THAT THIS SECTION FOLLOWS THE B$XXX ROUTINES TO
;      ENABLE A FAST TEST FOR THE PATTERN DATATYPE.
;
	.ALIGN	WORD
	.WORD	BL$$I
P$AAA::				;ENTRY TO MARK FIRST PATTERN
;
;
;      THE ENTRY CONDITIONS TO THE MATCH ROUTINE ARE AS FOLLOWS
;      (SEE O$PMN, O$PMV, O$PMS AND PROCEDURE MATCH).
;
;      STACK CONTENTS.
;
;                            NAME BASE (O$PMN ONLY)
;                            NAME OFFSET (O$PMN ONLY)
;                            TYPE (0-O$PMN, 1-O$PMV, 2-O$PMS)
;      PMHBS --------------- INITIAL CURSOR (ZERO)
;                            INITIAL NODE POINTER
;      XS ------------------ =NDABO (ANCHORED), =NDUNA (UNANCH)
;
;      REGISTER VALUES.
;
;           (XS)             SET AS SHOWN IN STACK DIAGRAM
;           (XR)             POINTER TO INITIAL PATTERN NODE
;           (WB)             INITIAL CURSOR (ZERO)
;
;      GLOBAL PATTERN VALUES
;
;           R$PMS            POINTER TO SUBJECT STRING SCBLK
;           PMSSL            LENGTH OF SUBJECT STRING IN CHARS
;           PMDFL            DOT FLAG, INITIALLY ZERO
;           PMHBS            SET AS SHOWN IN STACK DIAGRAM
;
;      CONTROL IS PASSED BY BRANCHING THROUGH THE PCODE
;      FIELD OF THE INITIAL PATTERN NODE (BRI (XR)).
	.PAGE
;
;      DESCRIPTION OF ALGORITHM
;
;      A PATTERN STRUCTURE IS REPRESENTED AS A LINKED GRAPH
;      OF NODES WITH THE FOLLOWING STRUCTURE.
;
;           +------------------------------------+
;           I                PCODE               I
;           +------------------------------------+
;           I                PTHEN               I
;           +------------------------------------+
;           I                PARM1               I
;           +------------------------------------+
;           I                PARM2               I
;           +------------------------------------+
;
;      PCODE IS A POINTER TO THE ROUTINE WHICH WILL PERFORM
;      THE MATCH OF THIS PARTICULAR NODE TYPE.
;
;      PTHEN IS A POINTER TO THE SUCCESSOR NODE. I.E. THE NODE
;      TO BE MATCHED IF THE ATTEMPT TO MATCH THIS NODE SUCCEEDS.
;      IF THIS IS THE LAST NODE OF THE PATTERN PTHEN POINTS
;      TO THE DUMMY NODE NDNTH WHICH INITIATES PATTERN EXIT.
;
;      PARM1, PARM2 ARE PARAMETERS WHOSE USE VARIES WITH THE
;      PARTICULAR NODE. THEY ARE ONLY PRESENT IF REQUIRED.
;
;      ALTERNATIVES ARE HANDLED WITH THE SPECIAL ALTERNATIVE
;      NODE WHOSE PARAMETER POINTS TO THE NODE TO BE MATCHED
;      IF THERE IS A FAILURE ON THE SUCCESSOR PATH.
;
;      THE FOLLOWING EXAMPLE ILLUSTRATES THE MANNER IN WHICH
;      THE STRUCTURE IS BUILT UP. THE PATTERN IS
;
;      (A / B / C) (D / E)   WHERE / IS ALTERNATION
;
;      IN THE DIAGRAM, THE NODE MARKED + REPRESENTS AN
;      ALTERNATIVE NODE AND THE DOTTED LINE FROM A + NODE
;      REPRESENTS THE PARAMETER POINTER TO THE ALTERNATIVE.
;
;      +---+     +---+     +---+     +---+
;      I + I-----I A I-----I + I-----I D I-----
;      +---+     +---+  I  +---+     +---+
;        .              I    .
;        .              I    .
;      +---+     +---+  I  +---+
;      I + I-----I B I--I  I E I-----
;      +---+     +---+  I  +---+
;        .              I
;        .              I
;      +---+            I
;      I C I------------I
;      +---+
	.PAGE
;
;      DURING THE MATCH, THE REGISTERS ARE USED AS FOLLOWS.
;
;      (XR)                  POINTS TO THE CURRENT NODE
;      (XL)                  SCRATCH
;      (XS)                  MAIN STACK POINTER
;      (WB)                  CURSOR (NUMBER OF CHARS MATCHED)
;      (WA,WC)               SCRATCH
;
;      TO KEEP TRACK OF ALTERNATIVES, THE MAIN STACK IS USED AS
;      A HISTORY STACK AND CONTAINS TWO WORD ENTRIES.
;
;      WORD 1                SAVED CURSOR VALUE
;      WORD 2                NODE TO MATCH ON FAILURE
;
;      WHEN A FAILURE OCCURS, THE MOST RECENT ENTRY ON THIS
;      STACK IS POPPED OFF TO RESTORE THE CURSOR AND POINT
;      TO THE NODE TO BE MATCHED AS AN ALTERNATIVE. THE ENTRY
;      AT THE BOTTOM OF THE STACK POINTS TO THE FOLLOWING
;      SPECIAL NODES DEPENDING ON THE SCAN MODE.
;
;      ANCHORED MODE         THE BOTTOM ENTRY POINTS TO THE
;                            SPECIAL NODE NDABO WHICH CAUSES AN
;                            ABORT. THE CURSOR VALUE STORED
;                            WITH THIS ENTRY IS ALWAYS ZERO.
;
;      UNANCHORED MODE       THE BOTTOM ENTRY POINTS TO THE
;                            SPECIAL NODE NDUNA WHICH MOVES THE
;                            ANCHOR POINT AND RESTARTS THE MATCH
;                            THE CURSOR SAVED WITH THIS ENTRY
;                            IS THE NUMBER OF CHARACTERS WHICH
;                            LIE BEFORE THE INITIAL ANCHOR POINT
;                            (I.E. THE NUMBER OF ANCHOR MOVES).
;                            THIS ENTRY IS THREE WORDS LONG AND
;                            ALSO CONTAINS THE INITIAL PATTERN.
;
;      ENTRIES ARE MADE ON THIS HISTORY STACK BY ALTERNATIVE
;      NODES AND BY SOME SPECIAL COMPOUD PATTERNS AS DESCRIBED
;      LATER ON. THE FOLLOWING GLOBAL LOCATIONS ARE USED DURING
;      PATTERN MATCHING.
;
;      R$PMS                 POINTER TO SUBJECT STRING
;      PMSSL                 LENGTH OF SUBJECT STRING
;      PMDFL                 FLAG SET NON-ZERO FOR DOT PATTERNS
;      PMHBS                 BASE PTR FOR CURRENT HISTORY STACK
;
;      THE FOLLOWING EXIT POINTS ARE AVAILABLE TO MATCH ROUTINES
;
;      SUCCP                 SUCCESS IN MATCHING CURRENT NODE
;      FAILP                 FAILURE IN MATCHING CURRENT NODE
	.PAGE
;
;      COMPOUND PATTERNS
;
;      SOME PATTERNS HAVE IMPLICIT ALTERNATIVES AND THEIR
;      REPRESENTATION IN THE PATTERN STRUCTURE CONSISTS OF A
;      LINKED SET OF NODES AS INDICATED BY THESE DIAGRAMS.
;
;      AS BEFORE, THE + REPRESENTS AN ALTERNATIVE NODE AND
;      THE DOTTED LINE FROM A + NODE IS THE PARAMETER POINTER
;      TO THE ALTERNATIVE PATTERN.
;
;      ARB
;      ---
;
;           +---+            THIS NODE (P$ARB) MATCHES NULL
;           I B I-----       AND STACKS CURSOR, SUCCESSOR PTR,
;           +---+            CURSOR (COPY) AND A PTR TO NDARC.
;
;
;
;
;      BAL
;      ---
;
;           +---+            THE P$BAL NODE SCANS A BALANCED
;           I B I-----       STRING AND THEN STACKS A POINTER
;           +---+            TO ITSELF ON THE HISTORY STACK.
	.PAGE
;
;      COMPOUND PATTERN STRUCTURES (CONTINUED)
;
;
;      ARBNO
;      -----
;
;           +---+            THIS ALTERNATIVE NODE MATCHES NULL
;      +----I + I-----       THE FIRST TIME AND STACKS A POINTER
;      I    +---+            TO THE ARGUMENT PATTERN X.
;      I      .
;      I      .
;      I    +---+            NODE (P$ABA) TO STACK CURSOR
;      I    I A I            AND HISTORY STACK BASE PTR.
;      I    +---+
;      I      I
;      I      I
;      I    +---+            THIS IS THE ARGUMENT PATTERN. AS
;      I    I X I            INDICATED, THE SUCCESSOR OF THE
;      I    +---+            PATTERN IS THE P$ABC NODE
;      I      I
;      I      I
;      I    +---+            THIS NODE (P$ABC) POPS PMHBS,
;      +----I C I            STACKS OLD PMHBS AND PTR TO NDABD
;           +---+            (UNLESS OPTIMISATION HAS OCCURRED)
;
;      STRUCTURE AND EXECUTION OF THIS PATTERN RESEMBLE THOSE OF
;      RECURSIVE PATTERN MATCHING AND IMMEDIATE ASSIGNMENT.
;      THE ALTERNATIVE NODE AT THE HEAD OF THE STRUCTURE MATCHES
;      NULL INITIALLY BUT ON SUBSEQUENT FAILURE ENSURES ATTEMPT
;      TO MATCH THE ARGUMENT.  BEFORE THE ARGUMENT IS MATCHED
;      P$ABA STACKS THE CURSOR,PMHBS AND A PTR TO P$ABB.  IF
;      THE ARGUMENT CANT BE MATCHED , P$ABB REMOVES THIS SPECIAL
;      STACK ENTRY AND FAILS.
;      IF ARGUMENT IS MATCHED , P$ABC RESTORES THE OUTER PMHBS
;      VALUE (SAVED BY P$ABA) .  THEN IF THE ARGUMENT HAS LEFT
;      ALTERNATIVES ON STACK IT STACKS THE INNER VALUE OF PMHBS
;      AND A PTR TO NDABD. IF ARGUMENT LEFT NOTHING ON THE STACK
;      IT OPTIMISES BY REMOVING ITEMS STACKED BY P$ABA.  FINALLY
;      A CHECK IS MADE THAT ARGUMENT MATCHED MORE THAN THE NULL
;      STRING (CHECK IS INTENDED TO PREVENT USELESS LOOPING).
;      IF SO THE SUCCESSOR IS AGAIN THE ALTERNATIVE NODE AT THE
;      HEAD OF THE STRUCTURE , ENSURING A POSSIBLE EXTRA ATTEMPT
;      TO MATCH THE ARG IF NECESSARY.  IF NOT , THE SUCCESSOR TO
;      ALTERNATIVE IS TAKEN SO AS TO TERMINATE THE LOOP.  P$ABD
;      RESTORES INNER PMHBS PTR AND FAILS , THUS TRYING TO MATCH
;      ALTERNATIVES LEFT BY THE ARBNO ARGUMENT.
	.PAGE
;
;      COMPOUND PATTERN STRUCTURES (CONTINUED)
;
;      BREAKX
;      ------
;
;           +---+            THIS NODE IS A BREAK NODE FOR
;      +----I B I            THE ARGUMENT TO BREAKX, IDENTICAL
;      I    +---+            TO AN ORDINARY BREAK NODE.
;      I      I
;      I      I
;      I    +---+            THIS ALTERNATIVE NODE STACKS A
;      I    I + I-----       POINTER TO THE BREAKX NODE TO
;      I    +---+            ALLOW FOR SUBSEQUENT FAILURE
;      I      .
;      I      .
;      I    +---+            THIS IS THE BREAKX NODE ITSELF. IT
;      +----I X I            MATCHES ONE CHARACTER AND THEN
;           +---+            PROCEEDS BACK TO THE BREAK NODE.
;
;
;
;
;      FENCE
;      -----
;
;           +---+            THE FENCE NODE MATCHES NULL AND
;           I F I-----       STACKS A POINTER TO NODE NDABO TO
;           +---+            ABORT ON A SUBSEQUENT REMATCH
;
;
;
;
;      SUCCEED
;      -------
;
;           +---+            THE NODE FOR SUCCEED MATCHES NULL
;           I S I-----       AND STACKS A POINTER TO ITSELF
;           +---+            TO REPEAT THE MATCH ON A FAILURE.
	.PAGE
;
;      COMPOUND PATTERNS (CONTINUED)
;
;      BINARY DOT (PATTERN ASSIGNMENT)
;      -------------------------------
;
;           +---+            THIS NODE (P$PAA) SAVES THE CURRENT
;           I A I            CURSOR AND A POINTER TO THE
;           +---+            SPECIAL NODE NDPAB ON THE STACK.
;             I
;             I
;           +---+            THIS IS THE STRUCTURE FOR THE
;           I X I            PATTERN LEFT ARGUMENT OF THE
;           +---+            PATTERN ASSIGNMENT CALL.
;             I
;             I
;           +---+            THIS NODE (P$PAC) SAVES THE CURSOR,
;           I C I-----       A PTR TO ITSELF, THE CURSOR (COPY)
;           +---+            AND A PTR TO NDPAD ON THE STACK.
;
;
;      THE FUNCTION OF THE MATCH ROUTINE FOR NDPAB (P$PAB)
;      IS SIMPLY TO UNSTACK ITSELF AND FAIL BACK ONTO THE STACK.
;
;      THE MATCH ROUTINE FOR P$PAC ALSO SETS THE GLOBAL PATTERN
;      FLAG PMDFL NON-ZERO TO INDICATE THAT PATTERN ASSIGNMENTS
;      MAY HAVE OCCURED IN THE PATTERN MATCH
;
;      IF PMDFL IS SET AT THE END OF THE MATCH (SEE P$NTH), THE
;      HISTORY STACK IS SCANNED FOR MATCHING NDPAB-NDPAD PAIRS
;      AND THE CORRESPONDING PATTERN ASSIGNMENTS ARE EXECUTED.
;
;      THE FUNCTION OF THE MATCH ROUTINE FOR NDPAD (P$PAD)
;      IS SIMPLY TO REMOVE ITS ENTRY FROM THE STACK AND FAIL.
;      THIS INCLUDES REMOVING THE SPECIAL NODE POINTER STORED
;      IN ADDITION TO THE STANDARD TWO ENTRIES ON THE STACK.
	.PAGE
;
;      COMPOUNT PATTERN STRUCTURES (CONTINUED)
;
;      FENCE (FUNCTION)
;      ----------------
;
;           +---+                      THIS NODE (P$FNA) SAVES THE CURRENT
;           I A I                      HISTORY STACK AND A POINTER TO
;           +---+                      NDFNB ON THE STACK.
;             I
;             I
;           +---+                      THIS IS THE PATTERN STRUCTURE GIVEN
;           I X I                      AS THE ARGUMENT TO THE FENCE FUNCTION
;           +---+
;             I
;             I
;           +---+                      THIS NODE P$FNC RESTORES THE OUTER
;           I C I                      HISTORY STACK PTR SAVED IN P$FNA, AND
;           +---+                      STACKS THE INNER STACK BASE PTR AND
;                                      A POINTER TO NDFND ON THE STACK
;
;      NDFNB (F$FNB) SIMPLY IS THE FAILURE EXIT FOR PATTERN
;      ARGUMENT FAILURE, AND IT POPS ITSELF AND FAILS ONTO THE
;      STACK.
;
;      THE MATCH ROUTINE P$FNC ALLOWS FOR AN OPTIMIZATION WHEN
;      THE FENCE PATTERN LEAVES NO ALTERNATIVES.  IN THIS CASE,
;      THE NDFNB ENTRY IS POPPED, AND THE MATCH CONTINUES.
;
;      NDFND (P$FND) IS ENTERED WHEN THE PATTERN FAILS AFTER
;      GOING THROUGH A NON-OPTIMIZED P$FNC, AND IT POPS THE
;      STACK BACK PAST THE INNTER STACK BASE CREATED BY P$FNA
	.PAGE
;
;      COMPOUND PATTERNS (CONTINUED)
;
;      EXPRESSION PATTERNS (RECURSIVE PATTERN MATCHES)
;      -----------------------------------------------
;
;      INITIAL ENTRY FOR A PATTERN NODE IS TO THE ROUTINE P$EXA.
;      IF THE EVALUATED RESULT OF THE EXPRESSION IS ITSELF A
;      PATTERN, THEN THE FOLLOWING STEPS ARE TAKEN TO ARRANGE
;      FOR PROPER RECURSIVE PROCESSING.
;
;      1)   A POINTER TO THE CURRENT NODE (THE P$EXA NODE) IS
;           STORED ON THE HISTORY STACK WITH A DUMMY CURSOR.
;
;      2)   A SPECIAL HISTORY STACK ENTRY IS MADE IN WHICH THE
;           NODE POINTER POINTS TO NDEXB, AND THE CURSOR VALUE
;           IS THE SAVED VALUE OF PMHBS ON ENTRY TO THIS NODE.
;           THE MATCH ROUTINE FOR NDEXB (P$EXB) RESTORES PMHBS
;           FROM THIS CURSOR ENTRY, POPS OFF THE P$EXA NODE
;           POINTER AND FAILS.
;
;      3)   THE RESULTING HISTORY STACK POINTER IS SAVED IN
;           PMHBS TO ESTABLISH A NEW LEVEL OF HISTORY STACK.
;
;      AFTER MATCHING A PATTERN, THE END OF MATCH ROUTINE GETS
;      CONTROL (P$NTH). THIS ROUTINE PROCEEDS AS FOLLOWS.
;
;      1)   LOAD THE CURRENT VALUE OF PMHBS AND RECOGNIZE THE
;           OUTER LEVEL CASE BY THE FACT THAT THE ASSOCIATED
;           CURSOR IN THIS CASE IS THE PATTERN MATCH TYPE CODE
;           WHICH IS LESS THAN 3. TERMINATE THE MATCH IN THIS
;           CASE AND CONTINUE EXECUTION OF THE PROGRAM.
;
;      2)   OTHERWISE MAKE A SPECIAL HISTORY STACK ENTRY IN
;           WHICH THE NODE POINTER POINTS TO THE SPECIAL NODE
;           NDEXC AND THE CURSOR IS THE CURRENT VALUE OF PMHBS.
;           THE MATCH ROUTINE FOR NDEXC (P$EXC) RESETS PMHBS TO
;           THIS (INNER) VALUE AND AND THEN FAILS.
;
;      3)   USING THE HISTORY STACK ENTRY MADE ON STARTING THE
;           EXPRESSION (ACCESSIBLE WITH THE CURRENT VALUE OF
;           PMHBS), RESTORE THE P$EXA NODE POINTER AND THE OLD
;           PMHBS SETTING. TAKE THE SUCCESSOR AND CONTINUE.
;
;      AN OPTIMIZATION IS POSSIBLE IF THE EXPRESSION PATTERN
;      MAKES NO ENTRIES ON THE HISTORY STACK. IN THIS CASE,
;      INSTEAD OF BUILDING THE P$EXC NODE IN STEP 2, IT IS MORE
;      EFFICIENT TO SIMPLY POP OFF THE P$EXB ENTRY AND ITS
;      ASSOCIATED NODE POINTER. THE EFFECT IS THE SAME.
	.PAGE
;
;      COMPOUND PATTERNS (CONTINUED)
;
;      BINARY DOLLAR (IMMEDIATE ASSIGNMENT)
;      ------------------------------------
;
;           +---+            THIS NODE (P$IMA) STACKS THE CURSOR
;           I A I            PMHBS AND A PTR TO NDIMB AND RESETS
;           +---+            THE STACK PTR PMHBS.
;             I
;             I
;           +---+            THIS IS THE LEFT STRUCTURE FOR THE
;           I X I            PATTERN LEFT ARGUMENT OF THE
;           +---+            IMMEDIATE ASSIGNMENT CALL.
;             I
;             I
;           +---+            THIS NODE (P$IMC) PERFORMS THE
;           I C I-----       ASSIGNMENT, POPS PMHBS AND STACKS
;           +---+            THE OLD PMHBS AND A PTR TO NDIMD.
;
;
;      THE STRUCTURE AND EXECUTION OF THIS PATTERN ARE SIMILAR
;      TO THOSE OF THE RECURSIVE EXPRESSION PATTERN MATCHING.
;
;      THE MATCH ROUTINE FOR NDIMB (P$IMB) RESTORES THE OUTER
;      LEVEL VALUE OF PMHBS, UNSTACKS THE SAVED CURSOR AND FAILS
;
;      THE MATCH ROUTINE P$IMC USES THE CURRENT VALUE OF PMHBS
;      TO LOCATE THE P$IMB ENTRY. THIS ENTRY IS USED TO MAKE
;      THE ASSIGNMENT AND RESTORE THE OUTER LEVEL VALUE OF
;      PMHBS. FINALLY, THE INNER LEVEL VALUE OF PMHBS AND A
;      POINTER TO THE SPECIAL NODE NDIMD ARE STACKED.
;
;      THE MATCH ROUTINE FOR NDIMD (P$IMD) RESTORES THE INNER
;      LEVEL VALUE OF PMHBS AND FAILS BACK INTO THE STACK.
;
;      AN OPTIMIZATION OCCURS IF THE INNER PATTERN MAKES NO
;      ENTRIES ON THE HISTORY STACK. IN THIS CASE, P$IMC POPS
;      THE P$IMB ENTRY INSTEAD OF MAKING A P$IMD ENTRY.
	.PAGE
;
;      ARBNO
;
;      SEE COMPOUND PATTERNS SECTION FOR STUCTURE AND
;      ALGORITHM FOR MATCHING THIS NODE TYPE.
;
;      NO PARAMETERS
;
	.ALIGN	WORD
	.WORD	BL$P0
P$ABA::				;P0BLK
	MOVL	R7,-(SP)	;STACK CURSOR
	MOVL	R9,-(SP)	;STACK DUMMY NODE PTR
	MOVL	PMHBS,-(SP)	;STACK OLD STACK BASE PTR
	MOVL	#NDABB,-(SP)	;STACK PTR TO NODE NDABB
	MOVL	SP,PMHBS	;STORE NEW STACK BASE PTR
	JMP	SUCCP		;SUCCEED
	.PAGE
;
;      ARBNO (REMOVE P$ABA SPECIAL STACK ENTRY)
;
;      NO PARAMETERS (DUMMY PATTERN)
;
P$ABB::				;ENTRY POINT
	MOVL	R7,PMHBS	;RESTORE HISTORY STACK BASE PTR
	JMP	FLPOP		;FAIL AND POP DUMMY NODE PTR
	.PAGE
;
;      ARBNO (CHECK IF ARG MATCHED NULL STRING)
;
;      NO PARAMETERS (DUMMY PATTERN)
;
	.ALIGN	WORD
	.WORD	BL$P0
P$ABC::				;P0BLK
	MOVL	PMHBS,R10	;KEEP P$ABB STACK BASE
	MOVL	4*3(R10),R6	;LOAD INITIAL CURSOR
	MOVL	4*1(R10),PMHBS	;RESTORE OUTER STACK BASE PTR
	CMPL	R10,SP		;JUMP IF NO HISTORY STACK ENTRIES
	BEQLU	PABC1
	MOVL	R10,-(SP)	;ELSE SAVE INNER PMHBS ENTRY
	MOVL	#NDABD,-(SP)	;STACK PTR TO SPECIAL NODE NDABD
	JMP	PABC2		;MERGE
;
;      OPTIMISE CASE OF NO EXTRA ENTRIES ON STACK FROM ARBNO ARG
;
PABC1::	ADDL2	#4*NUM04,SP	;REMOVE NDABB ENTRY AND CURSOR
;
;      MERGE TO CHECK FOR MATCHING OF NULL STRING
;
PABC2::	CMPL	R6,R7		;ALLOW FURTHER ATTEMPT IF NON-NULL
	BEQLU	5033$
	JMP	SUCCP
5033$:
	MOVL	4*PTHEN(R9),R9	;BYPASS ALTERNATIVE NODE SO AS TO ..
	JMP	SUCCP		;... REFUSE FURTHER MATCH ATTEMPTS
	.PAGE
;
;      ARBNO (TRY FOR ALTERNATIVES IN ARBNO ARGUMENT)
;
;      NO PARAMETERS (DUMMY PATTERN)
;
P$ABD::				;ENTRY POINT
	MOVL	R7,PMHBS	;RESTORE INNER STACK BASE PTR
	JMP	FAILP		;AND FAIL
	.PAGE
;
;      ABORT
;
;      NO PARAMETERS
;
	.ALIGN	WORD
	.WORD	BL$P0
P$ABO::				;P0BLK
	JMP	EXFAL		;SIGNAL STATEMENT FAILURE
	.PAGE
;
;      ALTERNATION
;
;      PARM1                 ALTERNATIVE NODE
;
	.ALIGN	WORD
	.WORD	BL$P1
P$ALT::				;P1BLK
	MOVL	R7,-(SP)	;STACK CURSOR
	MOVL	4*PARM1(R9),-(SP);STACK POINTER TO ALTERNATIVE
	;CHK			;CHECK FOR STACK OVERFLOW
	JMP	SUCCP		;IF ALL OK, THEN SUCCEED
	.PAGE
;
;      ANY (ONE CHARACTER ARGUMENT) (1-CHAR STRING ALSO)
;
;      PARM1                 CHARACTER ARGUMENT
;
	.ALIGN	WORD
	.WORD	BL$P1
P$ANS::				;P1BLK
	CMPL	R7,PMSSL	;FAIL IF NO CHARS LEFT
	BNEQU	5034$
	JMP	FAILP
5034$:
	MOVL	R$PMS,R10	;ELSE POINT TO SUBJECT STRING
	MOVAB	CFP$F(R10)[R7],R10 ;POINT TO CURRENT CHARACTER
	MOVZBL	(R10),R6	;LOAD CURRENT CHARACTER
	CMPL	R6,4*PARM1(R9)	;FAIL IF NO MATCH
	BEQLU	5035$
	JMP	FAILP
5035$:
	INCL	R7		;ELSE BUMP CURSOR
	JMP	SUCCP		;AND SUCCEED
	.PAGE
;
;      ANY (MULTI-CHARACTER ARGUMENT CASE)
;
;      PARM1                 POINTER TO CTBLK
;      PARM2                 BIT MASK TO SELECT BIT IN CTBLK
;
	.ALIGN	WORD
	.WORD	BL$P2
P$ANY::				;P2BLK
;
;      EXPRESSION ARGUMENT CASE MERGES HERE
;
PANY1::	CMPL	R7,PMSSL	;FAIL IF NO CHARACTERS LEFT
	BNEQU	5036$
	JMP	FAILP
5036$:
	MOVL	R$PMS,R10	;ELSE POINT TO SUBJECT STRING
	MOVAB	CFP$F(R10)[R7],R10 ;GET CHAR PTR TO CURRENT CHARACTER
	MOVZBL	(R10),R6	;LOAD CURRENT CHARACTER
	MOVL	4*PARM1(R9),R10	;POINT TO CTBLK
	MOVAL	0[R6],R6	;CHANGE TO BYTE OFFSET
	ADDL2	R6,R10		;POINT TO ENTRY IN CTBLK
	MOVL	4*CTCHS(R10),R6	;LOAD WORD FROM CTBLK
	MCOML	4*PARM2(R9),R11	;AND WITH SELECTED BIT
	BICL2	R11,R6
	BNEQU	5037$
	JMP	FAILP
5037$:
	INCL	R7		;ELSE BUMP CURSOR
	JMP	SUCCP		;AND SUCCEED
	.PAGE
;
;      ANY (EXPRESSION ARGUMENT)
;
;      PARM1                 EXPRESSION POINTER
;
	.ALIGN	WORD
	.WORD	BL$P1
P$AYD::				;P1BLK
	JSB	EVALS		;EVALUATE STRING ARGUMENT
	.ADDRESS ERROR_043	;ANY EVALUATED ARGUMENT IS NOT STRING
	.ADDRESS FAILP		;FAIL IF EVALUATION FAILURE
	.ADDRESS PANY1		;MERGE MULTI-CHAR CASE IF OK
	.PAGE
;
;      P$ARB                 INITIAL ARB MATCH
;
;      NO PARAMETERS
;
;      THE P$ARB NODE IS PART OF A COMPOUND PATTERN STRUCTURE
;      FOR AN ARB PATTERN (SEE DESCRIPTION OF COMPOUND PATTERNS)
;
	.ALIGN	WORD
	.WORD	BL$P0
P$ARB::				;P0BLK
	MOVL	4*PTHEN(R9),R9	;LOAD SUCCESSOR POINTER
	MOVL	R7,-(SP)	;STACK DUMMY CURSOR
	MOVL	R9,-(SP)	;STACK SUCCESSOR POINTER
	MOVL	R7,-(SP)	;STACK CURSOR
	MOVL	#NDARC,-(SP)	;STACK PTR TO SPECIAL NODE NDARC
	MOVL	(R9),R11	;EXECUTE NEXT NODE MATCHING NULL
	JMP	(R11)
	.PAGE
;
;      P$ARC                 EXTEND ARB MATCH
;
;      NO PARAMETERS (DUMMY PATTERN)
;
P$ARC::				;ENTRY POINT
	CMPL	R7,PMSSL	;FAIL AND POP STACK TO SUCCESSOR
	BNEQU	5038$
	JMP	FLPOP
5038$:
	INCL	R7		;ELSE BUMP CURSOR
	MOVL	R7,-(SP)	;STACK UPDATED CURSOR
	MOVL	R9,-(SP)	;RESTACK POINTER TO NDARC NODE
	MOVL	4*2(SP),R9	;LOAD SUCCESSOR POINTER
	MOVL	(R9),R11	;OFF TO REEXECUTE SUCCESSOR NODE
	JMP	(R11)
	.PAGE
;
;      BAL
;
;      NO PARAMETERS
;
;      THE P$BAL NODE IS PART OF THE COMPOUND STRUCTURE BUILT
;      FOR BAL (SEE SECTION ON COMPOUND PATTERNS).
;
	.ALIGN	WORD
	.WORD	BL$P0
P$BAL::				;P0BLK
	CLRL	R8		;ZERO PARENTHESES LEVEL COUNTER
	MOVL	R$PMS,R10	;POINT TO SUBJECT STRING
	MOVAB	CFP$F(R10)[R7],R10 ;POINT TO CURRENT CHARACTER
	JMP	PBAL2		;JUMP INTO SCAN LOOP
;
;      LOOP TO SCAN OUT CHARACTERS
;
PBAL1::	MOVZBL	(R10)+,R6	;LOAD NEXT CHARACTER, BUMP POINTER
	INCL	R7		;PUSH CURSOR FOR CHARACTER
	CMPL	R6,#CH$PP	;JUMP IF LEFT PAREN
	BEQLU	PBAL3
	CMPL	R6,#CH$RP	;JUMP IF RIGHT PAREN
	BEQLU	PBAL4
	TSTL	R8		;ELSE SUCCEED IF AT OUTER LEVEL
	BEQLU	PBAL5
;
;      HERE AFTER PROCESSING ONE CHARACTER
;
PBAL2::	CMPL	R7,PMSSL	;LOOP BACK UNLESS END OF STRING
	BNEQU	PBAL1
	JMP	FAILP		;IN WHICH CASE, FAIL
;
;      HERE ON LEFT PAREN
;
PBAL3::	INCL	R8		;BUMP PAREN LEVEL
	JMP	PBAL2		;LOOP BACK TO CHECK END OF STRING
;
;      HERE FOR RIGHT PAREN
;
PBAL4::	TSTL	R8		;FAIL IF NO MATCHING LEFT PAREN
	BNEQU	5039$
	JMP	FAILP
5039$:
	DECL	R8		;ELSE DECREMENT LEVEL COUNTER
	TSTL	R8		;LOOP BACK IF NOT AT OUTER LEVEL
	BNEQU	PBAL2
;
;      HERE AFTER SUCCESSFULLY SCANNING A BALANCED STRING
;
PBAL5::	MOVL	R7,-(SP)	;STACK CURSOR
	MOVL	R9,-(SP)	;STACK PTR TO BAL NODE FOR EXTEND
	JMP	SUCCP		;AND SUCCEED
	.PAGE
;
;      BREAK (EXPRESSION ARGUMENT)
;
;      PARM1                 EXPRESSION POINTER
;
	.ALIGN	WORD
	.WORD	BL$P1
P$BKD::				;P1BLK
	JSB	EVALS		;EVALUATE STRING EXPRESSION
	.ADDRESS ERROR_044	;BREAK EVALUATED ARGUMENT IS NOT STRING
	.ADDRESS FAILP		;FAIL IF EVALUATION FAILS
	.ADDRESS PBRK1		;MERGE WITH MULTI-CHAR CASE IF OK
	.PAGE
;
;      BREAK (ONE CHARACTER ARGUMENT)
;
;      PARM1                 CHARACTER ARGUMENT
;
	.ALIGN	WORD
	.WORD	BL$P1
P$BKS::				;P1BLK
	MOVL	PMSSL,R8	;GET SUBJECT STRING LENGTH
	SUBL2	R7,R8		;GET NUMBER OF CHARACTERS LEFT
	TSTL	R8		;FAIL IF NO CHARACTERS LEFT
	BNEQU	5040$
	JMP	FAILP
5040$:
				;SET COUNTER FOR CHARS LEFT
	MOVL	R$PMS,R10	;POINT TO SUBJECT STRING
	MOVAB	CFP$F(R10)[R7],R10 ;POINT TO CURRENT CHARACTER
;
;      LOOP TO SCAN TILL BREAK CHARACTER FOUND
;
PBKS1::	MOVZBL	(R10)+,R6	;LOAD NEXT CHAR, BUMP POINTER
	CMPL	R6,4*PARM1(R9)	;SUCCEED IF BREAK CHARACTER FOUND
	BNEQU	5041$
	JMP	SUCCP
5041$:
	INCL	R7		;ELSE PUSH CURSOR
	SOBGTR	R8,PBKS1	;LOOP BACK IF MORE TO GO
	JMP	FAILP		;FAIL IF END OF STRING, NO BREAK CHR
	.PAGE
;
;      BREAK (MULTI-CHARACTER ARGUMENT)
;
;      PARM1                 POINTER TO CTBLK
;      PARM2                 BIT MASK TO SELECT BIT COLUMN
;
	.ALIGN	WORD
	.WORD	BL$P2
P$BRK::				;P2BLK
;
;      EXPRESSION ARGUMENT MERGES HERE
;
PBRK1::	MOVL	PMSSL,R8	;LOAD SUBJECT STRING LENGTH
	SUBL2	R7,R8		;GET NUMBER OF CHARACTERS LEFT
	TSTL	R8		;FAIL IF NO CHARACTERS LEFT
	BNEQU	5042$
	JMP	FAILP
5042$:
				;SET COUNTER FOR CHARACTERS LEFT
	MOVL	R$PMS,R10	;ELSE POINT TO SUBJECT STRING
	MOVAB	CFP$F(R10)[R7],R10 ;POINT TO CURRENT CHARACTER
	MOVL	R9,PSAVE	;SAVE NODE POINTER
;
;      LOOP TO SEARCH FOR BREAK CHARACTER
;
PBRK2::	MOVZBL	(R10)+,R6	;LOAD NEXT CHAR, BUMP POINTER
	MOVL	4*PARM1(R9),R9	;LOAD POINTER TO CTBLK
	MOVAL	0[R6],R6	;CONVERT TO BYTE OFFSET
	ADDL2	R6,R9		;POINT TO CTBLK ENTRY
	MOVL	4*CTCHS(R9),R6	;LOAD CTBLK WORD
	MOVL	PSAVE,R9	;RESTORE NODE POINTER
	MCOML	4*PARM2(R9),R11	;AND WITH SELECTED BIT
	BICL2	R11,R6
	BEQLU	5043$
	JMP	SUCCP
5043$:
	INCL	R7		;ELSE PUSH CURSOR
	SOBGTR	R8,PBRK2	;LOOP BACK UNLESS END OF STRING
	JMP	FAILP		;FAIL IF END OF STRING, NO BREAK CHR
	.PAGE
;
;      BREAKX (EXTENSION)
;
;      THIS IS THE ENTRY WHICH CAUSES AN EXTENSION OF A BREAKX
;      MATCH WHEN FAILURE OCCURS. SEE SECTION ON COMPOUND
;      PATTERNS FOR FULL DETAILS OF BREAKX MATCHING.
;
;      NO PARAMETERS
;
	.ALIGN	WORD
	.WORD	BL$P0
P$BKX::				;P0BLK
	INCL	R7		;STEP CURSOR PAST PREVIOUS BREAK CHR
	JMP	SUCCP		;SUCCEED TO REMATCH BREAK
	.PAGE
;
;      BREAKX (EXPRESSION ARGUMENT)
;
;      SEE SECTION ON COMPOUND PATTERNS FOR FULL STRUCTURE OF
;      BREAKX PATTERN. THE ACTUAL CHARACTER MATCHING USES A
;      BREAK NODE. HOWEVER, THE ENTRY FOR THE EXPRESSION
;      ARGUMENT CASE IS SEPARATED TO GET PROPER ERROR MESSAGES.
;
;      PARM1                 EXPRESSION POINTER
;
	.ALIGN	WORD
	.WORD	BL$P1
P$BXD::				;P1BLK
	JSB	EVALS		;EVALUATE STRING ARGUMENT
	.ADDRESS ERROR_045	;BREAKX EVALUATED ARGUMENT IS NOT STRING
	.ADDRESS FAILP		;FAIL IF EVALUATION FAILS
	.ADDRESS PBRK1		;MERGE WITH BREAK IF ALL OK
	.PAGE
;
;      CURSOR ASSIGNMENT
;
;      PARM1                 NAME BASE
;      PARM2                 NAME OFFSET
;
	.ALIGN	WORD
	.WORD	BL$P2
P$CAS::				;P2BLK
	MOVL	R9,-(SP)	;SAVE NODE POINTER
	MOVL	R7,-(SP)	;SAVE CURSOR
	MOVL	4*PARM1(R9),R10	;LOAD NAME BASE
	MOVL	R7,R5		;LOAD CURSOR AS INTEGER
	MOVL	4*PARM2(R9),R7	;LOAD NAME OFFSET
	JSB	ICBLD		;GET ICBLK FOR CURSOR VALUE
	MOVL	R7,R6		;MOVE NAME OFFSET
	MOVL	R9,R7		;MOVE VALUE TO ASSIGN
	JSB	ASINP		;PERFORM ASSIGNMENT
	.ADDRESS FLPOP		;FAIL ON ASSIGNMENT FAILURE
	MOVL	(SP)+,R7	;ELSE RESTORE CURSOR
	MOVL	(SP)+,R9	;RESTORE NODE POINTER
	JMP	SUCCP		;AND SUCCEED MATCHING NULL
	.PAGE
;
;      EXPRESSION NODE (P$EXA, INITIAL ENTRY)
;
;      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
;      ALGORITHMS FOR HANDLING EXPRESSION NODES.
;
;      PARM1                 EXPRESSION POINTER
;
	.ALIGN	WORD
	.WORD	BL$P1
P$EXA::				;P1BLK
	JSB	EVALP		;EVALUATE EXPRESSION
	.ADDRESS FAILP		;FAIL IF EVALUATION FAILS
	CMPL	R6,#P$AAA	;JUMP IF RESULT IS NOT A PATTERN
	BLEQU	PEXA1
;
;      HERE IF RESULT OF EXPRESSION IS A PATTERN
;
	MOVL	R7,-(SP)	;STACK DUMMY CURSOR
	MOVL	R9,-(SP)	;STACK PTR TO P$EXA NODE
	MOVL	PMHBS,-(SP)	;STACK HISTORY STACK BASE PTR
	MOVL	#NDEXB,-(SP)	;STACK PTR TO SPECIAL NODE NDEXB
	MOVL	SP,PMHBS	;STORE NEW STACK BASE POINTER
	MOVL	R10,R9		;COPY NODE POINTER
	MOVL	(R9),R11	;MATCH FIRST NODE IN EXPRESSION PAT
	JMP	(R11)
;
;      HERE IF RESULT OF EXPRESSION IS NOT A PATTERN
;
PEXA1::	CMPL	R6,#B$SCL	;JUMP IF IT IS ALREADY A STRING
	BEQLU	PEXA2
	MOVL	R10,-(SP)	;ELSE STACK RESULT
	MOVL	R9,R10		;SAVE NODE POINTER
	JSB	GTSTG		;CONVERT RESULT TO STRING
	.ADDRESS ERROR_046	;EXPRESSION DOES NOT EVALUATE TO PATTERN
	MOVL	R9,R8		;COPY STRING POINTER
	MOVL	R10,R9		;RESTORE NODE POINTER
	MOVL	R8,R10		;COPY STRING POINTER AGAIN
;
;      MERGE HERE WITH STRING POINTER IN XL
;
PEXA2::	TSTL	4*SCLEN(R10)	;JUST SUCCEED IF NULL STRING
	BNEQU	5044$
	JMP	SUCCP
5044$:
	JMP	PSTR1		;ELSE MERGE WITH STRING CIRCUIT
	.PAGE
;
;      EXPRESSION NODE (P$EXB, REMOVE NDEXB ENTRY)
;
;      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
;      ALGORITHMS FOR HANDLING EXPRESSION NODES.
;
;      NO PARAMETERS (DUMMY PATTERN)
;
P$EXB::				;ENTRY POINT
	MOVL	R7,PMHBS	;RESTORE OUTER LEVEL STACK POINTER
	JMP	FLPOP		;FAIL AND POP P$EXA NODE PTR
	.PAGE
;
;      EXPRESSION NODE (P$EXC, REMOVE NDEXC ENTRY)
;
;      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
;      ALGORITHMS FOR HANDLING EXPRESSION NODES.
;
;      NO PARAMETERS (DUMMY PATTERN)
;
P$EXC::				;ENTRY POINT
	MOVL	R7,PMHBS	;RESTORE INNER STACK BASE POINTER
	JMP	FAILP		;AND FAIL INTO EXPR PATTERN ALTERNVS
	.PAGE
;
;      FAIL
;
;      NO PARAMETERS
;
	.ALIGN	WORD
	.WORD	BL$P0
P$FAL::				;P0BLK
	JMP	FAILP		;JUST SIGNAL FAILURE
	.PAGE
;
;      FENCE
;
;      SEE COMPOUND PATTERNS SECTION FOR THE STRUCTURE AND
;      ALGORITHM FOR MATCHING THIS NODE TYPE.
;
;      NO PARAMETERS
;
	.ALIGN	WORD
	.WORD	BL$P0
P$FEN::				;P0BLK
	MOVL	R7,-(SP)	;STACK DUMMY CURSOR
	MOVL	#NDABO,-(SP)	;STACK PTR TO ABORT NODE
	JMP	SUCCP		;AND SUCCEED MATCHING NULL
	.PAGE
;
;      FENCE (FUNCTION)
;
;      SEE COMPOUND PATTERNS COMMENTS AT START OF THIS SECTION
;      FOR DETAILS OF SCHEME
;
;      NO PARAMETERS
;
	.ALIGN	WORD
	.WORD	BL$P0
P$FNA::				;P0BLK
	MOVL	PMHBS,-(SP)	;STACK CURRENT HISTORY STACK BASE
	MOVL	#NDFNB,-(SP)	;STACK INDIR PTR TO P$FNB (FAILURE)
	MOVL	SP,PMHBS	;BEGIN NEW HISTORY STACK
	JMP	SUCCP		;SUCCEED
	.PAGE
;
;      FENCE (FUNCTION) (RESET HISTORY STACK AND FAIL)
;
;      NO PARAMETERS (DUMMY PATTERN)
;
	.ALIGN	WORD
	.WORD	BL$P0
P$FNB::				;P0BLK
	MOVL	R7,PMHBS	;RESTORE OUTER PMHBS STACK BASE
	JMP	FAILP		;...AND FAIL
	.PAGE
;
;      FENCE (FUNCTION) (MAKE FENCE TRAP ENTRY ON STACK)
;
;      NO PARAMETERS (DUMMY PATTERN)
;
	.ALIGN	WORD
	.WORD	BL$P0
P$FNC::				;P0BLK
	MOVL	PMHBS,R10	;GET INNER STACK BASE PTR
	MOVL	4*NUM01(R10),PMHBS ;RESTORE OUTER STACK BASE
	CMPL	R10,SP		;OPTIMIZE IF NO ALTERNATIVES
	BEQLU	PFNC1
	MOVL	R10,-(SP)	;ELSE STACK INNER STACK BASE
	MOVL	#NDFND,-(SP)	;STACK PTR TO NDFND
	JMP	SUCCP		;SUCCEED
;
;      HERE WHEN FENCE FUNCTION LEFT NOTHING ON THE STACK
;
PFNC1::	ADDL2	#4*NUM02,SP	;POP OFF P$FNB ENTRY
	JMP	SUCCP		;SUCCEED
	.PAGE
;
;      FENCE (FUNCTION) (SKIP PAST ALTERNATIVES ON FAILURE)
;
;      NO PARAMETERS (DUMMY PATTERN)
;
	.ALIGN	WORD
	.WORD	BL$P0
P$FND::				;P0BLK
	MOVL	R7,SP		;POP STACK TO FENCE() HISTORY BASE
	JMP	FLPOP		;POP BASE ENTRY AND FAIL
	.PAGE
;
;      IMMEDIATE ASSIGNMENT (INITIAL ENTRY, SAVE CURRENT CURSOR)
;
;      SEE COMPOUND PATTERNS DESCRIPTION FOR DETAILS OF THE
;      STRUCTURE AND ALGORITHM FOR MATCHING THIS NODE TYPE.
;
;      NO PARAMETERS
;
	.ALIGN	WORD
	.WORD	BL$P0
P$IMA::				;P0BLK
	MOVL	R7,-(SP)	;STACK CURSOR
	MOVL	R9,-(SP)	;STACK DUMMY NODE POINTER
	MOVL	PMHBS,-(SP)	;STACK OLD STACK BASE POINTER
	MOVL	#NDIMB,-(SP)	;STACK PTR TO SPECIAL NODE NDIMB
	MOVL	SP,PMHBS	;STORE NEW STACK BASE POINTER
	JMP	SUCCP		;AND SUCCEED
	.PAGE
;
;      IMMEDIATE ASSIGNMENT (REMOVE CURSOR MARK ENTRY)
;
;      SEE COMPOUND PATTERNS DESCRIPTION FOR DETAILS OF THE
;      STRUCTURE AND ALGORITHMS FOR MATCHING THIS NODE TYPE.
;
;      NO PARAMETERS (DUMMY PATTERN)
;
P$IMB::				;ENTRY POINT
	MOVL	R7,PMHBS	;RESTORE HISTORY STACK BASE PTR
	JMP	FLPOP		;FAIL AND POP DUMMY NODE PTR
	.PAGE
;
;      IMMEDIATE ASSIGNMENT (PERFORM ACTUAL ASSIGNMENT)
;
;      SEE COMPOUND PATTERNS DESCRIPTION FOR DETAILS OF THE
;      STRUCTURE AND ALGORITHMS FOR MATCHING THIS NODE TYPE.
;
;      PARM1                 NAME BASE OF VARIABLE
;      PARM2                 NAME OFFSET OF VARIABLE
;
	.ALIGN	WORD
	.WORD	BL$P2
P$IMC::				;P2BLK
	MOVL	PMHBS,R10	;LOAD POINTER TO P$IMB ENTRY
	MOVL	R7,R6		;COPY FINAL CURSOR
	MOVL	4*3(R10),R7	;LOAD INITIAL CURSOR
	MOVL	4*1(R10),PMHBS	;RESTORE OUTER STACK BASE POINTER
	CMPL	R10,SP		;JUMP IF NO HISTORY STACK ENTRIES
	BEQLU	PIMC1
	MOVL	R10,-(SP)	;ELSE SAVE INNER PMHBS POINTER
	MOVL	#NDIMD,-(SP)	;AND A PTR TO SPECIAL NODE NDIMD
	JMP	PIMC2		;MERGE
;
;      HERE IF NO ENTRIES MADE ON HISTORY STACK
;
PIMC1::	ADDL2	#4*NUM04,SP	;REMOVE NDIMB ENTRY AND CURSOR
;
;      MERGE HERE TO PERFORM ASSIGNMENT
;
PIMC2::	MOVL	R6,-(SP)	;SAVE CURRENT (FINAL) CURSOR
	MOVL	R9,-(SP)	;SAVE CURRENT NODE POINTER
	MOVL	R$PMS,R10	;POINT TO SUBJECT STRING
	SUBL2	R7,R6		;COMPUTE SUBSTRING LENGTH
	JSB	SBSTR		;BUILD SUBSTRING
	MOVL	R9,R7		;MOVE RESULT
	MOVL	(SP),R9		;RELOAD NODE POINTER
	MOVL	4*PARM1(R9),R10	;LOAD NAME BASE
	MOVL	4*PARM2(R9),R6	;LOAD NAME OFFSET
	JSB	ASINP		;PERFORM ASSIGNMENT
	.ADDRESS FLPOP		;FAIL IF ASSIGNMENT FAILS
	MOVL	(SP)+,R9	;ELSE RESTORE NODE POINTER
	MOVL	(SP)+,R7	;RESTORE CURSOR
	JMP	SUCCP		;AND SUCCEED
	.PAGE
;
;      IMMEDIATE ASSIGNMENT (REMOVE NDIMD ENTRY ON FAILURE)
;
;      SEE COMPOUND PATTERNS DESCRIPTION FOR DETAILS OF THE
;      STRUCTURE AND ALGORITHMS FOR MATCHING THIS NODE TYPE.
;
;      NO PARAMETERS (DUMMY PATTERN)
;
P$IMD::				;ENTRY POINT
	MOVL	R7,PMHBS	;RESTORE INNER STACK BASE POINTER
	JMP	FAILP		;AND FAIL
	.PAGE
;
;      LEN (INTEGER ARGUMENT)
;
;      PARM1                 INTEGER ARGUMENT
;
	.ALIGN	WORD
	.WORD	BL$P1
P$LEN::				;P1BLK
;
;      EXPRESSION ARGUMENT CASE MERGES HERE
;
PLEN1::	ADDL2	4*PARM1(R9),R7	;PUSH CURSOR INDICATED AMOUNT
	CMPL	R7,PMSSL	;SUCCEED IF NOT OFF END
	BGTRU	5045$
	JMP	SUCCP
5045$:
	JMP	FAILP		;ELSE FAIL
	.PAGE
;
;      LEN (EXPRESSION ARGUMENT)
;
;      PARM1                 EXPRESSION POINTER
;
	.ALIGN	WORD
	.WORD	BL$P1
P$LND::				;P1BLK
	JSB	EVALI		;EVALUATE INTEGER ARGUMENT
	.ADDRESS ERROR_047	;LEN EVALUATED ARGUMENT IS NOT INTEGER
	.ADDRESS ERROR_048	;LEN EVALUATED ARGUMENT IS NEGATIVE OR TOO LARGE
	.ADDRESS FAILP		;FAIL IF EVALUATION FAILS
	.ADDRESS PLEN1		;MERGE WITH NORMAL CIRCUIT IF OK
	.PAGE
;
;      NOTANY (EXPRESSION ARGUMENT)
;
;      PARM1                 EXPRESSION POINTER
;
	.ALIGN	WORD
	.WORD	BL$P1
P$NAD::				;P1BLK
	JSB	EVALS		;EVALUATE STRING ARGUMENT
	.ADDRESS ERROR_049	;NOTANY EVALUATED ARGUMENT IS NOT STRING
	.ADDRESS FAILP		;FAIL IF EVALUATION FAILS
	.ADDRESS PNAY1		;MERGE WITH MULTI-CHAR CASE IF OK
	.PAGE
;
;      NOTANY (ONE CHARACTER ARGUMENT)
;
;      PARM1                 CHARACTER ARGUMENT
;
	.ALIGN	WORD
	.WORD	BL$P1
P$NAS::				;ENTRY POINT
	CMPL	R7,PMSSL	;FAIL IF NO CHARS LEFT
	BNEQU	5046$
	JMP	FAILP
5046$:
	MOVL	R$PMS,R10	;ELSE POINT TO SUBJECT STRING
	MOVAB	CFP$F(R10)[R7],R10 ;POINT TO CURRENT CHARACTER IN STRIN
	MOVZBL	(R10),R6	;LOAD CURRENT CHARACTER
	CMPL	R6,4*PARM1(R9)	;FAIL IF MATCH
	BNEQU	5047$
	JMP	FAILP
5047$:
	INCL	R7		;ELSE BUMP CURSOR
	JMP	SUCCP		;AND SUCCEED
	.PAGE
;
;      NOTANY (MULTI-CHARACTER STRING ARGUMENT)
;
;      PARM1                 POINTER TO CTBLK
;      PARM2                 BIT MASK TO SELECT BIT COLUMN
;
	.ALIGN	WORD
	.WORD	BL$P2
P$NAY::				;P2BLK
;
;      EXPRESSION ARGUMENT CASE MERGES HERE
;
PNAY1::	CMPL	R7,PMSSL	;FAIL IF NO CHARACTERS LEFT
	BNEQU	5048$
	JMP	FAILP
5048$:
	MOVL	R$PMS,R10	;ELSE POINT TO SUBJECT STRING
	MOVAB	CFP$F(R10)[R7],R10 ;POINT TO CURRENT CHARACTER
	MOVZBL	(R10),R6	;LOAD CURRENT CHARACTER
	MOVAL	0[R6],R6	;CONVERT TO BYTE OFFSET
	MOVL	4*PARM1(R9),R10	;LOAD POINTER TO CTBLK
	ADDL2	R6,R10		;POINT TO ENTRY IN CTBLK
	MOVL	4*CTCHS(R10),R6	;LOAD ENTRY FROM CTBLK
	MCOML	4*PARM2(R9),R11	;AND WITH SELECTED BIT
	BICL2	R11,R6
	BEQLU	5049$
	JMP	FAILP
5049$:
	INCL	R7		;ELSE BUMP CURSOR
	JMP	SUCCP		;AND SUCCEED
	.PAGE
;
;      END OF PATTERN MATCH
;
;      THIS ROUTINE IS ENTERED ON SUCCESSFUL COMPLETION.
;      SEE DESCRIPTION OF EXPRESSION PATTERNS IN COMPOUND
;      PATTERN SECTION FOR HANDLING OF RECURSION IN MATCHING.
;
;      NO PARAMETERS (DUMMY PATTERN)
;
P$NTH::				;ENTRY POINT
	MOVL	PMHBS,R10	;LOAD POINTER TO BASE OF STACK
	MOVL	4*1(R10),R6	;LOAD SAVED PMHBS (OR PATTERN TYPE)
	CMPL	R6,#NUM02	;JUMP IF OUTER LEVEL (PATTERN TYPE)
	BLEQU	PNTH2
;
;      HERE WE ARE AT THE END OF MATCHING AN EXPRESSION PATTERN
;
	MOVL	R6,PMHBS	;RESTORE OUTER STACK BASE POINTER
	MOVL	4*2(R10),R9	;RESTORE POINTER TO P$EXA NODE
	CMPL	R10,SP		;JUMP IF NO HISTORY STACK ENTRIES
	BEQLU	PNTH1
	MOVL	R10,-(SP)	;ELSE STACK INNER STACK BASE PTR
	MOVL	#NDEXC,-(SP)	;STACK PTR TO SPECIAL NODE NDEXC
	JMP	SUCCP		;AND SUCCEED
;
;      HERE IF NO HISTORY STACK ENTRIES DURING PATTERN
;
PNTH1::	ADDL2	#4*NUM04,SP	;REMOVE P$EXB ENTRY AND NODE PTR
	JMP	SUCCP		;AND SUCCEED
;
;      HERE IF END OF MATCH AT OUTER LEVEL
;
PNTH2::	MOVL	R7,PMSSL	;SAVE FINAL CURSOR IN SAFE PLACE
	TSTL	PMDFL		;JUMP IF NO PATTERN ASSIGNMENTS
	BEQLU	PNTH6
	.PAGE
;
;      END OF PATTERN MATCH (CONTINUED)
;
;      NOW WE MUST PERFORM PATTERN ASSIGNMENTS. THIS IS DONE BY
;      SCANNING THE HISTORY STACK FOR MATCHING NDPAB-NDPAD PAIRS
;
PNTH3::	SUBL2	#4,R10		;POINT PAST CURSOR ENTRY
	MOVL	-(R10),R6	;LOAD NODE POINTER
	CMPL	R6,#NDPAD	;JUMP IF NDPAD ENTRY
	BEQLU	PNTH4
	CMPL	R6,#NDPAB	;JUMP IF NOT NDPAB ENTRY
	BNEQU	PNTH5
;
;      HERE FOR NDPAB ENTRY, STACK INITIAL CURSOR
;      NOTE THAT THERE MUST BE MORE ENTRIES ON THE STACK.
;
	MOVL	4*1(R10),-(SP)	;STACK INITIAL CURSOR
	;CHK			;CHECK FOR STACK OVERFLOW
	JMP	PNTH3		;LOOP BACK IF OK
;
;      HERE FOR NDPAD ENTRY. THE STARTING CURSOR FROM THE
;      MATCHING NDPAD ENTRY IS NOW THE TOP STACK ENTRY.
;
PNTH4::	MOVL	4*1(R10),R6	;LOAD FINAL CURSOR
	MOVL	(SP),R7		;LOAD INITIAL CURSOR FROM STACK
	MOVL	R10,(SP)	;SAVE HISTORY STACK SCAN PTR
	SUBL2	R7,R6		;COMPUTE LENGTH OF STRING
;
;      BUILD SUBSTRING AND PERFORM ASSIGNMENT
;
	MOVL	R$PMS,R10	;POINT TO SUBJECT STRING
	JSB	SBSTR		;CONSTRUCT SUBSTRING
	MOVL	R9,R7		;COPY SUBSTRING POINTER
	MOVL	(SP),R10	;RELOAD HISTORY STACK SCAN PTR
	MOVL	4*2(R10),R10	;LOAD POINTER TO P$PAC NODE WITH NAM
	MOVL	4*PARM2(R10),R6	;LOAD NAME OFFSET
	MOVL	4*PARM1(R10),R10;LOAD NAME BASE
	JSB	ASINP		;PERFORM ASSIGNMENT
	.ADDRESS EXFAL		;MATCH FAILS IF NAME EVAL FAILS
	MOVL	(SP)+,R10	;ELSE RESTORE HISTORY STACK PTR
	.PAGE
;
;      END OF PATTERN MATCH (CONTINUED)
;
;      HERE CHECK FOR END OF ENTRIES
;
PNTH5::	CMPL	R10,SP		;LOOP IF MORE ENTRIES TO SCAN
	BNEQU	PNTH3
;
;      HERE AFTER DEALING WITH PATTERN ASSIGNMENTS
;
PNTH6::	MOVL	PMHBS,SP	;WIPE OUT HISTORY STACK
	MOVL	(SP)+,R7	;LOAD INITIAL CURSOR
	MOVL	(SP)+,R8	;LOAD MATCH TYPE CODE
	MOVL	PMSSL,R6	;LOAD FINAL CURSOR VALUE
	MOVL	R$PMS,R10	;POINT TO SUBJECT STRING
	CLRL	R$PMS		;CLEAR SUBJECT STRING PTR FOR GBCOL
	TSTL	R8		;JUMP IF CALL BY NAME
	BEQLU	PNTH7
	CMPL	R8,#NUM02	;EXIT IF STATEMENT LEVEL CALL
	BNEQU	5050$
	JMP	EXITS
5050$:
;
;      HERE WE HAVE A CALL BY VALUE, BUILD SUBSTRING
;
	SUBL2	R7,R6		;COMPUTE LENGTH OF STRING
	JSB	SBSTR		;BUILD SUBSTRING
	JMP	EXIXR		;AND EXIT WITH SUBSTRING VALUE
;
;      HERE FOR CALL BY NAME, MAKE STACK ENTRIES FOR O$RPL
;
PNTH7::	MOVL	R7,-(SP)	;STACK INITIAL CURSOR
	MOVL	R6,-(SP)	;STACK FINAL CURSOR
	MOVL	R10,-(SP)	;STACK SUBJECT STRING POINTER
	JMP	EXITS		;EXIT WITH SPECIAL ENTRY ON STACK
	.PAGE
;
;      POS (INTEGER ARGUMENT)
;
;      PARM1                 INTEGER ARGUMENT
;
	.ALIGN	WORD
	.WORD	BL$P1
P$POS::				;P1BLK
;
;      EXPRESSION ARGUMENT CASE MERGES HERE
;
PPOS1::	CMPL	R7,4*PARM1(R9)	;SUCCEED IF AT RIGHT LOCATION
	BNEQU	5051$
	JMP	SUCCP
5051$:
	JMP	FAILP		;ELSE FAIL
	.PAGE
;
;      POS (EXPRESSION ARGUMENT)
;
;      PARM1                 EXPRESSION POINTER
;
	.ALIGN	WORD
	.WORD	BL$P1
P$PSD::				;P1BLK
	JSB	EVALI		;EVALUATE INTEGER ARGUMENT
	.ADDRESS ERROR_050	;POS EVALUATED ARGUMENT IS NOT INTEGER
	.ADDRESS ERROR_051	;POS EVALUATED ARGUMENT IS NEGATIVE OR TOO LARGE
	.ADDRESS FAILP		;FAIL IF EVALUATION FAILS
	.ADDRESS PPOS1		;MERGE WITH NORMAL CASE IF OK
	.PAGE
;
;      PATTERN ASSIGNMENT (INITIAL ENTRY, SAVE CURSOR)
;
;      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
;      ALGORITHMS FOR MATCHING THIS NODE TYPE.
;
;      NO PARAMETERS
;
	.ALIGN	WORD
	.WORD	BL$P0
P$PAA::				;P0BLK
	MOVL	R7,-(SP)	;STACK INITIAL CURSOR
	MOVL	#NDPAB,-(SP)	;STACK PTR TO NDPAB SPECIAL NODE
	JMP	SUCCP		;AND SUCCEED MATCHING NULL
	.PAGE
;
;      PATTERN ASSIGNMENT (REMOVE SAVED CURSOR)
;
;      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
;      ALGORITHMS FOR MATCHING THIS NODE TYPE.
;
;      NO PARAMETERS (DUMMY PATTERN)
;
P$PAB::				;ENTRY POINT
	JMP	FAILP		;JUST FAIL (ENTRY IS ALREADY POPPED)
	.PAGE
;
;      PATTERN ASSIGNMENT (END OF MATCH, MAKE ASSIGN ENTRY)
;
;      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
;      ALGORITHMS FOR MATCHING THIS NODE TYPE.
;
;      PARM1                 NAME BASE OF VARIABLE
;      PARM2                 NAME OFFSET OF VARIABLE
;
	.ALIGN	WORD
	.WORD	BL$P2
P$PAC::				;P2BLK
	MOVL	R7,-(SP)	;STACK DUMMY CURSOR VALUE
	MOVL	R9,-(SP)	;STACK POINTER TO P$PAC NODE
	MOVL	R7,-(SP)	;STACK FINAL CURSOR
	MOVL	#NDPAD,-(SP)	;STACK PTR TO SPECIAL NDPAD NODE
	MOVL	SP,PMDFL	;SET DOT FLAG NON-ZERO
	JMP	SUCCP		;AND SUCCEED
	.PAGE
;
;      PATTERN ASSIGNMENT (REMOVE ASSIGN ENTRY)
;
;      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
;      ALGORITHMS FOR MATCHING THIS NODE TYPE.
;
;      NO PARAMETERS (DUMMY NODE)
;
P$PAD::				;ENTRY POINT
	JMP	FLPOP		;FAIL AND REMOVE P$PAC NODE
	.PAGE
;
;      REM
;
;      NO PARAMETERS
;
	.ALIGN	WORD
	.WORD	BL$P0
P$REM::				;P0BLK
	MOVL	PMSSL,R7	;POINT CURSOR TO END OF STRING
	JMP	SUCCP		;AND SUCCEED
	.PAGE
;
;      RPOS (EXPRESSION ARGUMENT)
;
;      PARM1                 EXPRESSION POINTER
;
	.ALIGN	WORD
	.WORD	BL$P1
P$RPD::				;P1BLK
	JSB	EVALI		;EVALUATE INTEGER ARGUMENT
	.ADDRESS ERROR_052	;RPOS EVALUATED ARGUMENT IS NOT INTEGER
	.ADDRESS ERROR_053	;RPOS EVALUATED ARGUMENT IS NEGATIVE OR TOO LARGE
	.ADDRESS FAILP		;FAIL IF EVALUATION FAILS
	.ADDRESS PRPS1		;MERGE WITH NORMAL CASE IF OK
	.PAGE
;
;      RPOS (INTEGER ARGUMENT)
;
;      PARM1                 INTEGER ARGUMENT
;
	.ALIGN	WORD
	.WORD	BL$P1
P$RPS::				;P1BLK
;
;      EXPRESSION ARGUMENT CASE MERGES HERE
;
PRPS1::	MOVL	PMSSL,R8	;GET LENGTH OF STRING
	SUBL2	R7,R8		;GET NUMBER OF CHARACTERS REMAINING
	CMPL	R8,4*PARM1(R9)	;SUCCEED IF AT RIGHT LOCATION
	BNEQU	5052$
	JMP	SUCCP
5052$:
	JMP	FAILP		;ELSE FAIL
	.PAGE
;
;      RTAB (INTEGER ARGUMENT)
;
;      PARM1                 INTEGER ARGUMENT
;
	.ALIGN	WORD
	.WORD	BL$P1
P$RTB::				;P1BLK
;
;      EXPRESSION ARGUMENT CASE MERGES HERE
;
PRTB1::	MOVL	R7,R8		;SAVE INITIAL CURSOR
	MOVL	PMSSL,R7	;POINT TO END OF STRING
	CMPL	R7,4*PARM1(R9)	;FAIL IF STRING NOT LONG ENOUGH
	BGEQU	5053$
	JMP	FAILP
5053$:
	SUBL2	4*PARM1(R9),R7	;ELSE SET NEW CURSOR
	CMPL	R7,R8		;AND SUCCEED IF NOT TOO FAR ALREADY
	BLSSU	5054$
	JMP	SUCCP
5054$:
	JMP	FAILP		;IN WHICH CASE, FAIL
	.PAGE
;
;      RTAB (EXPRESSION ARGUMENT)
;
;      PARM1                 EXPRESSION POINTER
;
	.ALIGN	WORD
	.WORD	BL$P1
P$RTD::				;P1BLK
	JSB	EVALI		;EVALUATE INTEGER ARGUMENT
	.ADDRESS ERROR_054	;RTAB EVALUATED ARGUMENT IS NOT INTEGER
	.ADDRESS ERROR_055	;RTAB EVALUATED ARGUMENT IS NEGATIVE OR TOO LARGE
	.ADDRESS FAILP		;FAIL IF EVALUATION FAILS
	.ADDRESS PRTB1		;MERGE WITH NORMAL CASE IF SUCCESS
	.PAGE
;
;      SPAN (EXPRESSION ARGUMENT)
;
;      PARM1                 EXPRESSION POINTER
;
	.ALIGN	WORD
	.WORD	BL$P1
P$SPD::				;P1BLK
	JSB	EVALS		;EVALUATE STRING ARGUMENT
	.ADDRESS ERROR_056	;SPAN EVALUATED ARGUMENT IS NOT STRING
	.ADDRESS FAILP		;FAIL IF EVALUATION FAILS
	.ADDRESS PSPN1		;MERGE WITH MULTI-CHAR CASE IF OK
	.PAGE
;
;      SPAN (MULTI-CHARACTER ARGUMENT CASE)
;
;      PARM1                 POINTER TO CTBLK
;      PARM2                 BIT MASK TO SELECT BIT COLUMN
;
	.ALIGN	WORD
	.WORD	BL$P2
P$SPN::				;P2BLK
;
;      EXPRESSION ARGUMENT CASE MERGES HERE
;
PSPN1::	MOVL	PMSSL,R8	;COPY SUBJECT STRING LENGTH
	SUBL2	R7,R8		;CALCULATE NUMBER OF CHARACTERS LEFT
	TSTL	R8		;FAIL IF NO CHARACTERS LEFT
	BNEQU	5055$
	JMP	FAILP
5055$:
	MOVL	R$PMS,R10	;POINT TO SUBJECT STRING
	MOVAB	CFP$F(R10)[R7],R10 ;POINT TO CURRENT CHARACTER
	MOVL	R7,PSAVC	;SAVE INITIAL CURSOR
	MOVL	R9,PSAVE	;SAVE NODE POINTER
				;SET COUNTER FOR CHARS LEFT
;
;      LOOP TO SCAN MATCHING CHARACTERS
;
PSPN2::	MOVZBL	(R10)+,R6	;LOAD NEXT CHARACTER, BUMP POINTER
	MOVAL	0[R6],R6	;CONVERT TO BYTE OFFSET
	MOVL	4*PARM1(R9),R9	;POINT TO CTBLK
	ADDL2	R6,R9		;POINT TO CTBLK ENTRY
	MOVL	4*CTCHS(R9),R6	;LOAD CTBLK ENTRY
	MOVL	PSAVE,R9	;RESTORE NODE POINTER
	MCOML	4*PARM2(R9),R11	;AND WITH SELECTED BIT
	BICL2	R11,R6
	BEQLU	PSPN3
	INCL	R7		;ELSE PUSH CURSOR
	SOBGTR	R8,PSPN2	;LOOP BACK UNLESS END OF STRING
;
;      HERE AFTER SCANNING MATCHING CHARACTERS
;
PSPN3::	CMPL	R7,PSAVC	;SUCCEED IF CHARS MATCHED
	BEQLU	5056$
	JMP	SUCCP
5056$:
	JMP	FAILP		;ELSE FAIL IF NULL STRING MATCHED
	.PAGE
;
;      SPAN (ONE CHARACTER ARGUMENT)
;
;      PARM1                 CHARACTER ARGUMENT
;
	.ALIGN	WORD
	.WORD	BL$P1
P$SPS::				;P1BLK
	MOVL	PMSSL,R8	;GET SUBJECT STRING LENGTH
	SUBL2	R7,R8		;CALCULATE NUMBER OF CHARACTERS LEFT
	TSTL	R8		;FAIL IF NO CHARACTERS LEFT
	BNEQU	5057$
	JMP	FAILP
5057$:
	MOVL	R$PMS,R10	;ELSE POINT TO SUBJECT STRING
	MOVAB	CFP$F(R10)[R7],R10 ;POINT TO CURRENT CHARACTER
	MOVL	R7,PSAVC	;SAVE INITIAL CURSOR
				;SET COUNTER FOR CHARACTERS LEFT
;
;      LOOP TO SCAN MATCHING CHARACTERS
;
PSPS1::	MOVZBL	(R10)+,R6	;LOAD NEXT CHARACTER, BUMP POINTER
	CMPL	R6,4*PARM1(R9)	;JUMP IF NO MATCH
	BNEQU	PSPS2
	INCL	R7		;ELSE PUSH CURSOR
	SOBGTR	R8,PSPS1	;AND LOOP UNLESS END OF STRING
;
;      HERE AFTER SCANNING MATCHING CHARACTERS
;
PSPS2::	CMPL	R7,PSAVC	;SUCCEED IF CHARS MATCHED
	BEQLU	5058$
	JMP	SUCCP
5058$:
	JMP	FAILP		;FAIL IF NULL STRING MATCHED
	.PAGE
;
;      MULTI-CHARACTER STRING
;
;      NOTE THAT ONE CHARACTER STRINGS USE THE CIRCUIT FOR
;      ONE CHARACTER ANY ARGUMENTS (P$AN1).
;
;      PARM1                 POINTER TO SCBLK FOR STRING ARG
;
	.ALIGN	WORD
	.WORD	BL$P1
P$STR::				;P1BLK
	MOVL	4*PARM1(R9),R10	;GET POINTER TO STRING
;
;      MERGE HERE AFTER EVALUATING EXPRESSION WITH STRING VALUE
;
PSTR1::	MOVL	R9,PSAVE	;SAVE NODE POINTER
	MOVL	R$PMS,R9	;LOAD SUBJECT STRING POINTER
	MOVAB	CFP$F(R9)[R7],R9;POINT TO CURRENT CHARACTER
	ADDL2	4*SCLEN(R10),R7	;COMPUTE NEW CURSOR POSITION
	CMPL	R7,PMSSL	;FAIL IF PAST END OF STRING
	BLEQU	5059$
	JMP	FAILP
5059$:
	MOVL	R7,PSAVC	;SAVE UPDATED CURSOR
	MOVL	4*SCLEN(R10),R6	;GET NUMBER OF CHARS TO COMPARE
	MOVAB	CFP$F(R10),R10	;POINT TO CHARS OF TEST STRING
	CMC	FAILP,FAILP	;COMPARE, FAIL IF NOT EQUAL
	MOVL	PSAVE,R9	;IF ALL MATCHED, RESTORE NODE PTR
	MOVL	PSAVC,R7	;RESTORE UPDATED CURSOR
	JMP	SUCCP		;AND SUCCEED
	.PAGE
;
;      SUCCEED
;
;      SEE SECTION ON COMPOUND PATTERNS FOR DETAILS OF THE
;      STRUCTURE AND ALGORITHMS FOR MATCHING THIS NODE TYPE
;
;      NO PARAMETERS
;
	.ALIGN	WORD
	.WORD	BL$P0
P$SUC::				;P0BLK
	MOVL	R7,-(SP)	;STACK CURSOR
	MOVL	R9,-(SP)	;STACK POINTER TO THIS NODE
	JMP	SUCCP		;SUCCEED MATCHING NULL
	.PAGE
;
;      TAB (INTEGER ARGUMENT)
;
;      PARM1                 INTEGER ARGUMENT
;
	.ALIGN	WORD
	.WORD	BL$P1
P$TAB::				;P1BLK
;
;      EXPRESSION ARGUMENT CASE MERGES HERE
;
PTAB1::	CMPL	R7,4*PARM1(R9)	;FAIL IF TOO FAR ALREADY
	BLEQU	5060$
	JMP	FAILP
5060$:
	MOVL	4*PARM1(R9),R7	;ELSE SET NEW CURSOR POSITION
	CMPL	R7,PMSSL	;SUCCEED IF NOT OFF END
	BGTRU	5061$
	JMP	SUCCP
5061$:
	JMP	FAILP		;ELSE FAIL
	.PAGE
;
;      TAB (EXPRESSION ARGUMENT)
;
;      PARM1                 EXPRESSION POINTER
;
	.ALIGN	WORD
	.WORD	BL$P1
P$TBD::				;P1BLK
	JSB	EVALI		;EVALUATE INTEGER ARGUMENT
	.ADDRESS ERROR_057	;TAB EVALUATED ARGUMENT IS NOT INTEGER
	.ADDRESS ERROR_058	;TAB EVALUATED ARGUMENT IS NEGATIVE OR TOO LARGE
	.ADDRESS FAILP		;FAIL IF EVALUATION FAILS
	.ADDRESS PTAB1		;MERGE WITH NORMAL CASE IF OK
	.PAGE
;
;      ANCHOR MOVEMENT
;
;      NO PARAMETERS (DUMMY NODE)
;
P$UNA::				;ENTRY POINT
	MOVL	R7,R9		;COPY INITIAL PATTERN NODE POINTER
	MOVL	(SP),R7		;GET INITIAL CURSOR
	CMPL	R7,PMSSL	;MATCH FAILS IF AT END OF STRING
	BNEQU	5062$
	JMP	EXFAL
5062$:
	INCL	R7		;ELSE INCREMENT CURSOR
	MOVL	R7,(SP)		;STORE INCREMENTED CURSOR
	MOVL	R9,-(SP)	;RESTACK INITIAL NODE PTR
	MOVL	#NDUNA,-(SP)	;RESTACK UNANCHORED NODE
	MOVL	(R9),R11	;REMATCH FIRST NODE
	JMP	(R11)
	.PAGE
;
;      END OF PATTERN MATCH ROUTINES
;
;      THE FOLLOWING ENTRY POINT MARKS THE END OF THE PATTERN
;      MATCHING ROUTINES AND ALSO THE END OF THE ENTRY POINTS
;      REFERENCED FROM THE FIRST WORD OF BLOCKS IN DYNAMIC STORE
;
	.ALIGN	WORD
	.WORD	BL$$I
P$YYY::				;MARK LAST ENTRY IN PATTERN SECTION
	.PAGE
	.SUBTITLE S P I T B O L -- PREDEFINED SNOBOL4 FUNCTIONS
;
;      THE FOLLOWING SECTION CONTAINS CODING FOR FUNCTIONS
;      WHICH ARE PREDEFINED AND AVAILABLE AT THE SNOBOL LEVEL.
;
;      THESE ROUTINES RECEIVE CONTROL DIRECTLY FROM THE CODE OR
;      INDIRECTLY THROUGH THE O$FNC, O$FNS OR CFUNC ROUTINES.
;      IN BOTH CASES THE CONDITIONS ON ENTRY ARE AS FOLLOWS
;
;      THE ARGUMENTS ARE ON THE STACK. THE NUMBER OF ARGUMENTS
;      HAS BEEN ADJUSTED TO CORRESPOND TO THE SVBLK SVNAR FIELD.
;
;      IN CERTAIN FUNCTIONS THE DIRECT CALL IS NOT PERMITTED
;      AND IN THESE INSTANCES WE ALSO HAVE.
;
;      (WA)                  ACTUAL NUMBER OF ARGUMENTS IN CALL
;
;      CONTROL RETURNS BY PLACING THE FUNCTION RESULT VALUE ON
;      ON THE STACK AND CONTINUING EXECUTION WITH THE NEXT
;      WORD FROM THE GENERATED CODE.
;
;      THE NAMES OF THE ENTRY POINTS OF THESE FUNCTIONS ARE OF
;      THE FORM S$XXX WHERE XXX IS THE THREE LETTER CODE FOR
;      THE SYSTEM VARIABLE NAME. THE FUNCTIONS ARE IN ORDER
;      ALPHABETICALLY BY THEIR ENTRY NAMES.
	.PAGE
;
;      ANY
;
S$ANY::				;ENTRY POINT
	MOVL	#P$ANS,R7	;SET PCODE FOR SINGLE CHAR CASE
	MOVL	#P$ANY,R10	;PCODE FOR MULTI-CHAR CASE
	MOVL	#P$AYD,R8	;PCODE FOR EXPRESSION CASE
	JSB	PATST		;CALL COMMON ROUTINE TO BUILD NODE
	.ADDRESS ERROR_059	;ANY ARGUMENT IS NOT STRING OR EXPRESSION
	JMP	EXIXR		;JUMP FOR NEXT CODE WORD
	.PAGE
;
;      APPLY
;
;      APPLY DOES NOT PERMIT THE DIRECT (FAST) CALL SO THAT
;      WA CONTAINS THE ACTUAL NUMBER OF ARGUMENTS PASSED.
;
S$APP::				;ENTRY POINT
	TSTL	R6		;JUMP IF NO ARGUMENTS
	BEQLU	SAPP3
	DECL	R6		;ELSE GET APPLIED FUNC ARG COUNT
	MOVL	R6,R7		;COPY
	MOVAL	0[R7],R7	;CONVERT TO BYTES
	MOVL	SP,R10		;COPY STACK POINTER
	ADDL2	R7,R10		;POINT TO FUNCTION ARGUMENT ON STACK
	MOVL	(R10),R9	;LOAD FUNCTION PTR (APPLY 1ST ARG)
	TSTL	R6		;JUMP IF NO ARGS FOR APPLIED FUNC
	BEQLU	SAPP2
	MOVL	R6,R7		;ELSE SET COUNTER FOR LOOP
;
;      LOOP TO MOVE ARGUMENTS UP ON STACK
;
SAPP1::	SUBL2	#4,R10		;POINT TO NEXT ARGUMENT
	MOVL	(R10),4*1(R10)	;MOVE ARGUMENT UP
	SOBGTR	R7,SAPP1	;LOOP TILL ALL MOVED
;
;      MERGE HERE TO CALL FUNCTION (WA = NUMBER OF ARGUMENTS)
;
SAPP2::	ADDL2	#4,SP		;ADJUST STACK PTR FOR APPLY 1ST ARG
	JSB	GTNVR		;GET VARIABLE BLOCK ADDR FOR FUNC
	.ADDRESS SAPP3		;JUMP IF NOT NATURAL VARIABLE
	MOVL	4*VRFNC(R9),R10	;ELSE POINT TO FUNCTION BLOCK
	JMP	CFUNC		;GO CALL APPLIED FUNCTION
;
;      HERE FOR INVALID FIRST ARGUMENT
;
SAPP3::	JMP	ERROR_060	;APPLY FIRST ARG IS NOT NATURAL VARIABLE NAME
	.PAGE
;
;      ARBNO
;
;      ARBNO BUILDS A COMPOUND PATTERN. SEE DESCRIPTION AT
;      START OF PATTERN MATCHING SECTION FOR STRUCTURE FORMED.
;
S$ABN::				;ENTRY POINT
	CLRL	R9		;SET PARM1 = 0 FOR THE MOMENT
	MOVL	#P$ALT,R7	;SET PCODE FOR ALTERNATIVE NODE
	JSB	PBILD		;BUILD ALTERNATIVE NODE
	MOVL	R9,R10		;SAVE PTR TO ALTERNATIVE PATTERN
	MOVL	#P$ABC,R7	;PCODE FOR P$ABC
	CLRL	R9		;P0BLK
	JSB	PBILD		;BUILD P$ABC NODE
	MOVL	R10,4*PTHEN(R9)	;PUT ALTERNATIVE NODE AS SUCCESSOR
	MOVL	R10,R6		;REMEMBER ALTERNATIVE NODE POINTER
	MOVL	R9,R10		;COPY P$ABC NODE PTR
	MOVL	(SP),R9		;LOAD ARBNO ARGUMENT
	MOVL	R6,(SP)		;STACK ALTERNATIVE NODE POINTER
	JSB	GTPAT		;GET ARBNO ARGUMENT AS PATTERN
	.ADDRESS ERROR_061	;ARBNO ARGUMENT IS NOT PATTERN
	JSB	PCONC		;CONCAT ARG WITH P$ABC NODE
	MOVL	R9,R10		;REMEMBER PTR TO CONCD PATTERNS
	MOVL	#P$ABA,R7	;PCODE FOR P$ABA
	CLRL	R9		;P0BLK
	JSB	PBILD		;BUILD P$ABA NODE
	MOVL	R10,4*PTHEN(R9)	;CONCATENATE NODES
	MOVL	(SP),R10	;RECALL PTR TO ALTERNATIVE NODE
	MOVL	R9,4*PARM1(R10)	;POINT ALTERNATIVE BACK TO ARGUMENT
	JMP	EXITS		;JUMP FOR NEXT CODE WORD
	.PAGE
;
;      ARG
;
S$ARG::				;ENTRY POINT
	JSB	GTSMI		;GET SECOND ARG AS SMALL INTEGER
	.ADDRESS ERROR_062	;ARG SECOND ARGUMENT IS NOT INTEGER
	.ADDRESS EXFAL		;FAIL IF OUT OF RANGE OR NEGATIVE
	MOVL	R9,R6		;SAVE ARGUMENT NUMBER
	MOVL	(SP)+,R9	;LOAD FIRST ARGUMENT
	JSB	GTNVR		;LOCATE VRBLK
	.ADDRESS SARG1		;JUMP IF NOT NATURAL VARIABLE
	MOVL	4*VRFNC(R9),R9	;ELSE LOAD FUNCTION BLOCK POINTER
	CMPL	(R9),#B$PFC	;JUMP IF NOT PROGRAM DEFINED
	BNEQU	SARG1
	TSTL	R6		;FAIL IF ARG NUMBER IS ZERO
	BNEQU	5063$
	JMP	EXFAL
5063$:
	CMPL	R6,4*FARGS(R9)	;FAIL IF ARG NUMBER IS TOO LARGE
	BLEQU	5064$
	JMP	EXFAL
5064$:
	MOVAL	0[R6],R6	;ELSE CONVERT TO BYTE OFFSET
	ADDL2	R6,R9		;POINT TO ARGUMENT SELECTED
	MOVL	4*PFAGB(R9),R9	;LOAD ARGUMENT VRBLK POINTER
	JMP	EXVNM		;EXIT TO BUILD NMBLK
;
;      HERE IF 1ST ARGUMENT IS BAD
;
SARG1::	JMP	ERROR_063	;ARG FIRST ARGUMENT IS NOT PROGRAM FUNCTION NAME
	.PAGE
;
;      ARRAY
;
S$ARR::				;ENTRY POINT
	MOVL	(SP)+,R10	;LOAD INITIAL ELEMENT VALUE
	MOVL	(SP)+,R9	;LOAD FIRST ARGUMENT
	JSB	GTINT		;CONVERT FIRST ARG TO INTEGER
	.ADDRESS SAR02		;JUMP IF NOT INTEGER
;
;      HERE FOR INTEGER FIRST ARGUMENT, BUILD VCBLK
;
	MOVL	4*ICVAL(R9),R5	;LOAD INTEGER VALUE
	BGTR	5065$
	JMP	SAR10
5065$:
	MFI	R6,SAR11	;ELSE CONVERT TO ONE WORD, TEST OVFL
	MOVL	R6,R7		;COPY ELEMENTS FOR LOOP LATER ON
	ADDL2	#VCSI$,R6	;ADD SPACE FOR STANDARD FIELDS
	MOVAL	0[R6],R6	;CONVERT LENGTH TO BYTES
	CMPL	R6,MXLEN	;FAIL IF TOO LARGE
	BLSSU	5066$
	JMP	SAR11
5066$:
	JSB	ALLOC		;ALLOCATE SPACE FOR VCBLK
	MOVL	#B$VCT,(R9)	;STORE TYPE WORD
	MOVL	R6,4*VCLEN(R9)	;SET LENGTH
	MOVL	R10,R8		;COPY DEFAULT VALUE
	MOVL	R9,R10		;COPY VCBLK POINTER
	ADDL2	#4*VCVLS,R10	;POINT TO FIRST ELEMENT VALUE
;
;      LOOP TO SET VECTOR ELEMENTS TO DEFAULT VALUE
;
SAR01::	MOVL	R8,(R10)+	;STORE ONE VALUE
	SOBGTR	R7,SAR01	;LOOP TILL ALL STORED
	JMP	EXSID		;EXIT SETTING IDVAL
	.PAGE
;
;      ARRAY (CONTINUED)
;
;      HERE IF FIRST ARGUMENT IS NOT AN INTEGER
;
SAR02::	MOVL	R9,-(SP)	;REPLACE ARGUMENT ON STACK
	JSB	XSCNI		;INITIALIZE SCAN OF FIRST ARGUMENT
	.ADDRESS ERROR_064	;ARRAY FIRST ARGUMENT IS NOT INTEGER OR STRING
	.ADDRESS EXNUL		;DUMMY (UNUSED) NULL STRING EXIT
	MOVL	R$XSC,-(SP)	;SAVE PROTOTYPE POINTER
	MOVL	R10,-(SP)	;SAVE DEFAULT VALUE
	CLRL	ARCDM		;ZERO COUNT OF DIMENSIONS
	CLRL	ARPTR		;ZERO OFFSET TO INDICATE PASS ONE
	MOVL	INTV1,R5	;LOAD INTEGER ONE
	MOVL	R5,ARNEL	;INITIALIZE ELEMENT COUNT
;
;      THE FOLLOWING CODE IS EXECUTED TWICE. THE FIRST TIME
;      (ARPTR EQ 0), IT IS USED TO COUNT THE NUMBER OF ELEMENTS
;      AND NUMBER OF DIMENSIONS. THE SECOND TIME (ARPTR GT 0) IS
;      USED TO ACTUALLY FILL IN THE DIM,LBD FIELDS OF THE ARBLK.
;
SAR03::	MOVL	INTV1,R5	;LOAD ONE AS DEFAULT LOW BOUND
	MOVL	R5,ARSVL	;SAVE AS LOW BOUND
	MOVL	#CH$CL,R8	;SET DELIMITER ONE = COLON
	MOVL	#CH$CM,R10	;SET DELIMITER TWO = COMMA
	JSB	XSCAN		;SCAN NEXT BOUND
	CMPL	R6,#NUM01	;JUMP IF NOT COLON
	BNEQU	SAR04
;
;      HERE WE HAVE A COLON ENDING A LOW BOUND
;
	JSB	GTINT		;CONVERT LOW BOUND
	.ADDRESS ERROR_065	;ARRAY FIRST ARGUMENT LOWER BOUND IS NOT INTEGER
	MOVL	4*ICVAL(R9),R5	;LOAD VALUE OF LOW BOUND
	MOVL	R5,ARSVL	;STORE LOW BOUND VALUE
	MOVL	#CH$CM,R8	;SET DELIMITER ONE = COMMA
	MOVL	R8,R10		;AND DELIMITER TWO = COMMA
	JSB	XSCAN		;SCAN HIGH BOUND
	.PAGE
;
;      ARRAY (CONTINUED)
;
;      MERGE HERE TO PROCESS UPPER BOUND
;
SAR04::	JSB	GTINT		;CONVERT HIGH BOUND TO INTEGER
	.ADDRESS ERROR_066	;ARRAY FIRST ARGUMENT UPPER BOUND IS NOT INTEGER
	MOVL	4*ICVAL(R9),R5	;GET HIGH BOUND
	SUBL2	ARSVL,R5	;SUBTRACT LOWER BOUND
	BVC	5067$
	JMP	SAR10
5067$:
	TSTL	R5		;BAD DIMENSION IF NEGATIVE
	BGEQ	5068$
	JMP	SAR10
5068$:
	ADDL2	INTV1,R5	;ADD 1 TO GET DIMENSION
	BVC	5069$
	JMP	SAR10
5069$:
	MOVL	ARPTR,R10	;LOAD OFFSET (ALSO PASS INDICATOR)
	BEQLU	SAR05
;
;      HERE IN SECOND PASS TO STORE LBD AND DIM IN ARBLK
;
	ADDL2	(SP),R10	;POINT TO CURRENT LOCATION IN ARBLK
	MOVL	R5,4*CFP$I(R10)	;STORE DIMENSION
	MOVL	ARSVL,R5	;LOAD LOW BOUND
	MOVL	R5,(R10)	;STORE LOW BOUND
	ADDL2	#4*ARDMS,ARPTR	;BUMP OFFSET TO NEXT BOUNDS
	JMP	SAR06		;JUMP TO CHECK FOR END OF BOUNDS
;
;      HERE IN PASS 1
;
SAR05::	INCL	ARCDM		;BUMP DIMENSION COUNT
	MULL2	ARNEL,R5	;MULTIPLY DIMENSION BY COUNT SO FAR
	BVC	5070$
	JMP	SAR11
5070$:
	MOVL	R5,ARNEL	;ELSE STORE UPDATED ELEMENT COUNT
;
;      MERGE HERE AFTER PROCESSING ONE SET OF BOUNDS
;
SAR06::	TSTL	R6		;LOOP BACK UNLESS END OF BOUNDS
	BEQLU	5071$
	JMP	SAR03
5071$:
	TSTL	ARPTR		;JUMP IF END OF PASS 2
	BEQLU	5072$
	JMP	SAR09
5072$:
	.PAGE
;
;      ARRAY (CONTINUED)
;
;      HERE AT END OF PASS ONE, BUILD ARBLK
;
	MOVL	ARNEL,R5	;GET NUMBER OF ELEMENTS
	MFI	R7,SAR11	;GET AS ADDR INTEGER, TEST OVFLO
	MOVAL	0[R7],R7	;ELSE CONVERT TO LENGTH IN BYTES
	MOVL	#4*ARSI$,R6	;SET SIZE OF STANDARD FIELDS
	MOVL	ARCDM,R8	;SET DIMENSION COUNT TO CONTROL LOOP
;
;      LOOP TO ALLOW SPACE FOR DIMENSIONS
;
SAR07::	ADDL2	#4*ARDMS,R6	;ALLOW SPACE FOR ONE SET OF BOUNDS
	SOBGTR	R8,SAR07	;LOOP BACK TILL ALL ACCOUNTED FOR
	MOVL	R6,R10		;SAVE SIZE (=AROFS)
;
;      NOW ALLOCATE SPACE FOR ARBLK
;
	ADDL2	R7,R6		;ADD SPACE FOR ELEMENTS
	ADDL2	#4,R6		;ALLOW FOR ARPRO PROTOTYPE FIELD
	CMPL	R6,MXLEN	;FAIL IF TOO LARGE
	BLSSU	5073$
	JMP	SAR11
5073$:
	JSB	ALLOC		;ELSE ALLOCATE ARBLK
	MOVL	(SP),R7		;LOAD DEFAULT VALUE
	MOVL	R9,(SP)		;SAVE ARBLK POINTER
	MOVL	R6,R8		;SAVE LENGTH IN BYTES
	ASHL	#-2,R6,R6	;CONVERT LENGTH BACK TO WORDS
				;SET COUNTER TO CONTROL LOOP
;
;      LOOP TO CLEAR ENTIRE ARBLK TO DEFAULT VALUE
;
SAR08::	MOVL	R7,(R9)+	;SET ONE WORD
	SOBGTR	R6,SAR08	;LOOP TILL ALL SET
	.PAGE
;
;      ARRAY (CONTINUED)
;
;      NOW SET INITIAL FIELDS OF ARBLK
;
	MOVL	(SP)+,R9	;RELOAD ARBLK POINTER
	MOVL	(SP),R7		;LOAD PROTOTYPE
	MOVL	#B$ART,(R9)	;SET TYPE WORD
	MOVL	R8,4*ARLEN(R9)	;STORE LENGTH IN BYTES
	CLRL	4*IDVAL(R9)	;ZERO ID TILL WE GET IT BUILT
	MOVL	R10,4*AROFS(R9)	;SET PROTOTYPE FIELD PTR
	MOVL	ARCDM,4*ARNDM(R9);SET NUMBER OF DIMENSIONS
	MOVL	R9,R8		;SAVE ARBLK POINTER
	ADDL2	R10,R9		;POINT TO PROTOTYPE FIELD
	MOVL	R7,(R9)		;STORE PROTOTYPE PTR IN ARBLK
	MOVL	#4*ARLBD,ARPTR	;SET OFFSET FOR PASS 2 BOUNDS SCAN
	MOVL	R7,R$XSC	;RESET STRING POINTER FOR XSCAN
	MOVL	R8,(SP)		;STORE ARBLK POINTER ON STACK
	CLRL	XSOFS		;RESET OFFSET PTR TO START OF STRING
	JMP	SAR03		;JUMP BACK TO RESCAN BOUNDS
;
;      HERE AFTER FILLING IN BOUNDS INFORMATION (END PASS TWO)
;
SAR09::	MOVL	(SP)+,R9	;RELOAD POINTER TO ARBLK
	JMP	EXSID		;EXIT SETTING IDVAL
;
;      HERE FOR BAD DIMENSION
;
SAR10::	JMP	ERROR_067	;ARRAY DIMENSION IS ZERO,NEGATIVE OR OUT OF RANGE
;
;      HERE IF ARRAY IS TOO LARGE
;
SAR11::	JMP	ERROR_068	;ARRAY SIZE EXCEEDS MAXIMUM PERMITTED
	.PAGE
;
;      BREAK
;
S$BRK::				;ENTRY POINT
	MOVL	#P$BKS,R7	;SET PCODE FOR SINGLE CHAR CASE
	MOVL	#P$BRK,R10	;PCODE FOR MULTI-CHAR CASE
	MOVL	#P$BKD,R8	;PCODE FOR EXPRESSION CASE
	JSB	PATST		;CALL COMMON ROUTINE TO BUILD NODE
	.ADDRESS ERROR_069	;BREAK ARGUMENT IS NOT STRING OR EXPRESSION
	JMP	EXIXR		;JUMP FOR NEXT CODE WORD
	.PAGE
;
;      BREAKX
;
;      BREAKX IS A COMPOUND PATTERN. SEE DESCRIPTION AT START
;      OF PATTERN MATCHING SECTION FOR STRUCTURE FORMED.
;
S$BKX::				;ENTRY POINT
	MOVL	#P$BKS,R7	;PCODE FOR SINGLE CHAR ARGUMENT
	MOVL	#P$BRK,R10	;PCODE FOR MULTI-CHAR ARGUMENT
	MOVL	#P$BXD,R8	;PCODE FOR EXPRESSION CASE
	JSB	PATST		;CALL COMMON ROUTINE TO BUILD NODE
	.ADDRESS ERROR_070	;BREAKX ARGUMENT IS NOT STRING OR EXPRESSION
;
;      NOW HOOK BREAKX NODE ON AT FRONT END
;
	MOVL	R9,-(SP)	;SAVE PTR TO BREAK NODE
	MOVL	#P$BKX,R7	;SET PCODE FOR BREAKX NODE
	JSB	PBILD		;BUILD IT
	MOVL	(SP),4*PTHEN(R9);SET BREAK NODE AS SUCCESSOR
	MOVL	#P$ALT,R7	;SET PCODE FOR ALTERNATION NODE
	JSB	PBILD		;BUILD (PARM1=ALT=BREAKX NODE)
	MOVL	R9,R6		;SAVE PTR TO ALTERNATION NODE
	MOVL	(SP),R9		;POINT TO BREAK NODE
	MOVL	R6,4*PTHEN(R9)	;SET ALTERNATE NODE AS SUCCESSOR
	JMP	EXITS		;EXIT WITH RESULT ON STACK
	.PAGE
;
;      CLEAR
;
S$CLR::				;ENTRY POINT
	JSB	XSCNI		;INITIALIZE TO SCAN ARGUMENT
	.ADDRESS ERROR_071	;CLEAR ARGUMENT IS NOT STRING
	.ADDRESS SCLR2		;JUMP IF NULL
;
;      LOOP TO SCAN OUT NAMES IN FIRST ARGUMENT. VARIABLES IN
;      THE LIST ARE FALGGED BY SETTING VRGET OF VRBLK TO ZERO.
;
SCLR1::	MOVL	#CH$CM,R8	;SET DELIMITER ONE = COMMA
	MOVL	R8,R10		;DELIMITER TWO = COMMA
	JSB	XSCAN		;SCAN NEXT VARIABLE NAME
	JSB	GTNVR		;LOCATE VRBLK
	.ADDRESS ERROR_072	;CLEAR ARGUMENT HAS NULL VARIABLE NAME
	CLRL	4*VRGET(R9)	;ELSE FLAG BY ZEROING VRGET FIELD
	TSTL	R6		;LOOP BACK IF STOPPED BY COMMA
	BNEQU	SCLR1
;
;      HERE AFTER FLAGGING VARIABLES IN ARGUMENT LIST
;
SCLR2::	MOVL	HSHTB,R7	;POINT TO START OF HASH TABLE
;
;      LOOP THROUGH SLOTS IN HASH TABLE
;
SCLR3::	CMPL	R7,HSHTE	;EXIT RETURNING NULL IF NONE LEFT
	BNEQU	5074$
	JMP	EXNUL
5074$:
	MOVL	R7,R9		;ELSE COPY SLOT POINTER
	ADDL2	#4,R7		;BUMP SLOT POINTER
	SUBL2	#4*VRNXT,R9	;SET OFFSET TO MERGE INTO LOOP
;
;      LOOP THROUGH VRBLKS ON ONE HASH CHAIN
;
SCLR4::	MOVL	4*VRNXT(R9),R9	;POINT TO NEXT VRBLK ON CHAIN
	BEQLU	SCLR3
	TSTL	4*VRGET(R9)	;JUMP IF NOT FLAGGED
	BNEQU	SCLR5
	.PAGE
;
;      CLEAR (CONTINUED)
;
;      HERE FOR FLAGGED VARIABLE, DO NOT SET VALUE TO NULL
;
	JSB	SETVR		;FOR FLAGGED VAR, RESTORE VRGET
	JMP	SCLR4		;AND LOOP BACK FOR NEXT VRBLK
;
;      HERE TO SET VALUE OF A VARIABLE TO NULL
;
SCLR5::	MOVL	R9,R10		;COPY VRBLK POINTER
;
;      LOOP TO LOCATE VALUE AT END OF POSSIBLE TRBLK CHAIN
;
SCLR6::	MOVL	R10,R6		;SAVE BLOCK POINTER
	MOVL	4*VRVAL(R10),R10;LOAD NEXT VALUE FIELD
	CMPL	(R10),#B$TRT	;LOOP BACK IF TRAPPED
	BEQLU	SCLR6
;
;      NOW STORE THE NULL VALUE
;
	MOVL	R6,R10		;RESTORE BLOCK POINTER
	MOVL	#NULLS,4*VRVAL(R10) ;STORE NULL CONSTANT VALUE
	JMP	SCLR4		;LOOP BACK FOR NEXT VRBLK
	.PAGE
;
;      CODE
;
S$COD::				;ENTRY POINT
	MOVL	(SP)+,R9	;LOAD ARGUMENT
	JSB	GTCOD		;CONVERT TO CODE
	.ADDRESS EXFAL		;FAIL IF CONVERSION IS IMPOSSIBLE
	JMP	EXIXR		;ELSE RETURN CODE AS RESULT
	.PAGE
;
;      COLLECT
;
S$COL::				;ENTRY POINT
	MOVL	(SP)+,R9	;LOAD ARGUMENT
	JSB	GTINT		;CONVERT TO INTEGER
	.ADDRESS ERROR_073	;COLLECT ARGUMENT IS NOT INTEGER
	MOVL	4*ICVAL(R9),R5	;LOAD COLLECT ARGUMENT
	MOVL	R5,CLSVI	;SAVE COLLECT ARGUMENT
	CLRL	R7		;SET NO MOVE UP
	JSB	GBCOL		;PERFORM GARBAGE COLLECTION
	MOVL	DNAME,R6	;POINT TO END OF MEMORY
	SUBL2	DNAMP,R6	;SUBTRACT NEXT LOCATION
	ASHL	#-2,R6,R6	;CONVERT BYTES TO WORDS
	MOVL	R6,R5		;CONVERT WORDS AVAILABLE AS INTEGER
	SUBL2	CLSVI,R5	;SUBTRACT ARGUMENT
	BVC	5075$
	JMP	EXFAL
5075$:
	TSTL	R5		;FAIL IF NOT ENOUGH
	BGEQ	5076$
	JMP	EXFAL
5076$:
	ADDL2	CLSVI,R5	;ELSE RECOMPUTE AVAILABLE
	JMP	EXINT		;AND EXIT WITH INTEGER RESULT
	.PAGE
;
;      CONVERT
;
S$CNV::				;ENTRY POINT
	JSB	GTSTG		;CONVERT SECOND ARGUMENT TO STRING
	.ADDRESS ERROR_074	;CONVERT SECOND ARGUMENT IS NOT STRING
	MOVL	(SP),R10	;LOAD FIRST ARGUMENT
	CMPL	(R10),#B$PDT	;JUMP IF NOT PROGRAM DEFINED
	BNEQU	SCV01
;
;      HERE FOR PROGRAM DEFINED DATATYPE
;
	MOVL	4*PDDFP(R10),R10;POINT TO DFBLK
	MOVL	4*DFNAM(R10),R10;LOAD DATATYPE NAME
	JSB	IDENT		;COMPARE WITH SECOND ARG
	.ADDRESS EXITS		;EXIT IF IDENT WITH ARG AS RESULT
	JMP	EXFAL		;ELSE FAIL
;
;      HERE IF NOT PROGRAM DEFINED DATATYPE
;
SCV01::	MOVL	R9,-(SP)	;SAVE STRING ARGUMENT
	MOVL	#SVCTB,R10	;POINT TO TABLE OF NAMES TO COMPARE
	CLRL	R7		;INITIALIZE COUNTER
	MOVL	R6,R8		;SAVE LENGTH OF ARGUMENT STRING
;
;      LOOP THROUGH TABLE ENTRIES
;
SCV02::	MOVL	(R10)+,R9	;LOAD NEXT TABLE ENTRY, BUMP POINTER
	BNEQU	5077$
	JMP	EXFAL
5077$:
	CMPL	R8,4*SCLEN(R9)	;JUMP IF WRONG LENGTH
	BEQLU	5078$
	JMP	SCV05
5078$:
	MOVL	R10,CNVTP	;ELSE STORE TABLE POINTER
	MOVAB	CFP$F(R9),R9	;POINT TO CHARS OF TABLE ENTRY
	MOVL	(SP),R10	;LOAD POINTER TO STRING ARGUMENT
	MOVAB	CFP$F(R10),R10	;POINT TO CHARS OF STRING ARG
	MOVL	R8,R6		;SET NUMBER OF CHARS TO COMPARE
	CMC	SCV04,SCV04	;COMPARE, JUMP IF NO MATCH
	.PAGE
;
;      CONVERT (CONTINUED)
;
;      HERE WE HAVE A MATCH
;
SCV03::	MOVL	R7,R10		;COPY ENTRY NUMBER
	ADDL2	#4,SP		;POP STRING ARG OFF STACK
	MOVL	(SP)+,R9	;LOAD FIRST ARGUMENT
	.IF NOT_EQUAL CNRA
	BSW	R10,9		;JUMP TO APPROPRIATE ROUTINE
	.IF_FALSE
	BSW	R10,10		;JUMP TO APPROPRIATE ROUTINE
	.ENDC
	IFF	0,SCV06		;STRING
	IFF	1,SCV07		;INTEGER
	IFF	2,SCV09		;NAME
	IFF	3,SCV10		;PATTERN
	IFF	4,SCV11		;ARRAY
	IFF	5,SCV19		;TABLE
	IFF	6,SCV25		;EXPRESSION
	IFF	7,SCV26		;CODE
	IFF	8,SCV27		;NUMERIC
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	IFF	9,SCV08		;REAL
	.ENDC
	ESW			;END OF SWITCH TABLE
;
;      HERE IF NO MATCH WITH TABLE ENTRY
;
SCV04::	MOVL	CNVTP,R10	;RESTORE TABLE POINTER, MERGE
;
;      MERGE HERE IF LENGTHS DID NOT MATCH
;
SCV05::	INCL	R7		;BUMP ENTRY NUMBER
	JMP	SCV02		;LOOP BACK TO CHECK NEXT ENTRY
;
;      HERE TO CONVERT TO STRING
;
SCV06::	MOVL	R9,-(SP)	;REPLACE STRING ARGUMENT ON STACK
	JSB	GTSTG		;CONVERT TO STRING
	.ADDRESS EXFAL		;FAIL IF CONVERSION NOT POSSIBLE
	JMP	EXIXR		;ELSE RETURN STRING
	.PAGE
;
;      CONVERT (CONTINUED)
;
;      HERE TO CONVERT TO INTEGER
;
SCV07::	JSB	GTINT		;CONVERT TO INTEGER
	.ADDRESS EXFAL		;FAIL IF CONVERSION NOT POSSIBLE
	JMP	EXIXR		;ELSE RETURN INTEGER
	.IF NOT_EQUAL CNRA
	.IF_FALSE
;
;      HERE TO CONVERT TO REAL
;
SCV08::	JSB	GTREA		;CONVERT TO REAL
	.ADDRESS EXFAL		;FAIL IF CONVERSION NOT POSSIBLE
	JMP	EXIXR		;ELSE RETURN REAL
	.ENDC
;
;      HERE TO CONVERT TO NAME
;
SCV09::	CMPL	(R9),#B$NML	;RETURN IF ALREADY A NAME
	BNEQU	5079$
	JMP	EXIXR
5079$:
	JSB	GTNVR		;ELSE TRY STRING TO NAME CONVERT
	.ADDRESS EXFAL		;FAIL IF CONVERSION NOT POSSIBLE
	JMP	EXVNM		;ELSE EXIT BUILDING NMBLK FOR VRBLK
;
;      HERE TO CONVERT TO PATTERN
;
SCV10::	JSB	GTPAT		;CONVERT TO PATTERN
	.ADDRESS EXFAL		;FAIL IF CONVERSION NOT POSSIBLE
	JMP	EXIXR		;ELSE RETURN PATTERN
;
;      CONVERT TO ARRAY
;
SCV11::	JSB	GTARR		;GET AN ARRAY
	.ADDRESS EXFAL		;FAIL IF NOT CONVERTIBLE
	JMP	EXSID		;EXIT SETTING ID FIELD
;
;      CONVERT TO TABLE
;
SCV19::	MOVL	(R9),R6		;LOAD FIRST WORD OF BLOCK
	MOVL	R9,-(SP)	;REPLACE ARBLK POINTER ON STACK
	CMPL	R6,#B$TBT	;RETURN ARG IF ALREADY A TABLE
	BNEQU	5080$
	JMP	EXITS
5080$:
	CMPL	R6,#B$ART	;ELSE FAIL IF NOT AN ARRAY
	BEQLU	5081$
	JMP	EXFAL
5081$:
	.PAGE
;
;      CONVERT (CONTINUED)
;
;      HERE TO CONVERT AN ARRAY TO TABLE
;
	CMPL	4*ARNDM(R9),#NUM02 ;FAIL IF NOT 2-DIM ARRAY
	BEQLU	5082$
	JMP	EXFAL
5082$:
	MOVL	4*ARDM2(R9),R5	;LOAD DIM 2
	SUBL2	INTV2,R5	;SUBTRACT 2 TO COMPARE
	TSTL	R5		;FAIL IF DIM2 NOT 2
	BEQL	5083$
	JMP	EXFAL
5083$:
;
;      HERE WE HAVE AN ARBLK OF THE RIGHT SHAPE
;
	MOVL	4*ARDIM(R9),R5	;LOAD DIM 1 (NUMBER OF ELEMENTS)
	MFI	R6		;GET AS ONE WORD INTEGER
	MOVL	R6,R7		;COPY TO CONTROL LOOP
	ADDL2	#TBSI$,R6	;ADD SPACE FOR STANDARD FIELDS
	MOVAL	0[R6],R6	;CONVERT LENGTH TO BYTES
	JSB	ALLOC		;ALLOCATE SPACE FOR TBBLK
	MOVL	R9,R8		;COPY TBBLK POINTER
	MOVL	R9,-(SP)	;SAVE TBBLK POINTER
	MOVL	#B$TBT,(R9)+	;STORE TYPE WORD
	CLRL	(R9)+		;STORE ZERO FOR IDVAL FOR NOW
	MOVL	R6,(R9)+	;STORE LENGTH
	MOVL	#NULLS,(R9)+	;NULL INITIAL LOOKUP VALUE
;
;      LOOP TO INITIALIZE BUCKET PTRS TO POINT TO TABLE
;
SCV20::	MOVL	R8,(R9)+	;SET BUCKET PTR TO POINT TO TBBLK
	SOBGTR	R7,SCV20	;LOOP TILL ALL INITIALIZED
	MOVL	#4*ARVL2,R7	;SET OFFSET TO FIRST ARBLK ELEMENT
;
;      LOOP TO COPY ELEMENTS FROM ARRAY TO TABLE
;
SCV21::	MOVL	4*1(SP),R10	;POINT TO ARBLK
	CMPL	R7,4*ARLEN(R10)	;JUMP IF ALL MOVED
	BEQLU	SCV24
	ADDL2	R7,R10		;ELSE POINT TO CURRENT LOCATION
	ADDL2	#4*NUM02,R7	;BUMP OFFSET
	MOVL	(R10),R9	;LOAD SUBSCRIPT NAME
	SUBL2	#4,R10		;ADJUST PTR TO MERGE (TRVAL=1+1)
	.PAGE
;
;      CONVERT (CONTINUED)
;
;      LOOP TO CHASE DOWN TRBLK CHAIN FOR VALUE
;
SCV22::	MOVL	4*TRVAL(R10),R10;POINT TO NEXT VALUE
	CMPL	(R10),#B$TRT	;LOOP BACK IF TRAPPED
	BEQLU	SCV22
;
;      HERE WITH NAME IN XR, VALUE IN XL
;
SCV23::	MOVL	R10,-(SP)	;STACK VALUE
	MOVL	4*1(SP),R10	;LOAD TBBLK POINTER
	JSB	TFIND		;BUILD TEBLK (NOTE WB GT 0 BY NAME)
	.ADDRESS EXFAL		;FAIL IF ACESS FAILS
	MOVL	(SP)+,4*TEVAL(R10) ;STORE VALUE IN TEBLK
	JMP	SCV21		;LOOP BACK FOR NEXT ELEMENT
;
;      HERE AFTER MOVING ALL ELEMENTS TO TBBLK
;
SCV24::	MOVL	(SP)+,R9	;LOAD TBBLK POINTER
	ADDL2	#4,SP		;POP ARBLK POINTER
	JMP	EXSID		;EXIT SETTING IDVAL
;
;      CONVERT TO EXPRESSION
;
SCV25::	JSB	GTEXP		;CONVERT TO EXPRESSION
	.ADDRESS EXFAL		;FAIL IF CONVERSION NOT POSSIBLE
	JMP	EXIXR		;ELSE RETURN EXPRESSION
;
;      CONVERT TO CODE
;
SCV26::	JSB	GTCOD		;CONVERT TO CODE
	.ADDRESS EXFAL		;FAIL IF CONVERSION IS NOT POSSIBLE
	JMP	EXIXR		;ELSE RETURN CODE
;
;      CONVERT TO NUMERIC
;
SCV27::	JSB	GTNUM		;CONVERT TO NUMERIC
	.ADDRESS EXFAL		;FAIL IF UNCONVERTIBLE
	JMP	EXIXR		;RETURN NUMBER
	.PAGE
;
;      COPY
;
S$COP::				;ENTRY POINT
	JSB	COPYB		;COPY THE BLOCK
	.ADDRESS EXITS		;RETURN IF NO IDVAL FIELD
	JMP	EXSID		;EXIT SETTING ID VALUE
	.PAGE
;
;      DATA
;
S$DAT::				;ENTRY POINT
	JSB	XSCNI		;PREPARE TO SCAN ARGUMENT
	.ADDRESS ERROR_075	;DATA ARGUMENT IS NOT STRING
	.ADDRESS ERROR_076	;DATA ARGUMENT IS NULL
;
;      SCAN OUT DATATYPE NAME
;
	MOVL	#CH$PP,R8	;DELIMITER ONE = LEFT PAREN
	MOVL	R8,R10		;DELIMITER TWO = LEFT PAREN
	JSB	XSCAN		;SCAN DATATYPE NAME
	TSTL	R6		;SKIP IF LEFT PAREN FOUND
	BNEQU	SDAT1
	JMP	ERROR_077	;DATA ARGUMENT IS MISSING A LEFT PAREN
;
;      HERE AFTER SCANNING DATATYPE NAME
;
SDAT1::	MOVL	R9,R10		;SAVE NAME PTR
	MOVL	4*SCLEN(R9),R6	;GET LENGTH
	MOVAB	3+<4*SCSI$>(R6),R6 ;COMPUTE SPACE NEEDED
	BICL2	#3,R6
	JSB	ALOST		;REQUEST STATIC STORE FOR NAME
	MOVL	R9,-(SP)	;SAVE DATATYPE NAME
	MVW			;COPY NAME TO STATIC
	MOVL	(SP),R9		;GET NAME PTR
	CLRL	R10		;SCRUB DUD REGISTER
	JSB	GTNVR		;LOCATE VRBLK FOR DATATYPE NAME
	.ADDRESS ERROR_078	;DATA ARGUMENT HAS NULL DATATYPE NAME
	MOVL	R9,DATDV	;SAVE VRBLK POINTER FOR DATATYPE
	MOVL	SP,DATXS	;STORE STARTING STACK VALUE
	CLRL	R7		;ZERO COUNT OF FIELD NAMES
;
;      LOOP TO SCAN FIELD NAMES AND STACK VRBLK POINTERS
;
SDAT2::	MOVL	#CH$RP,R8	;DELIMITER ONE = RIGHT PAREN
	MOVL	#CH$CM,R10	;DELIMITER TWO = COMMA
	JSB	XSCAN		;SCAN NEXT FIELD NAME
	TSTL	R6		;JUMP IF DELIMITER FOUND
	BNEQU	SDAT3
	JMP	ERROR_079	;DATA ARGUMENT IS MISSING A RIGHT PAREN
;
;      HERE AFTER SCANNING OUT ONE FIELD NAME
;
SDAT3::	JSB	GTNVR		;LOCATE VRBLK FOR FIELD NAME
	.ADDRESS ERROR_080	;DATA ARGUMENT HAS NULL FIELD NAME
	MOVL	R9,-(SP)	;STACK VRBLK POINTER
	INCL	R7		;INCREMENT COUNTER
	CMPL	R6,#NUM02	;LOOP BACK IF STOPPED BY COMMA
	BEQLU	SDAT2
	.PAGE
;
;      DATA (CONTINUED)
;
;      NOW BUILD THE DFBLK
;
	MOVL	#DFSI$,R6	;SET SIZE OF DFBLK STANDARD FIELDS
	ADDL2	R7,R6		;ADD NUMBER OF FIELDS
	MOVAL	0[R6],R6	;CONVERT LENGTH TO BYTES
	MOVL	R7,R8		;PRESERVE NO. OF FIELDS
	JSB	ALOST		;ALLOCATE SPACE FOR DFBLK
	MOVL	R8,R7		;GET NO OF FIELDS
	MOVL	DATXS,R10	;POINT TO START OF STACK
	MOVL	(R10),R8	;LOAD DATATYPE NAME
	MOVL	R9,(R10)	;SAVE DFBLK POINTER ON STACK
	MOVL	#B$DFC,(R9)+	;STORE TYPE WORD
	MOVL	R7,(R9)+	;STORE NUMBER OF FIELDS (FARGS)
	MOVL	R6,(R9)+	;STORE LENGTH (DFLEN)
	SUBL2	#4*PDDFS,R6	;COMPUTE PDBLK LENGTH (FOR DFPDL)
	MOVL	R6,(R9)+	;STORE PDBLK LENGTH (DFPDL)
	MOVL	R8,(R9)+	;STORE DATATYPE NAME (DFNAM)
	MOVL	R7,R8		;COPY NUMBER OF FIELDS
;
;      LOOP TO MOVE FIELD NAME VRBLK POINTERS TO DFBLK
;
SDAT4::	MOVL	-(R10),(R9)+	;MOVE ONE FIELD NAME VRBLK POINTER
	SOBGTR	R8,SDAT4	;LOOP TILL ALL MOVED
;
;      NOW DEFINE THE DATATYPE FUNCTION
;
	MOVL	R6,R8		;COPY LENGTH OF PDBLK FOR LATER LOOP
	MOVL	DATDV,R9	;POINT TO VRBLK
	MOVL	DATXS,R10	;POINT BACK ON STACK
	MOVL	(R10),R10	;LOAD DFBLK POINTER
	JSB	DFFNC		;DEFINE FUNCTION
	.PAGE
;
;      DATA (CONTINUED)
;
;      LOOP TO BUILD FFBLKS
;
;
;      NOTICE THAT THE FFBLKS ARE CONSTRUCTED IN REVERSE ORDER
;      SO THAT THE REQUIRED OFFSETS CAN BE OBTAINED FROM
;      SUCCESSIVE DECREMENTATION OF THE PDBLK LENGTH (IN WC).
;
SDAT5::	MOVL	#4*FFSI$,R6	;SET LENGTH OF FFBLK
	JSB	ALLOC		;ALLOCATE SPACE FOR FFBLK
	MOVL	#B$FFC,(R9)	;SET TYPE WORD
	MOVL	#NUM01,4*FARGS(R9) ;STORE FARGS (ALWAYS ONE)
	MOVL	DATXS,R10	;POINT BACK ON STACK
	MOVL	(R10),4*FFDFP(R9);COPY DFBLK PTR TO FFBLK
	SUBL2	#4,R8		;DECREMENT OLD DFPDL TO GET NEXT OFS
	MOVL	R8,4*FFOFS(R9)	;SET OFFSET TO THIS FIELD
	CLRL	4*FFNXT(R9)	;TENTATIVELY SET ZERO FORWARD PTR
	MOVL	R9,R10		;COPY FFBLK POINTER FOR DFFNC
	MOVL	(SP),R9		;LOAD VRBLK POINTER FOR FIELD
	MOVL	4*VRFNC(R9),R9	;LOAD CURRENT FUNCTION POINTER
	CMPL	(R9),#B$FFC	;SKIP IF NOT CURRENTLY A FIELD FUNC
	BNEQU	SDAT6
;
;      HERE WE MUST CHAIN AN OLD FFBLK PTR TO PRESERVE IT IN THE
;      CASE OF MULTIPLE FIELD FUNCTIONS WITH THE SAME NAME
;
	MOVL	R9,4*FFNXT(R10)	;LINK NEW FFBLK TO PREVIOUS CHAIN
;
;      MERGE HERE TO DEFINE FIELD FUNCTION
;
SDAT6::	MOVL	(SP)+,R9	;LOAD VRBLK POINTER
	JSB	DFFNC		;DEFINE FIELD FUNCTION
	CMPL	SP,DATXS	;LOOP BACK TILL ALL DONE
	BNEQU	SDAT5
	ADDL2	#4,SP		;POP DFBLK POINTER
	JMP	EXNUL		;RETURN WITH NULL RESULT
	.PAGE
;
;      DATATYPE
;
S$DTP::				;ENTRY POINT
	MOVL	(SP)+,R9	;LOAD ARGUMENT
	JSB	DTYPE		;GET DATATYPE
	JMP	EXIXR		;AND RETURN IT AS RESULT
	.PAGE
;
;      DATE
;
S$DTE::				;ENTRY POINT
	JSB	SYSDT		;CALL SYSTEM DATE ROUTINE
	MOVL	4*1(R10),R6	;LOAD LENGTH FOR SBSTR
	BNEQU	5084$
	JMP	EXNUL
5084$:
	CLRL	R7		;SET ZERO OFFSET
	JSB	SBSTR		;USE SBSTR TO BUILD SCBLK
	JMP	EXIXR		;RETURN DATE STRING
	.PAGE
;
;      DEFINE
;
S$DEF::				;ENTRY POINT
	MOVL	(SP)+,R9	;LOAD SECOND ARGUMENT
	CLRL	DEFLB		;ZERO LABEL POINTER IN CASE NULL
	CMPL	R9,#NULLS	;JUMP IF NULL SECOND ARGUMENT
	BEQLU	SDF01
	JSB	GTNVR		;ELSE FIND VRBLK FOR LABEL
	.ADDRESS SDF13		;JUMP IF NOT A VARIABLE NAME
	MOVL	R9,DEFLB	;ELSE SET SPECIFIED ENTRY
;
;      SCAN FUNCTION NAME
;
SDF01::	JSB	XSCNI		;PREPARE TO SCAN FIRST ARGUMENT
	.ADDRESS ERROR_081	;DEFINE FIRST ARGUMENT IS NOT STRING
	.ADDRESS ERROR_082	;DEFINE FIRST ARGUMENT IS NULL
	MOVL	#CH$PP,R8	;DELIMITER ONE = LEFT PAREN
	MOVL	R8,R10		;DELIMITER TWO = LEFT PAREN
	JSB	XSCAN		;SCAN OUT FUNCTION NAME
	TSTL	R6		;JUMP IF LEFT PAREN FOUND
	BNEQU	SDF02
	JMP	ERROR_083	;DEFINE FIRST ARGUMENT IS MISSING A LEFT PAREN
;
;      HERE AFTER SCANNING OUT FUNCTION NAME
;
SDF02::	JSB	GTNVR		;GET VARIABLE NAME
	.ADDRESS ERROR_084	;DEFINE FIRST ARGUMENT HAS NULL FUNCTION NAME
	MOVL	R9,DEFVR	;SAVE VRBLK POINTER FOR FUNCTION NAM
	CLRL	R7		;ZERO COUNT OF ARGUMENTS
	MOVL	SP,DEFXS	;SAVE INITIAL STACK POINTER
	TSTL	DEFLB		;JUMP IF SECOND ARGUMENT GIVEN
	BNEQU	SDF03
	MOVL	R9,DEFLB	;ELSE DEFAULT IS FUNCTION NAME
;
;      LOOP TO SCAN ARGUMENT NAMES AND STACK VRBLK POINTERS
;
SDF03::	MOVL	#CH$RP,R8	;DELIMITER ONE = RIGHT PAREN
	MOVL	#CH$CM,R10	;DELIMITER TWO = COMMA
	JSB	XSCAN		;SCAN OUT NEXT ARGUMENT NAME
	TSTL	R6		;SKIP IF DELIMITER FOUND
	BNEQU	SDF04
	JMP	ERROR_085	;NULL ARG NAME OR MISSING ) IN DEFINE FIRST ARG.
	.PAGE
;
;      DEFINE (CONTINUED)
;
;      HERE AFTER SCANNING AN ARGUMENT NAME
;
SDF04::	CMPL	R9,#NULLS	;SKIP IF NON-NULL
	BNEQU	SDF05
	TSTL	R7		;IGNORE NULL IF CASE OF NO ARGUMENTS
	BEQLU	SDF06
;
;      HERE AFTER DEALING WITH THE CASE OF NO ARGUMENTS
;
SDF05::	JSB	GTNVR		;GET VRBLK POINTER
	.ADDRESS SDF03		;LOOP BACK TO IGNORE NULL NAME
	MOVL	R9,-(SP)	;STACK ARGUMENT VRBLK POINTER
	INCL	R7		;INCREMENT COUNTER
	CMPL	R6,#NUM02	;LOOP BACK IF STOPPED BY A COMMA
	BEQLU	SDF03
;
;      HERE AFTER SCANNING OUT FUNCTION ARGUMENT NAMES
;
SDF06::	MOVL	R7,DEFNA	;SAVE NUMBER OF ARGUMENTS
	CLRL	R7		;ZERO COUNT OF LOCALS
;
;      LOOP TO SCAN LOCAL NAMES AND STACK VRBLK POINTERS
;
SDF07::	MOVL	#CH$CM,R8	;SET DELIMITER ONE = COMMA
	MOVL	R8,R10		;SET DELIMITER TWO = COMMA
	JSB	XSCAN		;SCAN OUT NEXT LOCAL NAME
	CMPL	R9,#NULLS	;SKIP IF NON-NULL
	BNEQU	SDF08
	TSTL	R7		;IGNORE NULL IF CASE OF NO LOCALS
	BEQLU	SDF09
;
;      HERE AFTER SCANNING OUT A LOCAL NAME
;
SDF08::	JSB	GTNVR		;GET VRBLK POINTER
	.ADDRESS SDF07		;LOOP BACK TO IGNORE NULL NAME
	INCL	R7		;IF OK, INCREMENT COUNT
	MOVL	R9,-(SP)	;STACK VRBLK POINTER
	TSTL	R6		;LOOP BACK IF STOPPED BY A COMMA
	BNEQU	SDF07
	.PAGE
;
;      DEFINE (CONTINUED)
;
;      HERE AFTER SCANNING LOCALS, BUILD PFBLK
;
SDF09::	MOVL	R7,R6		;COPY COUNT OF LOCALS
	ADDL2	DEFNA,R6	;ADD NUMBER OF ARGUMENTS
	MOVL	R6,R8		;SET SUM ARGS+LOCALS AS LOOP COUNT
	ADDL2	#PFSI$,R6	;ADD SPACE FOR STANDARD FIELDS
	MOVAL	0[R6],R6	;CONVERT LENGTH TO BYTES
	JSB	ALLOC		;ALLOCATE SPACE FOR PFBLK
	MOVL	R9,R10		;SAVE POINTER TO PFBLK
	MOVL	#B$PFC,(R9)+	;STORE FIRST WORD
	MOVL	DEFNA,(R9)+	;STORE NUMBER OF ARGUMENTS
	MOVL	R6,(R9)+	;STORE LENGTH (PFLEN)
	MOVL	DEFVR,(R9)+	;STORE VRBLK PTR FOR FUNCTION NAME
	MOVL	R7,(R9)+	;STORE NUMBER OF LOCALS
	CLRL	(R9)+		;DEAL WITH LABEL LATER
	CLRL	(R9)+		;ZERO PFCTR
	CLRL	(R9)+		;ZERO PFRTR
	TSTL	R8		;SKIP IF NO ARGS OR LOCALS
	BEQLU	SDF11
	MOVL	R10,R6		;KEEP PFBLK POINTER
	MOVL	DEFXS,R10	;POINT BEFORE ARGUMENTS
				;GET COUNT OF ARGS+LOCALS FOR LOOP
;
;      LOOP TO MOVE LOCALS AND ARGS TO PFBLK
;
SDF10::	MOVL	-(R10),(R9)+	;STORE ONE ENTRY AND BUMP POINTERS
	SOBGTR	R8,SDF10	;LOOP TILL ALL STORED
	MOVL	R6,R10		;RECOVER PFBLK POINTER
	.PAGE
;
;      DEFINE (CONTINUED)
;
;      NOW DEAL WITH LABEL
;
SDF11::	MOVL	DEFXS,SP	;POP STACK
	MOVL	DEFLB,R9	;POINT TO VRBLK FOR LABEL
	MOVL	4*VRLBL(R9),R9	;LOAD LABEL POINTER
	CMPL	(R9),#B$TRT	;SKIP IF NOT TRAPPED
	BNEQU	SDF12
	MOVL	4*TRLBL(R9),R9	;ELSE POINT TO REAL LABEL
;
;      HERE AFTER LOCATING REAL LABEL POINTER
;
SDF12::	CMPL	R9,#STNDL	;JUMP IF LABEL IS NOT DEFINED
	BEQLU	SDF13
	MOVL	R9,4*PFCOD(R10)	;ELSE STORE LABEL POINTER
	MOVL	DEFVR,R9	;POINT BACK TO VRBLK FOR FUNCTION
	JSB	DFFNC		;DEFINE FUNCTION
	JMP	EXNUL		;AND EXIT RETURNING NULL
;
;      HERE FOR ERRONEOUS LABEL
;
SDF13::	JMP	ERROR_086	;DEFINE FUNCTION ENTRY POINT IS NOT DEFINED LABEL
	.PAGE
;
;      DETACH
;
S$DET::				;ENTRY POINT
	MOVL	(SP)+,R9	;LOAD ARGUMENT
	JSB	GTVAR		;LOCATE VARIABLE
	.ADDRESS ERROR_087	;DETACH ARGUMENT IS NOT APPROPRIATE NAME
	JSB	DTACH		;DETACH I/O ASSOCIATION FROM NAME
	JMP	EXNUL		;RETURN NULL RESULT
	.PAGE
;
;      DIFFER
;
S$DIF::				;ENTRY POINT
	MOVL	(SP)+,R9	;LOAD SECOND ARGUMENT
	MOVL	(SP)+,R10	;LOAD FIRST ARGUMENT
	JSB	IDENT		;CALL IDENT COMPARISON ROUTINE
	.ADDRESS EXFAL		;FAIL IF IDENT
	JMP	EXNUL		;RETURN NULL IF DIFFER
	.PAGE
;
;      DUMP
;
S$DMP::				;ENTRY POINT
	JSB	GTSMI		;LOAD DUMP ARG AS SMALL INTEGER
	.ADDRESS ERROR_088	;DUMP ARGUMENT IS NOT INTEGER
	.ADDRESS ERROR_089	;DUMP ARGUMENT IS NEGATIVE OR TOO LARGE
	JSB	DUMPR		;ELSE CALL DUMP ROUTINE
	JMP	EXNUL		;AND RETURN NULL AS RESULT
	.PAGE
;
;      DUPL
;
S$DUP::				;ENTRY POINT
	JSB	GTSMI		;GET SECOND ARGUMENT AS SMALL INTEGE
	.ADDRESS ERROR_090	;DUPL SECOND ARGUMENT IS NOT INTEGER
	.ADDRESS SDUP7		;JUMP IF NEGATIVE OT TOO BIG
	MOVL	R9,R7		;SAVE DUPLICATION FACTOR
	JSB	GTSTG		;GET FIRST ARG AS STRING
	.ADDRESS SDUP4		;JUMP IF NOT A STRING
;
;      HERE FOR CASE OF DUPLICATION OF A STRING
;
	MOVL	R6,R5		;ACQUIRE LENGTH AS INTEGER
	MOVL	R5,DUPSI	;SAVE FOR THE MOMENT
	MOVL	R7,R5		;GET DUPLICATION FACTOR AS INTEGER
	MULL2	DUPSI,R5	;FORM PRODUCT
	BVS	SDUP3
	TSTL	R5		;RETURN NULL IF RESULT LENGTH = 0
	BNEQ	5085$
	JMP	EXNUL
5085$:
	MFI	R6,SDUP3	;GET AS ADDR INTEGER, CHECK OVFLO
;
;      MERGE HERE WITH RESULT LENGTH IN WA
;
SDUP1::	MOVL	R9,R10		;SAVE STRING POINTER
	JSB	ALOCS		;ALLOCATE SPACE FOR STRING
	MOVL	R9,-(SP)	;SAVE AS RESULT POINTER
	MOVL	R10,R8		;SAVE POINTER TO ARGUMENT STRING
	MOVAB	CFP$F(R9),R9	;PREPARE TO STORE CHARS OF RESULT
				;SET COUNTER TO CONTROL LOOP
;
;      LOOP THROUGH DUPLICATIONS
;
SDUP2::	MOVL	R8,R10		;POINT BACK TO ARGUMENT STRING
	MOVL	4*SCLEN(R10),R6	;GET NUMBER OF CHARACTERS
	MOVAB	CFP$F(R10),R10	;POINT TO CHARS IN ARGUMENT STRING
	MVC			;MOVE CHARACTERS TO RESULT STRING
	SOBGTR	R7,SDUP2	;LOOP TILL ALL DUPLICATIONS DONE
	JMP	EXITS		;THEN EXIT FOR NEXT CODE WORD
	.PAGE
;
;      DUPL (CONTINUED)
;
;      HERE IF TOO LARGE, SET MAX LENGTH AND LET ALOCS CATCH IT
;
SDUP3::	MOVL	DNAME,R6	;SET IMPOSSIBLE LENGTH FOR ALOCS
	JMP	SDUP1		;MERGE BACK
;
;      HERE IF NOT A STRING
;
SDUP4::	JSB	GTPAT		;CONVERT ARGUMENT TO PATTERN
	.ADDRESS ERROR_091	;DUPL FIRST ARGUMENT IS NOT STRING OR PATTERN
;
;      HERE TO DUPLICATE A PATTERN ARGUMENT
;
	MOVL	R9,-(SP)	;STORE PATTERN ON STACK
	MOVL	#NDNTH,R9	;START OFF WITH NULL PATTERN
	TSTL	R7		;NULL PATTERN IS RESULT IF DUPFAC=0
	BEQLU	SDUP6
	MOVL	R7,-(SP)	;PRESERVE LOOP COUNT
;
;      LOOP TO DUPLICATE BY SUCCESSIVE CONCATENATION
;
SDUP5::	MOVL	R9,R10		;COPY CURRENT VALUE AS RIGHT ARGUMNT
	MOVL	4*1(SP),R9	;GET A NEW COPY OF LEFT
	JSB	PCONC		;CONCATENATE
	DECL	(SP)		;COUNT DOWN
	TSTL	(SP)		;LOOP
	BNEQU	SDUP5
	ADDL2	#4,SP		;POP LOOP COUNT
;
;      HERE TO EXIT AFTER CONSTRUCTING PATTERN
;
SDUP6::	MOVL	R9,(SP)		;STORE RESULT ON STACK
	JMP	EXITS		;EXIT WITH RESULT ON STACK
;
;      FAIL IF SECOND ARG IS OUT OF RANGE
;
SDUP7::	ADDL2	#4,SP		;POP FIRST ARGUMENT
	JMP	EXFAL		;FAIL
	.PAGE
;
;      EJECT
;
S$EJC::				;ENTRY POINT
	JSB	IOFCB		;CALL FCBLK ROUTINE
	.ADDRESS ERROR_092	;EJECT ARGUMENT IS NOT A SUITABLE NAME
	.ADDRESS SEJC1		;NULL ARGUMENT
	JSB	SYSEF		;CALL EJECT FILE FUNCTION
	.ADDRESS ERROR_093	;EJECT FILE DOES NOT EXIST
	.ADDRESS ERROR_094	;EJECT FILE DOES NOT PERMIT PAGE EJECT
	.ADDRESS ERROR_095	;EJECT CAUSED NON-RECOVERABLE OUTPUT ERROR
	JMP	EXNUL		;RETURN NULL AS RESULT
;
;      HERE TO EJECT STANDARD OUTPUT FILE
;
SEJC1::	JSB	SYSEP		;CALL ROUTINE TO EJECT PRINTER
	JMP	EXNUL		;EXIT WITH NULL RESULT
	.PAGE
;
;      ENDFILE
;
S$ENF::				;ENTRY POINT
	JSB	IOFCB		;CALL FCBLK ROUTINE
	.ADDRESS ERROR_096	;ENDFILE ARGUMENT IS NOT A SUITABLE NAME
	.ADDRESS ERROR_097	;ENDFILE ARGUMENT IS NULL
	JSB	SYSEN		;CALL ENDFILE ROUTINE
	.ADDRESS ERROR_098	;ENDFILE FILE DOES NOT EXIST
	.ADDRESS ERROR_099	;ENDFILE FILE DOES NOT PERMIT ENDFILE
	.ADDRESS ERROR_100	;ENDFILE CAUSED NON-RECOVERABLE OUTPUT ERROR
	MOVL	R10,R7		;REMEMBER VRBLK PTR FROM IOFCB CALL
;
;      LOOP TO FIND TRTRF BLOCK
;
SENF1::	MOVL	R10,R9		;COPY POINTER
	MOVL	4*TRVAL(R9),R9	;CHAIN ALONG
	CMPL	(R9),#B$TRT	;SKIP OUT IF CHAIN END
	BEQLU	5086$
	JMP	EXNUL
5086$:
	CMPL	4*TRTYP(R9),#TRTFC ;LOOP IF NOT FOUND
	BNEQU	SENF1
	MOVL	4*TRVAL(R9),4*TRVAL(R10) ;REMOVE TRTRF
	MOVL	4*TRTRF(R9),ENFCH;POINT TO HEAD OF IOCHN
	MOVL	4*TRFPT(R9),R8	;POINT TO FCBLK
	MOVL	R7,R9		;FILEARG1 VRBLK FROM IOFCB
	JSB	SETVR		;RESET IT
	MOVL	#R$FCB,R10	;PTR TO HEAD OF FCBLK CHAIN
	SUBL2	#4*NUM02,R10	;ADJUST READY TO ENTER LOOP
;
;      FIND FCBLK
;
SENF2::	MOVL	R10,R9		;COPY PTR
	MOVL	4*2(R10),R10	;GET NEXT LINK
	TSTL	R10		;STOP IF CHAIN END
	BEQLU	SENF4
	CMPL	4*3(R10),R8	;JUMP IF FCBLK FOUND
	BEQLU	SENF3
	JMP	SENF2		;LOOP
;
;      REMOVE FCBLK
;
SENF3::	MOVL	4*2(R10),4*2(R9);DELETE FCBLK FROM CHAIN
;
;      LOOP WHICH DETACHES ALL VBLS ON IOCHN CHAIN
;
SENF4::	MOVL	ENFCH,R10	;GET CHAIN HEAD
	BNEQU	5087$
	JMP	EXNUL
5087$:
	MOVL	4*TRTRF(R10),ENFCH ;CHAIN ALONG
	MOVL	4*IONMO(R10),R6	;NAME OFFSET
	MOVL	4*IONMB(R10),R10;NAME BASE
	JSB	DTACH		;DETACH NAME
	JMP	SENF4		;LOOP TILL DONE
	.PAGE
;
;      EQ
;
S$EQF::				;ENTRY POINT
	JSB	ACOMP		;CALL ARITHMETIC COMPARISON ROUTINE
	.ADDRESS ERROR_101	;EQ FIRST ARGUMENT IS NOT NUMERIC
	.ADDRESS ERROR_102	;EQ SECOND ARGUMENT IS NOT NUMERIC
	.ADDRESS EXFAL		;FAIL IF LT
	.ADDRESS EXNUL		;RETURN NULL IF EQ
	.ADDRESS EXFAL		;FAIL IF GT
	.PAGE
;
;      EVAL
;
S$EVL::				;ENTRY POINT
	MOVL	(SP)+,R9	;LOAD ARGUMENT
	JSB	GTEXP		;CONVERT TO EXPRESSION
	.ADDRESS ERROR_103	;EVAL ARGUMENT IS NOT EXPRESSION
	MOVL	(R3)+,R8	;LOAD NEXT CODE WORD
	CMPL	R8,#OFNE$	;JUMP IF CALLED BY VALUE
	BNEQU	SEVL1
	MOVL	R3,R10		;COPY CODE POINTER
	MOVL	(R10),R6	;GET NEXT CODE WORD
	CMPL	R6,#ORNM$	;BY NAME UNLESS EXPRESSION
	BNEQU	SEVL2
	TSTL	4*1(SP)	;JUMP IF BY NAME
	BNEQU	SEVL2
;
;      HERE IF CALLED BY VALUE
;
SEVL1::	CLRL	R7		;SET FLAG FOR BY VALUE
	MOVL	R8,-(SP)	;SAVE CODE WORD
	JSB	EVALX		;EVALUATE EXPRESSION BY VALUE
	.ADDRESS EXFAL		;FAIL IF EVALUATION FAILS
	MOVL	R9,R10		;COPY RESULT
	MOVL	(SP),R9		;RELOAD NEXT CODE WORD
	MOVL	R10,(SP)	;STACK RESULT
	MOVL	(R9),R11	;JUMP TO EXECUTE NEXT CODE WORD
	JMP	(R11)
;
;      HERE IF CALLED BY NAME
;
SEVL2::	MOVL	#NUM01,R7	;SET FLAG FOR BY NAME
	JSB	EVALX		;EVALUATE EXPRESSION BY NAME
	.ADDRESS EXFAL		;FAIL IF EVALUATION FAILS
	JMP	EXNAM		;EXIT WITH NAME
	.IF NOT_EQUAL CNEX
	.IF_FALSE
	.PAGE
;
;      EXIT
;
S$EXT::				;ENTRY POINT
	CLRL	R7		;CLEAR AMOUNT OF STATIC SHIFT
	JSB	GBCOL		;COMPACT MEMORY BY COLLECTING
	JSB	GTSTG		;CONVERT ARG TO STRING
	.ADDRESS ERROR_104	;EXIT ARGUMENT IS NOT SUITABLE INTEGER OR STRING
	MOVL	R9,R10		;COPY STRING PTR
	JSB	GTINT		;CHECK IT IS INTEGER
	.ADDRESS SEXT1		;SKIP IF UNCONVERTIBLE
	CLRL	R10		;NOTE IT IS INTEGER
	MOVL	4*ICVAL(R9),R5	;GET INTEGER ARG
	MOVL	R$FCB,R7	;GET FCBLK CHAIN HEADER
;
;      MERGE TO CALL OSINT EXIT ROUTINE
;
SEXT1::	MOVL	#HEADV,R9	;POINT TO V.V STRING
	JSB	SYSXI		;CALL EXTERNAL ROUTINE
	.ADDRESS ERROR_105	;EXIT ACTION NOT AVAILABLE IN THIS IMPLEMENTATION
	.ADDRESS ERROR_106	;EXIT ACTION CAUSED IRRECOVERABLE ERROR
	TSTL	R5		;RETURN IF ARGUMENT 0
	BNEQ	5088$
	JMP	EXNUL
5088$:
	CLRL	GBCNT		;RESUMING EXECUTION SO RESET
	TSTL	R5		;SKIP IF POSITIVE
	BGTR	SEXT2
	MNEGL	R5,R5		;MAKE POSITIVE
;
;      CHECK FOR OPTION RESPECIFICATION
;
SEXT2::	MFI	R8		;GET VALUE IN WORK REG
	CMPL	R8,#NUM03	;SKIP IF WAS 3
	BEQLU	SEXT3
	MOVL	R8,-(SP)	;SAVE VALUE
	CLRL	R8		;SET TO READ OPTIONS
	JSB	PRPAR		;READ SYSPP OPTIONS
	MOVL	(SP)+,R8	;RESTORE VALUE
;
;      DEAL WITH HEADER OPTION (FIDDLED BY PRPAR)
;
SEXT3::	MOVL	SP,HEADP	;ASSUME NO HEADERS
	CMPL	R8,#NUM01	;SKIP IF NOT 1
	BNEQU	SEXT4
	CLRL	HEADP		;REQUEST HEADER PRINTING
;
;      ALMOST READY TO RESUME RUNNING
;
SEXT4::	JSB	SYSTM		;GET EXECUTION TIME START [SGD11]
	MOVL	R5,TIMSX	;SAVE AS INITIAL TIME
	MOVL	KVSTC,R5	;RESET TO ENSURE ...
	MOVL	R5,KVSTL	;... CORRECT EXECUTION STATS
	JMP	EXNUL		;RESUME EXECUTION
	.ENDC
	.PAGE
;
;      FIELD
;
S$FLD::				;ENTRY POINT
	JSB	GTSMI		;GET SECOND ARGUMENT (FIELD NUMBER)
	.ADDRESS ERROR_107	;FIELD SECOND ARGUMENT IS NOT INTEGER
	.ADDRESS EXFAL		;FAIL IF OUT OF RANGE
	MOVL	R9,R7		;ELSE SAVE INTEGER VALUE
	MOVL	(SP)+,R9	;LOAD FIRST ARGUMENT
	JSB	GTNVR		;POINT TO VRBLK
	.ADDRESS SFLD1		;JUMP (ERROR) IF NOT VARIABLE NAME
	MOVL	4*VRFNC(R9),R9	;ELSE POINT TO FUNCTION BLOCK
	CMPL	(R9),#B$DFC	;ERROR IF NOT DATATYPE FUNCTION
	BNEQU	SFLD1
;
;      HERE IF FIRST ARGUMENT IS A DATATYPE FUNCTION NAME
;
	TSTL	R7		;FAIL IF ARGUMENT NUMBER IS ZERO
	BNEQU	5089$
	JMP	EXFAL
5089$:
	CMPL	R7,4*FARGS(R9)	;FAIL IF TOO LARGE
	BLEQU	5090$
	JMP	EXFAL
5090$:
	MOVAL	0[R7],R7	;ELSE CONVERT TO BYTE OFFSET
	ADDL2	R7,R9		;POINT TO FIELD NAME
	MOVL	4*DFFLB(R9),R9	;LOAD VRBLK POINTER
	JMP	EXVNM		;EXIT TO BUILD NMBLK
;
;      HERE FOR BAD FIRST ARGUMENT
;
SFLD1::	JMP	ERROR_108	;FIELD FIRST ARGUMENT IS NOT DATATYPE NAME
	.PAGE
;
;      FENCE
;
S$FNC::				;ENTRY POINT
	MOVL	#P$FNC,R7	;SET PCODE FOR P$FNC
	CLRL	R9		;P0BLK
	JSB	PBILD		;BUILD P$FNC NODE
	MOVL	R9,R10		;SAVE POINTER TO IT
	MOVL	(SP)+,R9	;GET ARGUMENT
	JSB	GTPAT		;CONVERT TO PATTERN
	.ADDRESS ERROR_259	;FENCE ARGUMENT IS NOT PATTERN
	JSB	PCONC		;CONCATENATE TO P$FNC NODE
	MOVL	R9,R10		;SAVE PTR TO CONCATENATED PATTERN
	MOVL	#P$FNA,R7	;SET FOR P$FNA PCODE
	CLRL	R9		;P0BLK
	JSB	PBILD		;CONSTRUCT P$FNA NODE
	MOVL	R10,4*PTHEN(R9)	;SET PATTERN AS PTHEN
	MOVL	R9,-(SP)	;SET AS RESULT
	JMP	EXITS		;DO NEXT CODE WORD
	.PAGE
;
;      GE
;
S$GEF::				;ENTRY POINT
	JSB	ACOMP		;CALL ARITHMETIC COMPARISON ROUTINE
	.ADDRESS ERROR_109	;GE FIRST ARGUMENT IS NOT NUMERIC
	.ADDRESS ERROR_110	;GE SECOND ARGUMENT IS NOT NUMERIC
	.ADDRESS EXFAL		;FAIL IF LT
	.ADDRESS EXNUL		;RETURN NULL IF EQ
	.ADDRESS EXNUL		;RETURN NULL IF GT
	.PAGE
;
;      GT
;
S$GTF::				;ENTRY POINT
	JSB	ACOMP		;CALL ARITHMETIC COMPARISON ROUTINE
	.ADDRESS ERROR_111	;GT FIRST ARGUMENT IS NOT NUMERIC
	.ADDRESS ERROR_112	;GT SECOND ARGUMENT IS NOT NUMERIC
	.ADDRESS EXFAL		;FAIL IF LT
	.ADDRESS EXFAL		;FAIL IF EQ
	.ADDRESS EXNUL		;RETURN NULL IF GT
	.PAGE
;
;      HOST
;
S$HST::				;ENTRY POINT
	MOVL	(SP)+,R9	;GET THIRD ARG
	MOVL	(SP)+,R10	;GET SECOND ARG
	MOVL	(SP)+,R6	;GET FIRST ARG
	JSB	SYSHS		;ENTER SYSHS ROUTINE
	.ADDRESS ERROR_254	;ERRONEOUS ARGUMENT FOR HOST
	.ADDRESS ERROR_255	;ERROR DURING EXECUTION OF HOST
	.ADDRESS SHST1		;STORE HOST STRING
	.ADDRESS EXNUL		;RETURN NULL RESULT
	.ADDRESS EXIXR		;RETURN XR
	.ADDRESS EXFAL		;FAIL RETURN
;
;      RETURN HOST STRING
;
SHST1::	TSTL	R10		;NULL STRING IF SYSHS UNCOOPERATIVE
	BNEQU	5091$
	JMP	EXNUL
5091$:
	MOVL	4*SCLEN(R10),R6	;LENGTH
	CLRL	R7		;ZERO OFFSET
	JSB	SBSTR		;BUILD COPY OF STRING
	MOVL	R9,-(SP)	;STACK THE RESULT
	JMP	EXITS		;RETURN RESULT ON STACK
	.PAGE
;
;      IDENT
;
S$IDN::				;ENTRY POINT
	MOVL	(SP)+,R9	;LOAD SECOND ARGUMENT
	MOVL	(SP)+,R10	;LOAD FIRST ARGUMENT
	JSB	IDENT		;CALL IDENT COMPARISON ROUTINE
	.ADDRESS EXNUL		;RETURN NULL IF IDENT
	JMP	EXFAL		;FAIL IF DIFFER
	.PAGE
;
;      INPUT
;
S$INP::				;ENTRY POINT
	CLRL	R7		;INPUT FLAG
	JSB	IOPUT		;CALL INPUT/OUTPUT ASSOC. ROUTINE
	.ADDRESS ERROR_113	;INPUT THIRD ARGUMENT IS NOT A STRING
	.ADDRESS ERROR_114	;INAPPROPRIATE SECOND ARGUMENT FOR INPUT
	.ADDRESS ERROR_115	;INAPPROPRIATE FIRST ARGUMENT FOR INPUT
	.ADDRESS ERROR_116	;INAPPROPRIATE FILE SPECIFICATION FOR INPUT
	.ADDRESS EXFAL		;FAIL IF FILE DOES NOT EXIST
	.ADDRESS ERROR_117	;INPUT FILE CANNOT BE READ
	JMP	EXNUL		;RETURN NULL STRING
	.PAGE
;
;      INTEGER
;
S$INT::				;ENTRY POINT
	MOVL	(SP)+,R9	;LOAD ARGUMENT
	JSB	GTNUM		;CONVERT TO NUMERIC
	.ADDRESS EXFAL		;FAIL IF NON-NUMERIC
	CMPL	R6,#B$ICL	;RETURN NULL IF INTEGER
	BNEQU	5092$
	JMP	EXNUL
5092$:
	JMP	EXFAL		;FAIL IF REAL
	.PAGE
;
;      ITEM
;
;      ITEM DOES NOT PERMIT THE DIRECT (FAST) CALL SO THAT
;      WA CONTAINS THE ACTUAL NUMBER OF ARGUMENTS PASSED.
;
S$ITM::				;ENTRY POINT
;
;      DEAL WITH CASE OF NO ARGS
;
	TSTL	R6		;JUMP IF AT LEAST ONE ARG
	BNEQU	SITM1
	MOVL	#NULLS,-(SP)	;ELSE SUPPLY GARBAGE NULL ARG
	MOVL	#NUM01,R6	;AND FIX ARGUMENT COUNT
;
;      CHECK FOR NAME/VALUE CASES
;
SITM1::	MOVL	R3,R9		;GET CURRENT CODE POINTER
	MOVL	(R9),R10	;LOAD NEXT CODE WORD
	DECL	R6		;GET NUMBER OF SUBSCRIPTS
	MOVL	R6,R9		;COPY FOR ARREF
	CMPL	R10,#OFNE$	;JUMP IF CALLED BY NAME
	BEQLU	SITM2
;
;      HERE IF CALLED BY VALUE
;
	CLRL	R7		;SET CODE FOR CALL BY VALUE
	JMP	ARREF		;OFF TO ARRAY REFERENCE ROUTINE
;
;      HERE FOR CALL BY NAME
;
SITM2::	MOVL	SP,R7		;SET CODE FOR CALL BY NAME
	MOVL	(R3)+,R6	;LOAD AND IGNORE OFNE$ CALL
	JMP	ARREF		;OFF TO ARRAY REFERENCE ROUTINE
	.PAGE
;
;      LE
;
S$LEF::				;ENTRY POINT
	JSB	ACOMP		;CALL ARITHMETIC COMPARISON ROUTINE
	.ADDRESS ERROR_118	;LE FIRST ARGUMENT IS NOT NUMERIC
	.ADDRESS ERROR_119	;LE SECOND ARGUMENT IS NOT NUMERIC
	.ADDRESS EXNUL		;RETURN NULL IF LT
	.ADDRESS EXNUL		;RETURN NULL IF EQ
	.ADDRESS EXFAL		;FAIL IF GT
	.PAGE
;
;      LEN
;
S$LEN::				;ENTRY POINT
	MOVL	#P$LEN,R7	;SET PCODE FOR INTEGER ARG CASE
	MOVL	#P$LND,R6	;SET PCODE FOR EXPR ARG CASE
	JSB	PATIN		;CALL COMMON ROUTINE TO BUILD NODE
	.ADDRESS ERROR_120	;LEN ARGUMENT IS NOT INTEGER OR EXPRESSION
	.ADDRESS ERROR_121	;LEN ARGUMENT IS NEGATIVE OR TOO LARGE
	JMP	EXIXR		;RETURN PATTERN NODE
	.PAGE
;
;      LEQ
;
S$LEQ::				;ENTRY POINT
	JSB	LCOMP		;CALL STRING COMPARISON ROUTINE
	.ADDRESS ERROR_122	;LEQ FIRST ARGUMENT IS NOT STRING
	.ADDRESS ERROR_123	;LEQ SECOND ARGUMENT IS NOT STRING
	.ADDRESS EXFAL		;FAIL IF LLT
	.ADDRESS EXNUL		;RETURN NULL IF LEQ
	.ADDRESS EXFAL		;FAIL IF LGT
	.PAGE
;
;      LGE
;
S$LGE::				;ENTRY POINT
	JSB	LCOMP		;CALL STRING COMPARISON ROUTINE
	.ADDRESS ERROR_124	;LGE FIRST ARGUMENT IS NOT STRING
	.ADDRESS ERROR_125	;LGE SECOND ARGUMENT IS NOT STRING
	.ADDRESS EXFAL		;FAIL IF LLT
	.ADDRESS EXNUL		;RETURN NULL IF LEQ
	.ADDRESS EXNUL		;RETURN NULL IF LGT
	.PAGE
;
;      LGT
;
S$LGT::				;ENTRY POINT
	JSB	LCOMP		;CALL STRING COMPARISON ROUTINE
	.ADDRESS ERROR_126	;LGT FIRST ARGUMENT IS NOT STRING
	.ADDRESS ERROR_127	;LGT SECOND ARGUMENT IS NOT STRING
	.ADDRESS EXFAL		;FAIL IF LLT
	.ADDRESS EXFAL		;FAIL IF LEQ
	.ADDRESS EXNUL		;RETURN NULL IF LGT
	.PAGE
;
;      LLE
;
S$LLE::				;ENTRY POINT
	JSB	LCOMP		;CALL STRING COMPARISON ROUTINE
	.ADDRESS ERROR_128	;LLE FIRST ARGUMENT IS NOT STRING
	.ADDRESS ERROR_129	;LLE SECOND ARGUMENT IS NOT STRING
	.ADDRESS EXNUL		;RETURN NULL IF LLT
	.ADDRESS EXNUL		;RETURN NULL IF LEQ
	.ADDRESS EXFAL		;FAIL IF LGT
	.PAGE
;
;      LLT
;
S$LLT::				;ENTRY POINT
	JSB	LCOMP		;CALL STRING COMPARISON ROUTINE
	.ADDRESS ERROR_130	;LLT FIRST ARGUMENT IS NOT STRING
	.ADDRESS ERROR_131	;LLT SECOND ARGUMENT IS NOT STRING
	.ADDRESS EXNUL		;RETURN NULL IF LLT
	.ADDRESS EXFAL		;FAIL IF LEQ
	.ADDRESS EXFAL		;FAIL IF LGT
	.PAGE
;
;      LNE
;
S$LNE::				;ENTRY POINT
	JSB	LCOMP		;CALL STRING COMPARISON ROUTINE
	.ADDRESS ERROR_132	;LNE FIRST ARGUMENT IS NOT STRING
	.ADDRESS ERROR_133	;LNE SECOND ARGUMENT IS NOT STRING
	.ADDRESS EXNUL		;RETURN NULL IF LLT
	.ADDRESS EXFAL		;FAIL IF LEQ
	.ADDRESS EXNUL		;RETURN NULL IF LGT
	.PAGE
;
;      LOCAL
;
S$LOC::				;ENTRY POINT
	JSB	GTSMI		;GET SECOND ARGUMENT (LOCAL NUMBER)
	.ADDRESS ERROR_134	;LOCAL SECOND ARGUMENT IS NOT INTEGER
	.ADDRESS EXFAL		;FAIL IF OUT OF RANGE
	MOVL	R9,R7		;SAVE LOCAL NUMBER
	MOVL	(SP)+,R9	;LOAD FIRST ARGUMENT
	JSB	GTNVR		;POINT TO VRBLK
	.ADDRESS SLOC1		;JUMP IF NOT VARIABLE NAME
	MOVL	4*VRFNC(R9),R9	;ELSE LOAD FUNCTION POINTER
	CMPL	(R9),#B$PFC	;JUMP IF NOT PROGRAM DEFINED
	BNEQU	SLOC1
;
;      HERE IF WE HAVE A PROGRAM DEFINED FUNCTION NAME
;
	TSTL	R7		;FAIL IF SECOND ARG IS ZERO
	BNEQU	5093$
	JMP	EXFAL
5093$:
	CMPL	R7,4*PFNLO(R9)	;OR TOO LARGE
	BLEQU	5094$
	JMP	EXFAL
5094$:
	ADDL2	4*FARGS(R9),R7	;ELSE ADJUST OFFSET TO INCLUDE ARGS
	MOVAL	0[R7],R7	;CONVERT TO BYTES
	ADDL2	R7,R9		;POINT TO LOCAL POINTER
	MOVL	4*PFAGB(R9),R9	;LOAD VRBLK POINTER
	JMP	EXVNM		;EXIT BUILDING NMBLK
;
;      HERE IF FIRST ARGUMENT IS NO GOOD
;
SLOC1::	JMP	ERROR_135	;LOCAL FIRST ARG IS NOT A PROGRAM FUNCTION NAME
	.IF NOT_EQUAL CNLD
	.IF_FALSE
	.PAGE
;
;      LOAD
;
S$LOD::				;ENTRY POINT
	JSB	GTSTG		;LOAD LIBRARY NAME
	.ADDRESS ERROR_136	;LOAD SECOND ARGUMENT IS NOT STRING
	MOVL	R9,R10		;SAVE LIBRARY NAME
	JSB	XSCNI		;PREPARE TO SCAN FIRST ARGUMENT
	.ADDRESS ERROR_137	;LOAD FIRST ARGUMENT IS NOT STRING
	.ADDRESS ERROR_138	;LOAD FIRST ARGUMENT IS NULL
	MOVL	R10,-(SP)	;STACK LIBRARY NAME
	MOVL	#CH$PP,R8	;SET DELIMITER ONE = LEFT PAREN
	MOVL	R8,R10		;SET DELIMITER TWO = LEFT PAREN
	JSB	XSCAN		;SCAN FUNCTION NAME
	MOVL	R9,-(SP)	;SAVE PTR TO FUNCTION NAME
	TSTL	R6		;JUMP IF LEFT PAREN FOUND
	BNEQU	SLOD1
	JMP	ERROR_139	;LOAD FIRST ARGUMENT IS MISSING A LEFT PAREN
;
;      HERE AFTER SUCCESSFULLY SCANNING FUNCTION NAME
;
SLOD1::	JSB	GTNVR		;LOCATE VRBLK
	.ADDRESS ERROR_140	;LOAD FIRST ARGUMENT HAS NULL FUNCTION NAME
	MOVL	R9,LODFN	;SAVE VRBLK POINTER
	CLRL	LODNA		;ZERO COUNT OF ARGUMENTS
;
;      LOOP TO SCAN ARGUMENT DATATYPE NAMES
;
SLOD2::	MOVL	#CH$RP,R8	;DELIMITER ONE IS RIGHT PAREN
	MOVL	#CH$CM,R10	;DELIMITER TWO IS COMMA
	JSB	XSCAN		;SCAN NEXT ARGUMENT NAME
	INCL	LODNA		;BUMP ARGUMENT COUNT
	TSTL	R6		;JUMP IF OK DELIMITER WAS FOUND
	BNEQU	SLOD3
	JMP	ERROR_141	;LOAD FIRST ARGUMENT IS MISSING A RIGHT PAREN
	.PAGE
;
;      LOAD (CONTINUED)
;
;      COME HERE TO ANALYZE THE DATATYPE POINTER IN (XR). THIS
;      CODE IS USED BOTH FOR ARGUMENTS (WA=1,2) AND FOR THE
;      RESULT DATATYPE (WITH WA SET TO ZERO).
;
SLOD3::	MOVL	R9,-(SP)	;STACK DATATYPE NAME POINTER
	MOVL	#NUM01,R7	;SET STRING CODE IN CASE
	MOVL	#SCSTR,R10	;POINT TO /STRING/
	JSB	IDENT		;CHECK FOR MATCH
	.ADDRESS SLOD4		;JUMP IF MATCH
	MOVL	(SP),R9		;ELSE RELOAD NAME
	ADDL2	R7,R7		;SET CODE FOR INTEGER (2)
	MOVL	#SCINT,R10	;POINT TO /INTEGER/
	JSB	IDENT		;CHECK FOR MATCH
	.ADDRESS SLOD4		;JUMP IF MATCH
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	MOVL	(SP),R9		;ELSE RELOAD STRING POINTER
	INCL	R7		;SET CODE FOR REAL (3)
	MOVL	#SCREA,R10	;POINT TO /REAL/
	JSB	IDENT		;CHECK FOR MATCH
	.ADDRESS SLOD4		;JUMP IF MATCH
	.ENDC
	CLRL	R7		;ELSE GET CODE FOR NO CONVERT
;
;      MERGE HERE WITH PROPER DATATYPE CODE IN WB
;
SLOD4::	MOVL	R7,(SP)		;STORE CODE ON STACK
	CMPL	R6,#NUM02	;LOOP BACK IF ARG STOPPED BY COMMA
	BEQLU	SLOD2
	TSTL	R6		;JUMP IF THAT WAS THE RESULT TYPE
	BEQLU	SLOD5
;
;      HERE WE SCAN OUT THE RESULT TYPE (ARG STOPPED BY ) )
;
	MOVL	MXLEN,R8	;SET DUMMY (IMPOSSIBLE) DELIMITER 1
	MOVL	R8,R10		;AND DELIMITER TWO
	JSB	XSCAN		;SCAN RESULT NAME
	CLRL	R6		;SET CODE FOR PROCESSING RESULT
	JMP	SLOD3		;JUMP BACK TO PROCESS RESULT NAME
	.PAGE
;
;      LOAD (CONTINUED)
;
;      HERE AFTER PROCESSING ALL ARGS AND RESULT
;
SLOD5::	MOVL	LODNA,R6	;GET NUMBER OF ARGUMENTS
	MOVL	R6,R8		;COPY FOR LATER
	MOVAL	0[R6],R6	;CONVERT LENGTH TO BYTES
	ADDL2	#4*EFSI$,R6	;ADD SPACE FOR STANDARD FIELDS
	JSB	ALLOC		;ALLOCATE EFBLK
	MOVL	#B$EFC,(R9)	;SET TYPE WORD
	MOVL	R8,4*FARGS(R9)	;SET NUMBER OF ARGUMENTS
	CLRL	4*EFUSE(R9)	;SET USE COUNT (DFFNC WILL SET TO 1)
	CLRL	4*EFCOD(R9)	;ZERO CODE POINTER FOR NOW
	MOVL	(SP)+,4*EFRSL(R9);STORE RESULT TYPE CODE
	MOVL	LODFN,4*EFVAR(R9);STORE FUNCTION VRBLK POINTER
	MOVL	R6,4*EFLEN(R9)	;STORE EFBLK LENGTH
	MOVL	R9,R7		;SAVE EFBLK POINTER
	ADDL2	R6,R9		;POINT PAST END OF EFBLK
				;SET NUMBER OF ARGUMENTS FOR LOOP
;
;      LOOP TO SET ARGUMENT TYPE CODES FROM STACK
;
SLOD6::	MOVL	(SP)+,-(R9)	;STORE ONE TYPE CODE FROM STACK
	SOBGTR	R8,SLOD6	;LOOP TILL ALL STORED
;
;      NOW LOAD THE EXTERNAL FUNCTION AND PERFORM DEFINITION
;
	MOVL	(SP)+,R9	;LOAD FUNCTION STRING NAME
	MOVL	(SP),R10	;LOAD LIBRARY NAME
	MOVL	R7,(SP)		;STORE EFBLK POINTER
	JSB	SYSLD		;CALL FUNCTION TO LOAD EXTERNAL FUNC
	.ADDRESS ERROR_142	;LOAD FUNCTION DOES NOT EXIST
	.ADDRESS ERROR_143	;LOAD FUNCTION CAUSED INPUT ERROR DURING LOAD
	MOVL	(SP)+,R10	;RECALL EFBLK POINTER
	MOVL	R9,4*EFCOD(R10)	;STORE CODE POINTER
	MOVL	LODFN,R9	;POINT TO VRBLK FOR FUNCTION
	JSB	DFFNC		;PERFORM FUNCTION DEFINITION
	JMP	EXNUL		;RETURN NULL RESULT
	.ENDC
	.PAGE
;
;      LPAD
;
S$LPD::				;ENTRY POINT
	JSB	GTSTG		;GET PAD CHARACTER
	.ADDRESS ERROR_144	;LPAD THIRD ARGUMENT NOT A STRING
	MOVAB	CFP$F(R9),R9	;POINT TO CHARACTER (NULL IS BLANK)
	MOVZBL	(R9),R7		;LOAD PAD CHARACTER
	JSB	GTSMI		;GET PAD LENGTH
	.ADDRESS ERROR_145	;LPAD SECOND ARGUMENT IS NOT INTEGER
	.ADDRESS SLPD3		;SKIP IF NEGATIVE OR LARGE
;
;      MERGE TO CHECK FIRST ARG
;
SLPD1::	JSB	GTSTG		;GET FIRST ARGUMENT (STRING TO PAD)
	.ADDRESS ERROR_146	;LPAD FIRST ARGUMENT IS NOT STRING
	CMPL	R6,R8		;RETURN 1ST ARG IF TOO LONG TO PAD
	BLSSU	5095$
	JMP	EXIXR
5095$:
	MOVL	R9,R10		;ELSE MOVE PTR TO STRING TO PAD
;
;      NOW WE ARE READY FOR THE PAD
;
;      (XL)                  POINTER TO STRING TO PAD
;      (WB)                  PAD CHARACTER
;      (WC)                  LENGTH TO PAD STRING TO
;
	MOVL	R8,R6		;COPY LENGTH
	JSB	ALOCS		;ALLOCATE SCBLK FOR NEW STRING
	MOVL	R9,-(SP)	;SAVE AS RESULT
	MOVL	4*SCLEN(R10),R6	;LOAD LENGTH OF ARGUMENT
	SUBL2	R6,R8		;CALCULATE NUMBER OF PAD CHARACTERS
	MOVAB	CFP$F(R9),R9	;POINT TO CHARS IN RESULT STRING
				;SET COUNTER FOR PAD LOOP
;
;      LOOP TO PERFORM PAD
;
SLPD2::	MOVB	R7,(R9)+	;STORE PAD CHARACTER, BUMP PTR
	SOBGTR	R8,SLPD2	;LOOP TILL ALL PAD CHARS STORED
	;CSC	R9		;COMPLETE STORE CHARACTERS
;
;      NOW COPY STRING
;
	TSTL	R6		;EXIT IF NULL STRING
	BNEQU	5096$
	JMP	EXITS
5096$:
	MOVAB	CFP$F(R10),R10	;ELSE POINT TO CHARS IN ARGUMENT
	MVC			;MOVE CHARACTERS TO RESULT STRING
	JMP	EXITS		;JUMP FOR NEXT CODE WORD
;
;      HERE IF 2ND ARG IS NEGATIVE OR LARGE
;
SLPD3::	CLRL	R8		;ZERO PAD COUNT
	JMP	SLPD1		;MERGE
	.PAGE
;
;      LT
;
S$LTF::				;ENTRY POINT
	JSB	ACOMP		;CALL ARITHMETIC COMPARISON ROUTINE
	.ADDRESS ERROR_147	;LT FIRST ARGUMENT IS NOT NUMERIC
	.ADDRESS ERROR_148	;LT SECOND ARGUMENT IS NOT NUMERIC
	.ADDRESS EXNUL		;RETURN NULL IF LT
	.ADDRESS EXFAL		;FAIL IF EQ
	.ADDRESS EXFAL		;FAIL IF GT
	.PAGE
;
;      NE
;
S$NEF::				;ENTRY POINT
	JSB	ACOMP		;CALL ARITHMETIC COMPARISON ROUTINE
	.ADDRESS ERROR_149	;NE FIRST ARGUMENT IS NOT NUMERIC
	.ADDRESS ERROR_150	;NE SECOND ARGUMENT IS NOT NUMERIC
	.ADDRESS EXNUL		;RETURN NULL IF LT
	.ADDRESS EXFAL		;FAIL IF EQ
	.ADDRESS EXNUL		;RETURN NULL IF GT
	.PAGE
;
;      NOTANY
;
S$NAY::				;ENTRY POINT
	MOVL	#P$NAS,R7	;SET PCODE FOR SINGLE CHAR ARG
	MOVL	#P$NAY,R10	;PCODE FOR MULTI-CHAR ARG
	MOVL	#P$NAD,R8	;SET PCODE FOR EXPR ARG
	JSB	PATST		;CALL COMMON ROUTINE TO BUILD NODE
	.ADDRESS ERROR_151	;NOTANY ARGUMENT IS NOT STRING OR EXPRESSION
	JMP	EXIXR		;JUMP FOR NEXT CODE WORD
	.PAGE
;
;      OPSYN
;
S$OPS::				;ENTRY POINT
	JSB	GTSMI		;LOAD THIRD ARGUMENT
	.ADDRESS ERROR_152	;OPSYN THIRD ARGUMENT IS NOT INTEGER
	.ADDRESS ERROR_153	;OPSYN THIRD ARGUMENT IS NEGATIVE OR TOO LARGE
	MOVL	R8,R7		;IF OK, SAVE THIRD ARGUMNET
	MOVL	(SP)+,R9	;LOAD SECOND ARGUMENT
	JSB	GTNVR		;LOCATE VARIABLE BLOCK
	.ADDRESS ERROR_154	;OPSYN SECOND ARG IS NOT NATURAL VARIABLE NAME
	MOVL	4*VRFNC(R9),R10	;IF OK, LOAD FUNCTION BLOCK POINTER
	TSTL	R7		;JUMP IF OPERATOR OPSYN CASE
	BNEQU	SOPS2
;
;      HERE FOR FUNCTION OPSYN (THIRD ARG ZERO)
;
	MOVL	(SP)+,R9	;LOAD FIRST ARGUMENT
	JSB	GTNVR		;GET VRBLK POINTER
	.ADDRESS ERROR_155	;OPSYN FIRST ARG IS NOT NATURAL VARIABLE NAME
;
;      MERGE HERE TO PERFORM FUNCTION DEFINITION
;
SOPS1::	JSB	DFFNC		;CALL FUNCTION DEFINER
	JMP	EXNUL		;EXIT WITH NULL RESULT
;
;      HERE FOR OPERATOR OPSYN (THIRD ARG NON-ZERO)
;
SOPS2::	JSB	GTSTG		;GET OPERATOR NAME
	.ADDRESS SOPS5		;JUMP IF NOT STRING
	CMPL	R6,#NUM01	;ERROR IF NOT ONE CHAR LONG
	BNEQU	SOPS5
	MOVAB	CFP$F(R9),R9	;ELSE POINT TO CHARACTER
	MOVZBL	(R9),R8		;LOAD CHARACTER NAME
	.PAGE
;
;      OPSYN (CONTINUED)
;
;      NOW SET TO SEARCH FOR MATCHING UNARY OR BINARY OPERATOR
;      NAME AS APPROPRIATE. NOTE THAT THERE ARE =OPBUN UNDEFINED
;      BINARY OPERATORS AND =OPUUN UNDEFINED UNARY OPERATORS.
;
	MOVL	#R$UUB,R6	;POINT TO UNOP POINTERS IN CASE
	MOVL	#OPNSU,R9	;POINT TO NAMES OF UNARY OPERATORS
	ADDL2	#OPBUN,R7	;ADD NO. OF UNDEFINED BINARY OPS
	CMPL	R7,#OPUUN	;JUMP IF UNOP (THIRD ARG WAS 1)
	BEQLU	SOPS3
	MOVL	#R$UBA,R6	;ELSE POINT TO BINARY OPERATOR PTRS
	MOVL	#OPSNB,R9	;POINT TO NAMES OF BINARY OPERATORS
	MOVL	#OPBUN,R7	;SET NUMBER OF UNDEFINED BINOPS
;
;      MERGE HERE TO CHECK LIST (WB = NUMBER TO CHECK)
;
SOPS3::				;SET COUNTER TO CONTROL LOOP
;
;      LOOP TO SEARCH FOR NAME MATCH
;
SOPS4::	CMPL	R8,(R9)		;JUMP IF NAMES MATCH
	BEQLU	SOPS6
	ADDL2	#4,R6		;ELSE PUSH POINTER TO FUNCTION PTR
	ADDL2	#4,R9		;BUMP POINTER
	SOBGTR	R7,SOPS4	;LOOP BACK TILL ALL CHECKED
;
;      HERE IF BAD OPERATOR NAME
;
SOPS5::	JMP	ERROR_156	;OPSYN FIRST ARG IS NOT CORRECT OPERATOR NAME
;
;      COME HERE ON FINDING A MATCH IN THE OPERATOR NAME TABLE
;
SOPS6::	MOVL	R6,R9		;COPY POINTER TO FUNCTION BLOCK PTR
	SUBL2	#4*VRFNC,R9	;MAKE IT LOOK LIKE DUMMY VRBLK
	JMP	SOPS1		;MERGE BACK TO DEFINE OPERATOR
	.PAGE
;
;      OUTPUT
;
S$OUP::				;ENTRY POINT
	MOVL	#NUM03,R7	;OUTPUT FLAG
	JSB	IOPUT		;CALL INPUT/OUTPUT ASSOC. ROUTINE
	.ADDRESS ERROR_157	;OUTPUT THIRD ARGUMENT IS NOT A STRING
	.ADDRESS ERROR_158	;INAPPROPRIATE SECOND ARGUMENT FOR OUTPUT
	.ADDRESS ERROR_159	;INAPPROPRIATE FIRST ARGUMENT FOR OUTPUT
	.ADDRESS ERROR_160	;INAPPROPRIATE FILE SPECIFICATION FOR OUTPUT
	.ADDRESS EXFAL		;FAIL IF FILE DOES NOT EXIST
	.ADDRESS ERROR_161	;OUTPUT FILE CANNOT BE WRITTEN TO
	JMP	EXNUL		;RETURN NULL STRING
	.PAGE
;
;      POS
;
S$POS::				;ENTRY POINT
	MOVL	#P$POS,R7	;SET PCODE FOR INTEGER ARG CASE
	MOVL	#P$PSD,R6	;SET PCODE FOR EXPRESSION ARG CASE
	JSB	PATIN		;CALL COMMON ROUTINE TO BUILD NODE
	.ADDRESS ERROR_162	;POS ARGUMENT IS NOT INTEGER OR EXPRESSION
	.ADDRESS ERROR_163	;POS ARGUMENT IS NEGATIVE OR TOO LARGE
	JMP	EXIXR		;RETURN PATTERN NODE
	.PAGE
;
;      PROTOTYPE
;
S$PRO::				;ENTRY POINT
	MOVL	(SP)+,R9	;LOAD ARGUMENT
	MOVL	4*TBLEN(R9),R7	;LENGTH IF TABLE, VECTOR (=VCLEN)
	ASHL	#-2,R7,R7	;CONVERT TO WORDS
	MOVL	(R9),R6		;LOAD TYPE WORD OF ARGUMENT BLOCK
	CMPL	R6,#B$ART	;JUMP IF ARRAY
	BEQLU	SPRO4
	CMPL	R6,#B$TBT	;JUMP IF TABLE
	BEQLU	SPRO1
	CMPL	R6,#B$VCT	;JUMP IF VECTOR
	BEQLU	SPRO3
	JMP	ERROR_164	;PROTOTYPE ARGUMENT IS NOT TABLE OR ARRAY
;
;      HERE FOR TABLE
;
SPRO1::	SUBL2	#TBSI$,R7	;SUBTRACT STANDARD FIELDS
;
;      MERGE FOR VECTOR
;
SPRO2::	MOVL	R7,R5		;CONVERT TO INTEGER
	JMP	EXINT		;EXIT WITH INTEGER RESULT
;
;      HERE FOR VECTOR
;
SPRO3::	SUBL2	#VCSI$,R7	;SUBTRACT STANDARD FIELDS
	JMP	SPRO2		;MERGE
;
;      HERE FOR ARRAY
;
SPRO4::	ADDL2	4*AROFS(R9),R9	;POINT TO PROTOTYPE FIELD
	MOVL	(R9),R9		;LOAD PROTOTYPE
	JMP	EXIXR		;RETURN PROTOTYPE AS RESULT
	.PAGE
;
;      REMDR
;
S$RMD::				;ENTRY POINT
	CLRL	R7		;SET POSITIVE FLAG
	MOVL	(SP),R9		;LOAD SECOND ARGUMENT
	JSB	GTINT		;CONVERT TO INTEGER
	.ADDRESS ERROR_165	;REMDR SECOND ARGUMENT IS NOT INTEGER
	JSB	ARITH		;CONVERT ARGS
	.ADDRESS SRM01		;FIRST ARG NOT INTEGER
	.ADDRESS INVALID$	;SECOND ARG CHECKED ABOVE
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	.ADDRESS SRM01		;FIRST ARG REAL
	.ENDC
	MOVL	4*ICVAL(R9),R5	;LOAD LEFT ARGUMENT VALUE
	RMI	4*ICVAL(R10)	;GET REMAINDER
	BVS	5097$
	JMP	EXINT
5097$:
	JMP	ERROR_167	;REMDR CAUSED INTEGER OVERFLOW
;
;      FAIL FIRST ARGUMENT
;
SRM01::	JMP	ERROR_166	;REMDR FIRST ARGUMENT IS NOT INTEGER
	.PAGE
;
;      REPLACE
;
;      THE ACTUAL REPLACE OPERATION USES AN SCBLK WHOSE CFP$A
;      CHARS CONTAIN THE TRANSLATED VERSIONS OF ALL THE CHARS.
;      THE TABLE POINTER IS REMEMBERED FROM CALL TO CALL AND
;      THE TABLE IS ONLY BUILT WHEN THE ARGUMENTS CHANGE.
;
S$RPL::				;ENTRY POINT
	JSB	GTSTG		;LOAD THIRD ARGUMENT AS STRING
	.ADDRESS ERROR_168	;REPLACE THIRD ARGUMENT IS NOT STRING
	MOVL	R9,R10		;SAVE THIRD ARG PTR
	JSB	GTSTG		;GET SECOND ARGUMENT
	.ADDRESS ERROR_169	;REPLACE SECOND ARGUMENT IS NOT STRING
;
;      CHECK TO SEE IF THIS IS THE SAME TABLE AS LAST TIME
;
	CMPL	R9,R$RA2	;JUMP IF 2ND ARGUMENT DIFFERENT
	BNEQU	SRPL1
	CMPL	R10,R$RA3	;JUMP IF ARGS SAME AS LAST TIME
	BNEQU	5098$
	JMP	SRPL4
5098$:
;
;      HERE WE BUILD A NEW REPLACE TABLE (NOTE WA = 2ND ARG LEN)
;
SRPL1::	MOVL	4*SCLEN(R10),R7	;LOAD 3RD ARGUMENT LENGTH
	CMPL	R6,R7		;JUMP IF ARGUMENTS NOT SAME LENGTH
	BEQLU	5099$
	JMP	SRPL5
5099$:
	TSTL	R7		;JUMP IF NULL 2ND ARGUMENT
	BNEQU	5100$
	JMP	SRPL5
5100$:
	MOVL	R10,R$RA3	;SAVE THIRD ARG FOR NEXT TIME IN
	MOVL	R9,R$RA2	;SAVE SECOND ARG FOR NEXT TIME IN
	MOVL	KVALP,R10	;POINT TO ALPHABET STRING
	MOVL	4*SCLEN(R10),R6	;LOAD ALPHABET SCBLK LENGTH
	MOVL	R$RPT,R9	;POINT TO CURRENT TABLE (IF ANY)
	BNEQU	SRPL2
;
;      HERE WE ALLOCATE A NEW TABLE
;
	JSB	ALOCS		;ALLOCATE NEW TABLE
	MOVL	R8,R6		;KEEP SCBLK LENGTH
	MOVL	R9,R$RPT	;SAVE TABLE POINTER FOR NEXT TIME
;
;      MERGE HERE WITH POINTER TO NEW TABLE BLOCK IN (XR)
;
SRPL2::	MOVAB	3+<4*SCSI$>(R6),R6 ;COMPUTE LENGTH OF SCBLK
	BICL2	#3,R6
	MVW			;COPY TO GET INITIAL TABLE VALUES
	.PAGE
;
;      REPLACE (CONTINUED)
;
;      NOW WE MUST PLUG SELECTED ENTRIES AS REQUIRED. NOTE THAT
;      WE ARE SHORT OF INDEX REGISTERS FOR THE FOLLOWING LOOP.
;      HENCE THE NEED TO REPEATEDLY RE-INITIALISE CHAR PTR XL
;
	MOVL	R$RA2,R10	;POINT TO SECOND ARGUMENT
				;NUMBER OF CHARS TO PLUG
	CLRL	R8		;ZERO CHAR OFFSET
	MOVL	R$RA3,R9	;POINT TO 3RD ARG
	MOVAB	CFP$F(R9),R9	;GET CHAR PTR FOR 3RD ARG
;
;      LOOP TO PLUG CHARS
;
SRPL3::	MOVL	R$RA2,R10	;POINT TO 2ND ARG
	MOVAB	CFP$F(R10)[R8],R10 ;POINT TO NEXT CHAR
	INCL	R8		;INCREMENT OFFSET
	MOVZBL	(R10),R6	;GET NEXT CHAR
	MOVL	R$RPT,R10	;POINT TO TRANSLATE TABLE
	MOVAB	CFP$F(R10)[R6],R10 ;CONVERT CHAR TO OFFSET INTO TABLE
	MOVZBL	(R9)+,R6	;GET TRANSLATED CHAR
	MOVB	R6,(R10)	;STORE IN TABLE
	;CSC	R10		;COMPLETE STORE CHARACTERS
	SOBGTR	R7,SRPL3	;LOOP TILL DONE
	.PAGE
;
;      REPLACE (CONTINUED)
;
;      HERE TO PERFORM TRANSLATE
;
SRPL4::	JSB	GTSTG		;GET FIRST ARGUMENT
	.ADDRESS ERROR_170	;REPLACE FIRST ARGUMENT IS NOT STRING
	TSTL	R6		;RETURN NULL IF NULL ARGUMENT
	BNEQU	5101$
	JMP	EXNUL
5101$:
	MOVL	R9,R10		;COPY POINTER
	MOVL	R6,R8		;SAVE LENGTH
	MOVAB	3+<4*SCHAR>(R6),R6 ;GET SCBLK LENGTH
	BICL2	#3,R6
	JSB	ALLOC		;ALLOCATE SPACE FOR COPY
	MOVL	R9,R7		;SAVE ADDRESS OF COPY
	MVW			;MOVE SCBLK CONTENTS TO COPY
	MOVL	R$RPT,R9	;POINT TO REPLACE TABLE
	MOVAB	CFP$F(R9),R9	;POINT TO CHARS OF TABLE
	MOVL	R7,R10		;POINT TO STRING TO TRANSLATE
	MOVAB	CFP$F(R10),R10	;POINT TO CHARS OF STRING
	MOVL	R8,R6		;SET NUMBER OF CHARS TO TRANSLATE
	TRC			;PERFORM TRANSLATION
	MOVL	R7,-(SP)	;STACK NEW STRING AS RESULT
	JMP	EXITS		;RETURN WITH RESULT ON STACK
;
;      ERROR POINT
;
SRPL5::	JMP	ERROR_171	;NULL OR UNEQUALLY LONG 2ND, 3RD ARGS TO REPLACE
	.PAGE
;
;      REWIND
;
S$REW::				;ENTRY POINT
	JSB	IOFCB		;CALL FCBLK ROUTINE
	.ADDRESS ERROR_172	;REWIND ARGUMENT IS NOT A SUITABLE NAME
	.ADDRESS ERROR_173	;REWIND ARGUMENT IS NULL
	JSB	SYSRW		;CALL SYSTEM REWIND FUNCTION
	.ADDRESS ERROR_174	;REWIND FILE DOES NOT EXIST
	.ADDRESS ERROR_175	;REWIND FILE DOES NOT PERMIT REWIND
	.ADDRESS ERROR_176	;REWIND CAUSED NON-RECOVERABLE ERROR
	JMP	EXNUL		;EXIT WITH NULL RESULT IF NO ERROR
	.PAGE
;
;      REVERSE
;
S$RVS::				;ENTRY POINT
	JSB	GTSTG		;LOAD STRING ARGUMENT
	.ADDRESS ERROR_177	;REVERSE ARGUMENT IS NOT STRING
	TSTL	R6		;RETURN ARGUMENT IF NULL
	BNEQU	5102$
	JMP	EXIXR
5102$:
	MOVL	R9,R10		;ELSE SAVE POINTER TO STRING ARG
	JSB	ALOCS		;ALLOCATE SPACE FOR NEW SCBLK
	MOVL	R9,-(SP)	;STORE SCBLK PTR ON STACK AS RESULT
	MOVAB	CFP$F(R9),R9	;PREPARE TO STORE IN NEW SCBLK
	MOVAB	CFP$F(R10)[R8],R10 ;POINT PAST LAST CHAR IN ARGUMENT
				;SET LOOP COUNTER
;
;      LOOP TO MOVE CHARS IN REVERSE ORDER
;
SRVS1::	MOVZBL	-(R10),R7	;LOAD NEXT CHAR FROM ARGUMENT
	MOVB	R7,(R9)+	;STORE IN RESULT
	SOBGTR	R8,SRVS1	;LOOP TILL ALL MOVED
	;CSC	R9		;COMPLETE STORE CHARACTERS
	JMP	EXITS		;AND THEN JUMP FOR NEXT CODE WORD
	.PAGE
;
;      RPAD
;
S$RPD::				;ENTRY POINT
	JSB	GTSTG		;GET PAD CHARACTER
	.ADDRESS ERROR_178	;RPAD THIRD ARGUMENT IS NOT STRING
	MOVAB	CFP$F(R9),R9	;POINT TO CHARACTER (NULL IS BLANK)
	MOVZBL	(R9),R7		;LOAD PAD CHARACTER
	JSB	GTSMI		;GET PAD LENGTH
	.ADDRESS ERROR_179	;RPAD SECOND ARGUMENT IS NOT INTEGER
	.ADDRESS SRPD3		;SKIP IF NEGATIVE OR LARGE
;
;      MERGE TO CHECK FIRST ARG.
;
SRPD1::	JSB	GTSTG		;GET FIRST ARGUMENT (STRING TO PAD)
	.ADDRESS ERROR_180	;RPAD FIRST ARGUMENT IS NOT STRING
	CMPL	R6,R8		;RETURN 1ST ARG IF TOO LONG TO PAD
	BLSSU	5103$
	JMP	EXIXR
5103$:
	MOVL	R9,R10		;ELSE MOVE PTR TO STRING TO PAD
;
;      NOW WE ARE READY FOR THE PAD
;
;      (XL)                  POINTER TO STRING TO PAD
;      (WB)                  PAD CHARACTER
;      (WC)                  LENGTH TO PAD STRING TO
;
	MOVL	R8,R6		;COPY LENGTH
	JSB	ALOCS		;ALLOCATE SCBLK FOR NEW STRING
	MOVL	R9,-(SP)	;SAVE AS RESULT
	MOVL	4*SCLEN(R10),R6	;LOAD LENGTH OF ARGUMENT
	SUBL2	R6,R8		;CALCULATE NUMBER OF PAD CHARACTERS
	MOVAB	CFP$F(R9),R9	;POINT TO CHARS IN RESULT STRING
				;SET COUNTER FOR PAD LOOP
;
;      COPY ARGUMENT STRING
;
	TSTL	R6		;JUMP IF ARGUMENT IS NULL
	BEQLU	SRPD2
	MOVAB	CFP$F(R10),R10	;ELSE POINT TO ARGUMENT CHARS
	MVC			;MOVE CHARACTERS TO RESULT STRING
;
;      LOOP TO SUPPLY PAD CHARACTERS
;
SRPD2::	MOVB	R7,(R9)+	;STORE PAD CHARACTER, BUMP PTR
	SOBGTR	R8,SRPD2	;LOOP TILL ALL PAD CHARS STORED
	;CSC	R9		;COMPLETE CHARACTER STORING
	JMP	EXITS		;AND EXIT FOR NEXT WORD
;
;      HERE IF 2ND ARG IS NEGATIVE OR LARGE
;
SRPD3::	CLRL	R8		;ZERO PAD COUNT
	JMP	SRPD1		;MERGE
	.PAGE
;
;      RTAB
;
S$RTB::				;ENTRY POINT
	MOVL	#P$RTB,R7	;SET PCODE FOR INTEGER ARG CASE
	MOVL	#P$RTD,R6	;SET PCODE FOR EXPRESSION ARG CASE
	JSB	PATIN		;CALL COMMON ROUTINE TO BUILD NODE
	.ADDRESS ERROR_181	;RTAB ARGUMENT IS NOT INTEGER OR EXPRESSION
	.ADDRESS ERROR_182	;RTAB ARGUMENT IS NEGATIVE OR TOO LARGE
	JMP	EXIXR		;RETURN PATTERN NODE
	.PAGE
;
;      TAB
;
S$TAB::				;ENTRY POINT
	MOVL	#P$TAB,R7	;SET PCODE FOR INTEGER ARG CASE
	MOVL	#P$TBD,R6	;SET PCODE FOR EXPRESSION ARG CASE
	JSB	PATIN		;CALL COMMON ROUTINE TO BUILD NODE
	.ADDRESS ERROR_183	;TAB ARGUMENT IS NOT INTEGER OR EXPRESSION
	.ADDRESS ERROR_184	;TAB ARGUMENT IS NEGATIVE OR TOO LARGE
	JMP	EXIXR		;RETURN PATTERN NODE
	.PAGE
;
;      RPOS
;
S$RPS::				;ENTRY POINT
	MOVL	#P$RPS,R7	;SET PCODE FOR INTEGER ARG CASE
	MOVL	#P$RPD,R6	;SET PCODE FOR EXPRESSION ARG CASE
	JSB	PATIN		;CALL COMMON ROUTINE TO BUILD NODE
	.ADDRESS ERROR_185	;RPOS ARGUMENT IS NOT INTEGER OR EXPRESSION
	.ADDRESS ERROR_186	;RPOS ARGUMENT IS NEGATIVE OR TOO LARGE
	JMP	EXIXR		;RETURN PATTERN NODE
	.IF NOT_EQUAL CNSR
	.IF_FALSE
	.PAGE
;
;      RSORT
;
S$RSR::				;ENTRY POINT
	MOVL	SP,R6		;MARK AS RSORT
	JSB	SORTA		;CALL SORT ROUTINE
	JMP	EXSID		;RETURN, SETTING IDVAL
	.ENDC
	.PAGE
;
;      SETEXIT
;
S$STX::				;ENTRY POINT
	MOVL	(SP)+,R9	;LOAD ARGUMENT
	MOVL	STXVR,R6	;LOAD OLD VRBLK POINTER
	CLRL	R10		;LOAD ZERO IN CASE NULL ARG
	CMPL	R9,#NULLS	;JUMP IF NULL ARGUMENT (RESET CALL)
	BEQLU	SSTX1
	JSB	GTNVR		;ELSE GET SPECIFIED VRBLK
	.ADDRESS SSTX2		;JUMP IF NOT NATURAL VARIABLE
	MOVL	4*VRLBL(R9),R10	;ELSE LOAD LABEL
	CMPL	R10,#STNDL	;JUMP IF LABEL IS NOT DEFINED
	BEQLU	SSTX2
	CMPL	(R10),#B$TRT	;JUMP IF NOT TRAPPED
	BNEQU	SSTX1
	MOVL	4*TRLBL(R10),R10;ELSE LOAD PTR TO REAL LABEL CODE
;
;      HERE TO SET/RESET SETEXIT TRAP
;
SSTX1::	MOVL	R9,STXVR	;STORE NEW VRBLK POINTER (OR NULL)
	MOVL	R10,R$SXC	;STORE NEW CODE PTR (OR ZERO)
	CMPL	R6,#NULLS	;RETURN NULL IF NULL RESULT
	BNEQU	5104$
	JMP	EXNUL
5104$:
	MOVL	R6,R9		;ELSE COPY VRBLK POINTER
	JMP	EXVNM		;AND RETURN BUILDING NMBLK
;
;      HERE IF BAD ARGUMENT
;
SSTX2::	JMP	ERROR_187	;SETEXIT ARGUMENT IS NOT LABEL NAME OR NULL
	.IF NOT_EQUAL CNSR
	.IF_FALSE
	.PAGE
;
;      SORT
;
S$SRT::				;ENTRY POINT
	CLRL	R6		;MARK AS SORT
	JSB	SORTA		;CALL SORT ROUTINE
	JMP	EXSID		;RETURN, SETTING IDVAL
	.ENDC
	.PAGE
;
;      SPAN
;
S$SPN::				;ENTRY POINT
	MOVL	#P$SPS,R7	;SET PCODE FOR SINGLE CHAR ARG
	MOVL	#P$SPN,R10	;SET PCODE FOR MULTI-CHAR ARG
	MOVL	#P$SPD,R8	;SET PCODE FOR EXPRESSION ARG
	JSB	PATST		;CALL COMMON ROUTINE TO BUILD NODE
	.ADDRESS ERROR_188	;SPAN ARGUMENT IS NOT STRING OR EXPRESSION
	JMP	EXIXR		;JUMP FOR NEXT CODE WORD
	.PAGE
;
;      SIZE
;
S$SI$::				;ENTRY POINT
	JSB	GTSTG		;LOAD STRING ARGUMENT
	.ADDRESS ERROR_189	;SIZE ARGUMENT IS NOT STRING
	MOVL	R6,R5		;LOAD LENGTH AS INTEGER
	JMP	EXINT		;EXIT WITH INTEGER RESULT
	.PAGE
;
;      STOPTR
;
S$STT::				;ENTRY POINT
	CLRL	R10		;INDICATE STOPTR CASE
	JSB	TRACE		;CALL TRACE PROCEDURE
	.ADDRESS ERROR_190	;STOPTR FIRST ARGUMENT IS NOT APPROPRIATE NAME
	.ADDRESS ERROR_191	;STOPTR SECOND ARGUMENT IS NOT TRACE TYPE
	JMP	EXNUL		;RETURN NULL
	.PAGE
;
;      SUBSTR
;
S$SUB::				;ENTRY POINT
	JSB	GTSMI		;LOAD THIRD ARGUMENT
	.ADDRESS ERROR_192	;SUBSTR THIRD ARGUMENT IS NOT INTEGER
	.ADDRESS EXFAL		;JUMP IF NEGATIVE OR TOO LARGE
	MOVL	R9,SBSSV	;SAVE THIRD ARGUMENT
	JSB	GTSMI		;LOAD SECOND ARGUMENT
	.ADDRESS ERROR_193	;SUBSTR SECOND ARGUMENT IS NOT INTEGER
	.ADDRESS EXFAL		;JUMP IF OUT OF RANGE
	MOVL	R9,R7		;SAVE SECOND ARGUMENT
	BNEQU	5105$
	JMP	EXFAL
5105$:
	DECL	R7		;ELSE DECREMENT FOR ONES ORIGIN
	JSB	GTSTG		;LOAD FIRST ARGUMENT
	.ADDRESS ERROR_194	;SUBSTR FIRST ARGUMENT IS NOT STRING
	MOVL	R9,R10		;COPY POINTER TO FIRST ARG
	MOVL	SBSSV,R8	;RELOAD THIRD ARGUMENT
	TSTL	R8		;SKIP IF THIRD ARG GIVEN
	BNEQU	SSUB1
	MOVL	4*SCLEN(R10),R8	;ELSE GET STRING LENGTH
	CMPL	R7,R8		;FAIL IF IMPROPER
	BLEQU	5106$
	JMP	EXFAL
5106$:
	SUBL2	R7,R8		;REDUCE BY OFFSET TO START
;
;      MERGE
;
SSUB1::	MOVL	R8,R6		;SET LENGTH OF SUBSTRING
	ADDL2	R7,R8		;ADD 2ND ARG TO 3RD ARG
	CMPL	R8,4*SCLEN(R10)	;JUMP IF IMPROPER SUBSTRING
	BLEQU	5107$
	JMP	EXFAL
5107$:
	JSB	SBSTR		;BUILD SUBSTRING
	JMP	EXIXR		;AND JUMP FOR NEXT CODE WORD
	.PAGE
;
;      TABLE
;
S$TBL::				;ENTRY POINT
	MOVL	(SP)+,R10	;GET INITIAL LOOKUP VALUE
	ADDL2	#4,SP		;POP SECOND ARGUMENT
	JSB	GTSMI		;LOAD ARGUMENT
	.ADDRESS ERROR_195	;TABLE ARGUMENT IS NOT INTEGER
	.ADDRESS ERROR_196	;TABLE ARGUMENT IS OUT OF RANGE
	TSTL	R8		;JUMP IF NON-ZERO
	BNEQU	STBL1
	MOVL	#TBNBK,R8	;ELSE SUPPLY DEFAULT VALUE
;
;      MERGE HERE WITH NUMBER OF HEADERS IN WA
;
STBL1::	MOVL	R8,R6		;COPY NUMBER OF HEADERS
	ADDL2	#TBSI$,R6	;ADJUST FOR STANDARD FIELDS
	MOVAL	0[R6],R6	;CONVERT LENGTH TO BYTES
	JSB	ALLOC		;ALLOCATE SPACE FOR TBBLK
	MOVL	R9,R7		;COPY POINTER TO TBBLK
	MOVL	#B$TBT,(R9)+	;STORE TYPE WORD
	CLRL	(R9)+		;ZERO ID FOR THE MOMENT
	MOVL	R6,(R9)+	;STORE LENGTH (TBLEN)
	MOVL	R10,(R9)+	;STORE INITIAL LOOKUP VALUE
				;SET LOOP COUNTER (NUM HEADERS)
;
;      LOOP TO INITIALIZE ALL BUCKET POINTERS
;
STBL2::	MOVL	R7,(R9)+	;STORE TBBLK PTR IN BUCKET HEADER
	SOBGTR	R8,STBL2	;LOOP TILL ALL STORED
	MOVL	R7,R9		;RECALL POINTER TO TBBLK
	JMP	EXSID		;EXIT SETTING IDVAL
	.PAGE
;
;      TIME
;
S$TIM::				;ENTRY POINT
	JSB	SYSTM		;GET TIMER VALUE
	SUBL2	TIMSX,R5	;SUBTRACT STARTING TIME
	JMP	EXINT		;EXIT WITH INTEGER VALUE
	.PAGE
;
;      TRACE
;
S$TRA::				;ENTRY POINT
	CMPL	4*3(SP),#NULLS	;JUMP IF FIRST ARGUMENT IS NULL
	BEQLU	STR03
	MOVL	(SP)+,R9	;LOAD FOURTH ARGUMENT
	CLRL	R10		;TENTATIVELY SET ZERO POINTER
	CMPL	R9,#NULLS	;JUMP IF 4TH ARGUMENT IS NULL
	BEQLU	STR02
	JSB	GTNVR		;ELSE POINT TO VRBLK
	.ADDRESS STR01		;JUMP IF NOT VARIABLE NAME
	MOVL	4*VRFNC(R9),R10	;ELSE LOAD FUNCTION POINTER
	CMPL	R10,#STNDF	;JUMP IF FUNCTION IS DEFINED
	BNEQU	STR02
;
;      HERE FOR BAD FOURTH ARGUMENT
;
STR01::	JMP	ERROR_197	;TRACE FOURTH ARG IS NOT FUNCTION NAME OR NULL
;
;      HERE WITH FUNCTION POINTER IN XL
;
STR02::	MOVL	(SP)+,R9	;LOAD THIRD ARGUMENT (TAG)
	CLRL	R7		;SET ZERO AS TRTYP VALUE FOR NOW
	JSB	TRBLD		;BUILD TRBLK FOR TRACE CALL
	MOVL	R9,R10		;MOVE TRBLK POINTER FOR TRACE
	JSB	TRACE		;CALL TRACE PROCEDURE
	.ADDRESS ERROR_198	;TRACE FIRST ARGUMENT IS NOT APPROPRIATE NAME
	.ADDRESS ERROR_199	;TRACE SECOND ARGUMENT IS NOT TRACE TYPE
	JMP	EXNUL		;RETURN NULL
;
;      HERE TO CALL SYSTEM TRACE TOGGLE ROUTINE
;
STR03::	JSB	SYSTT		;CALL IT
	ADDL2	#4*NUM04,SP	;POP TRACE ARGUMENTS
	JMP	EXNUL		;RETURN
	.PAGE
;
;      TRIM
;
S$TRM::				;ENTRY POINT
	JSB	GTSTG		;LOAD ARGUMENT AS STRING
	.ADDRESS ERROR_200	;TRIM ARGUMENT IS NOT STRING
	TSTL	R6		;RETURN NULL IF ARGUMENT IS NULL
	BNEQU	5108$
	JMP	EXNUL
5108$:
	MOVL	R9,R10		;COPY STRING POINTER
	MOVAB	3+<4*SCHAR>(R6),R6 ;GET BLOCK LENGTH
	BICL2	#3,R6
	JSB	ALLOC		;ALLOCATE COPY SAME SIZE
	MOVL	R9,R7		;SAVE POINTER TO COPY
	MVW			;COPY OLD STRING BLOCK TO NEW
	MOVL	R7,R9		;RESTORE PTR TO NEW BLOCK
	JSB	TRIMR		;TRIM BLANKS (WB IS NON-ZERO)
	JMP	EXIXR		;EXIT WITH RESULT IN XR
	.PAGE
;
;      UNLOAD
;
S$UNL::				;ENTRY POINT
	MOVL	(SP)+,R9	;LOAD ARGUMENT
	JSB	GTNVR		;POINT TO VRBLK
	.ADDRESS ERROR_201	;UNLOAD ARGUMENT IS NOT NATURAL VARIABLE NAME
	MOVL	#STNDF,R10	;GET PTR TO UNDEFINED FUNCTION
	JSB	DFFNC		;UNDEFINE NAMED FUNCTION
	JMP	EXNUL		;RETURN NULL AS RESULT
	.PAGE
	.SUBTITLE S P I T B O L -- UTILITY PROCEDURES
;
;      THE FOLLOWING SECTION CONTAINS PROCEDURES WHICH ARE
;      USED FOR VARIOUS PURPOSES THROUGHOUT THE SYSTEM.
;
;      EACH PROCEDURE IS PRECEDED BY A DESCRIPTION OF THE
;      CALLING SEQUENCE. USUALLY THE ARGUMENTS ARE IN REGISTERS
;      BUT ARGUMENTS CAN ALSO OCCUR ON THE STACK AND AS
;      PARAMETERS ASSEMBLED AFTER THE JSR INSTRUCTION.
;
;      THE FOLLOWING CONSIDERATIONS APPLY TO THESE DESCRIPTIONS.
;
;      1)   THE STACK POINTER (XS) IS NOT CHANGED UNLESS THE
;           CHANGE IS EXPLICITLY DOCUMENTED IN THE CALL.
;
;      2)   REGISTERS WHOSE ENTRY VALUES ARE NOT MENTIONED
;           MAY CONTAIN ANY VALUE EXCEPT THAT XL,XR MAY ONLY
;           CONTAIN PROPER (COLLECTABLE) POINTER VALUES.
;           THIS CONDITION ON XR MEANS THAT THE CALLED ROUTINE
;           MAY IF IT CHOOSES PRESERVE XR BY STACKING.
;
;      3)   REGISTERS NOT MENTIONED ON EXIT CONTAIN THE SAME
;           VALUES AS THEY DID ON ENTRY EXCEPT THAT VALUES IN
;           XR,XL MAY HAVE BEEN RELOCATED BY THE COLLECTOR.
;
;      4)   REGISTERS WHICH ARE DESTROYED ON EXIT MAY CONTAIN
;           ANY VALUE EXCEPT THAT VALUES IN XL,XR ARE PROPER
;           (COLLECTABLE) POINTERS.
;
;      5)   THE CODE POINTER REGISTER POINTS TO THE CURRENT
;           CODE LOCATION ON ENTRY AND IS UNCHANGED ON EXIT.
;
;      IN THE ABOVE DESCRIPTION, A COLLECTABLE POINTER IS ONE
;      WHICH EITHER POINTS OUTSIDE THE DYNAMIC REGION OR
;      POINTS TO THE START OF A BLOCK IN THE DYNAMIC REGION.
;
;      IN THOSE CASES WHERE THE CALLING SEQUENCE CONTAINS
;      PARAMETERS WHICH ARE USED AS ALTERNATE RETURN POINTS,
;      THESE PARAMETERS MAY BE REPLACED BY ERROR CODES
;      ASSEMBLED WITH THE ERR INSTRUCTION. THIS WILL RESULT
;      IN THE POSTING OF THE ERROR IF THE RETURN IS TAKEN.
;
;      THE PROCEDURES ALL HAVE NAMES CONSISTING OF FIVE LETTERS
;      AND ARE IN ALPHABETICAL ORDER BY THEIR NAMES.
	.PAGE
;
;      ACESS - ACCESS VARIABLE VALUE WITH TRACE/INPUT CHECKS
;
;      ACESS LOADS THE VALUE OF A VARIABLE. TRACE AND INPUT
;      ASSOCIATIONS ARE TESTED FOR AND EXECUTED AS REQUIRED.
;      ACESS ALSO HANDLES THE SPECIAL CASES OF PSEUDO-VARIABLES.
;
;      (XL)                  VARIABLE NAME BASE
;      (WA)                  VARIABLE NAME OFFSET
;      JSR  ACESS            CALL TO ACCESS VALUE
;      PPM  LOC              TRANSFER LOC IF ACCESS FAILURE
;      (XR)                  VARIABLE VALUE
;      (WA,WB,WC)            DESTROYED
;      (XL,RA)               DESTROYED
;
;      FAILURE CAN OCCUR IF AN INPUT ASSOCIATION CAUSES AN END
;      OF FILE CONDITION OR IF THE EVALUATION OF AN EXPRESSION
;      ASSOCIATED WITH AN EXPRESSION VARIABLE FAILS.
;
	.ENABLE	LOCAL_BLOCK
ACESS::	;PRC			;ENTRY POINT (RECURSIVE)
	MOVL	R10,R9		;COPY NAME BASE
	ADDL2	R6,R9		;POINT TO VARIABLE LOCATION
	MOVL	(R9),R9		;LOAD VARIABLE VALUE
;
;      LOOP HERE TO CHECK FOR SUCCESSIVE TRBLKS
;
ACS02::	CMPL	(R9),#B$TRT	;JUMP IF NOT TRAPPED
	BEQLU	5109$
	JMP	ACS18
5109$:
;
;      HERE IF TRAPPED
;
	CMPL	R9,#TRBKV	;JUMP IF KEYWORD VARIABLE
	BNEQU	5110$
	JMP	ACS12
5110$:
	CMPL	R9,#TRBEV	;JUMP IF NOT EXPRESSION VARIABLE
	BNEQU	ACS05
;
;      HERE FOR EXPRESSION VARIABLE, EVALUATE VARIABLE
;
	MOVL	4*EVEXP(R10),R9	;LOAD EXPRESSION POINTER
	CLRL	R7		;EVALUATE BY VALUE
	JSB	EVALX		;EVALUATE EXPRESSION
	.ADDRESS ACS04		;JUMP IF EVALUATION FAILURE
	JMP	ACS02		;CHECK VALUE FOR MORE TRBLKS
	.PAGE
;
;      ACESS (CONTINUED)
;
;      HERE ON READING END OF FILE
;
ACS03::	ADDL2	#4*NUM03,SP	;POP TRBLK PTR, NAME BASE AND OFFSET
	MOVL	R9,DNAMP	;POP UNUSED SCBLK
;
;      MERGE HERE WHEN EVALUATION OF EXPRESSION FAILS
;
ACS04::	MOVL	(SP)+,R11	;TAKE ALTERNATE (FAILURE) RETURN
	JMP	@(R11)+
;
;      HERE IF NOT KEYWORD OR EXPRESSION VARIABLE
;
ACS05::	MOVL	4*TRTYP(R9),R7	;LOAD TRAP TYPE CODE
	BEQLU	5111$
	JMP	ACS10
5111$:
	TSTL	KVINP		;IGNORE INPUT ASSOC IF INPUT IS OFF
	BNEQU	5112$
	JMP	ACS09
5112$:
;
;      HERE FOR INPUT ASSOCIATION
;
	MOVL	R10,-(SP)	;STACK NAME BASE
	MOVL	R6,-(SP)	;STACK NAME OFFSET
	MOVL	R9,-(SP)	;STACK TRBLK POINTER
	MOVL	4*TRFPT(R9),R10	;GET FILE CTRL BLK PTR OR ZERO
	BNEQU	ACS06
	CMPL	4*TRTER(R9),#V$TER ;JUMP IF TERMINAL
	BNEQU	5113$
	JMP	ACS21
5113$:
;
;      HERE TO READ FROM STANDARD INPUT FILE
;
	MOVL	CSWIN,R6	;LENGTH FOR READ BUFFER
	JSB	ALOCS		;BUILD STRING OF APPROPRIATE LENGTH
	JSB	SYSRD		;READ NEXT STANDARD INPUT IMAGE
	.ADDRESS ACS03		;JUMP TO FAIL EXIT IF END OF FILE
	JMP	ACS07		;ELSE MERGE WITH OTHER FILE CASE
;
;      HERE FOR INPUT FROM OTHER THAN STANDARD INPUT FILE
;
ACS06::	MOVL	R10,R6		;FCBLK PTR
	JSB	SYSIL		;GET INPUT RECORD MAX LENGTH (TO WA)
	JSB	ALOCS		;ALLOCATE STRING OF CORRECT SIZE
	MOVL	R10,R6		;FCBLK PTR
	JSB	SYSIN		;CALL SYSTEM INPUT ROUTINE
	.ADDRESS ACS03		;JUMP TO FAIL EXIT IF END OF FILE
	.ADDRESS ACS22		;ERROR
	.ADDRESS ACS23		;ERROR
	.PAGE
;
;      ACESS (CONTINUED)
;
;      MERGE HERE AFTER OBTAINING INPUT RECORD
;
ACS07::	MOVL	KVTRM,R7	;LOAD TRIM INDICATOR
	JSB	TRIMR		;TRIM RECORD AS REQUIRED
	MOVL	R9,R7		;COPY RESULT POINTER
	MOVL	(SP),R9		;RELOAD POINTER TO TRBLK
;
;      LOOP TO CHASE TO END OF TRBLK CHAIN AND STORE VALUE
;
ACS08::	MOVL	R9,R10		;SAVE POINTER TO THIS TRBLK
	MOVL	4*TRNXT(R9),R9	;LOAD FORWARD POINTER
	CMPL	(R9),#B$TRT	;LOOP IF THIS IS ANOTHER TRBLK
	BEQLU	ACS08
	MOVL	R7,4*TRNXT(R10)	;ELSE STORE RESULT AT END OF CHAIN
	MOVL	(SP)+,R9	;RESTORE INITIAL TRBLK POINTER
	MOVL	(SP)+,R6	;RESTORE NAME OFFSET
	MOVL	(SP)+,R10	;RESTORE NAME BASE POINTER
;
;      COME HERE TO MOVE TO NEXT TRBLK
;
ACS09::	MOVL	4*TRNXT(R9),R9	;LOAD FORWARD PTR TO NEXT VALUE
	JMP	ACS02		;BACK TO CHECK IF TRAPPED
;
;      HERE TO CHECK FOR ACCESS TRACE TRBLK
;
ACS10::	CMPL	R7,#TRTAC	;LOOP BACK IF NOT ACCESS TRACE
	BEQLU	5114$
	JMP	ACS09
5114$:
	TSTL	KVTRA		;IGNORE ACCESS TRACE IF TRACE OFF
	BNEQU	5115$
	JMP	ACS09
5115$:
	DECL	KVTRA		;ELSE DECREMENT TRACE COUNT
	TSTL	4*TRFNC(R9)	;JUMP IF PRINT TRACE
	BEQLU	ACS11
	.PAGE
;
;      ACESS (CONTINUED)
;
;      HERE FOR FULL FUNCTION TRACE
;
	JSB	TRXEQ		;CALL ROUTINE TO EXECUTE TRACE
	JMP	ACS09		;JUMP FOR NEXT TRBLK
;
;      HERE FOR CASE OF PRINT TRACE
;
ACS11::	JSB	PRTSN		;PRINT STATEMENT NUMBER
	JSB	PRTNV		;PRINT NAME = VALUE
	JMP	ACS09		;JUMP BACK FOR NEXT TRBLK
;
;      HERE FOR KEYWORD VARIABLE
;
ACS12::	MOVL	4*KVNUM(R10),R9	;LOAD KEYWORD NUMBER
	CMPL	R9,#K$V$$	;JUMP IF NOT ONE WORD VALUE
	BGEQU	ACS14
	MOVL	L^KVABE(R9),R5	;ELSE LOAD VALUE AS INTEGER
;
;      COMMON EXIT WITH KEYWORD VALUE AS INTEGER IN (IA)
;
ACS13::	JSB	ICBLD		;BUILD ICBLK
	JMP	ACS18		;JUMP TO EXIT
;
;      HERE IF NOT ONE WORD KEYWORD VALUE
;
ACS14::	CMPL	R9,#K$S$$	;JUMP IF SPECIAL CASE
	BGEQU	ACS15
	SUBL2	#K$V$$,R9	;ELSE GET OFFSET
	ADDL2	#NDABO,R9	;POINT TO PATTERN VALUE
	JMP	ACS18		;JUMP TO EXIT
;
;      HERE IF SPECIAL KEYWORD CASE
;
ACS15::	MOVL	KVRTN,R10	;LOAD RTNTYPE IN CASE
	MOVL	KVSTL,R5	;LOAD STLIMIT IN CASE
	SUBL2	#K$S$$,R9	;GET CASE NUMBER
	BSW	R9,5		;SWITCH ON KEYWORD NUMBER
	IFF	K$$AL,ACS16	;JUMP IF ALPHABET
	IFF	K$$RT,ACS17	;RTNTYPE
	IFF	K$$SC,ACS19	;STCOUNT
	IFF	K$$SL,ACS13	;STLIMIT
	IFF	K$$ET,ACS20	;ERRTEXT
	ESW			;END SWITCH ON KEYWORD NUMBER
	.PAGE
;
;      ACESS (CONTINUED)
;
;      ALPHABET
;
ACS16::	MOVL	KVALP,R10	;LOAD POINTER TO ALPHABET STRING
;
;      RTNTYPE MERGES HERE
;
ACS17::	MOVL	R10,R9		;COPY STRING PTR TO PROPER REG
;
;      COMMON RETURN POINT
;
ACS18::	ADDL2	#4*1,(SP)	;RETURN TO ACESS CALLER
	RSB
;
;      HERE FOR STCOUNT (IA HAS STLIMIT)
;
ACS19::	SUBL2	KVSTC,R5	;STCOUNT = LIMIT - LEFT
	JMP	ACS13		;MERGE BACK WITH INTEGER RESULT
;
;      ERRTEXT
;
ACS20::	MOVL	R$ETX,R9	;GET ERRTEXT STRING
	JMP	ACS18		;MERGE WITH RESULT
;
;      HERE TO READ A RECORD FROM TERMINAL
;
ACS21::	MOVL	#RILEN,R6	;BUFFER LENGTH
	JSB	ALOCS		;ALLOCATE BUFFER
	JSB	SYSRI		;READ RECORD
	.ADDRESS ACS03		;ENDFILE
	JMP	ACS07		;MERGE WITH RECORD READ
;
;      ERROR RETURNS
;
ACS22::	MOVL	R9,DNAMP	;POP UNUSED SCBLK
	JMP	ERROR_202	;INPUT FROM FILE CAUSED NON-RECOVERABLE ERROR
;
ACS23::	MOVL	R9,DNAMP	;POP UNUSED SCBLK
	JMP	ERROR_203	;INPUT FILE RECORD HAS INCORRECT FORMAT
	;ENP			;END PROCEDURE ACESS
	.PAGE
;
;      ACOMP -- COMPARE TWO ARITHMETIC VALUES
;
;      1(XS)                 FIRST ARGUMENT
;      0(XS)                 SECOND ARGUMENT
;      JSR  ACOMP            CALL TO COMPARE VALUES
;      PPM  LOC              TRANSFER LOC IF ARG1 IS NON-NUMERIC
;      PPM  LOC              TRANSFER LOC IF ARG2 IS NON-NUMERIC
;      PPM  LOC              TRANSFER LOC FOR ARG1 LT ARG2
;      PPM  LOC              TRANSFER LOC FOR ARG1 EQ ARG2
;      PPM  LOC              TRANSFER LOC FOR ARG1 GT ARG2
;      (NORMAL RETURN IS NEVER GIVEN)
;      (WA,WB,WC,IA,RA)      DESTROYED
;      (XL,XR)               DESTROYED
;
	.ENABLE	LOCAL_BLOCK
ACOMP::	MOVL	(SP)+,ACOMP_SAVE;ENTRY POINT
	.SAVE_PSECT LOCAL_BLOCK
	.PSECT	PRC_SAVE,NOEXE
ACOMP_SAVE::.LONG	0
	.RESTORE_PSECT
	JSB	ARITH		;LOAD ARITHMETIC OPERANDS
	.ADDRESS ACMP7		;JUMP IF FIRST ARG NON-NUMERIC
	.ADDRESS ACMP8		;JUMP IF SECOND ARG NON-NUMERIC
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	.ADDRESS ACMP4		;JUMP IF REAL ARGUMENTS
	.ENDC
;
;      HERE FOR INTEGER ARGUMENTS
;
	SUBL2	4*ICVAL(R10),R5	;SUBTRACT TO COMPARE
	BVS	ACMP3
	TSTL	R5		;ELSE JUMP IF ARG1 LT ARG2
	BLSS	ACMP5
	TSTL	R5		;JUMP IF ARG1 EQ ARG2
	BEQL	ACMP2
;
;      HERE IF ARG1 GT ARG2
;
ACMP1::	ADDL3	#4*4,ACOMP_SAVE,R11 ;TAKE GT EXIT
	JMP	@(R11)+
;
;      HERE IF ARG1 EQ ARG2
;
ACMP2::	ADDL3	#4*3,ACOMP_SAVE,R11 ;TAKE EQ EXIT
	JMP	@(R11)+
	.PAGE
;
;      ACOMP (CONTINUED)
;
;      HERE FOR INTEGER OVERFLOW ON SUBTRACT
;
ACMP3::	MOVL	4*ICVAL(R10),R5	;LOAD SECOND ARGUMENT
	BLSS	ACMP1
	JMP	ACMP5		;ELSE LT
	.IF NOT_EQUAL CNRA
	.IF_FALSE
;
;      HERE FOR REAL OPERANDS
;
ACMP4::	SUBF2	4*RCVAL(R10),R2	;SUBTRACT TO COMPARE
	BVS	ACMP6
	TSTF	R2		;ELSE JUMP IF ARG1 GT
	BGTR	ACMP1
	TSTF	R2		;JUMP IF ARG1 EQ ARG2
	BEQL	ACMP2
	.ENDC
;
;      HERE IF ARG1 LT ARG2
;
ACMP5::	ADDL3	#4*2,ACOMP_SAVE,R11 ;TAKE LT EXIT
	JMP	@(R11)+
	.IF NOT_EQUAL CNRA
	.IF_FALSE
;
;      HERE IF OVERFLOW ON REAL SUBTRACTION
;
ACMP6::	MOVF	4*RCVAL(R10),R2	;RELOAD ARG2
	TSTF	R2		;GT IF NEGATIVE
	BLSS	ACMP1
	JMP	ACMP5		;ELSE LT
	.ENDC
;
;      HERE IF ARG1 NON-NUMERIC
;
ACMP7::	MOVL	ACOMP_SAVE,R11	;TAKE ERROR EXIT
	JMP	@(R11)+
;
;      HERE IF ARG2 NON-NUMERIC
;
ACMP8::	ADDL3	#4*1,ACOMP_SAVE,R11 ;TAKE ERROR EXIT
	JMP	@(R11)+
	;ENP			;END PROCEDURE ACOMP
	.PAGE
;
;      ALLOC                 ALLOCATE BLOCK OF DYNAMIC STORAGE
;
;      (WA)                  LENGTH REQUIRED IN BYTES
;      JSR  ALLOC            CALL TO ALLOCATE BLOCK
;      (XR)                  POINTER TO ALLOCATED BLOCK
;
;      A POSSIBLE ALTERNATIVE TO AOV .. AND FOLLOWING STMT IS -
;      MOV  DNAME,XR .  SUB  WA,XR .  BLO XR,DNAMP,ALOC2 .
;      MOV  DNAMP,XR .  ADD  WA,XR
;
	.ENABLE	LOCAL_BLOCK
ALLOC::	;PRC			;ENTRY POINT
;
;      COMMON EXIT POINT
;
ALOC1::	MOVL	DNAMP,R9	;POINT TO NEXT AVAILABLE LOC
	AOV	R6,R9,ALOC2	;POINT PAST ALLOCATED BLOCK
	CMPL	R9,DNAME	;JUMP IF NOT ENOUGH ROOM
	BGTRU	ALOC2
	MOVL	R9,DNAMP	;STORE NEW POINTER
	SUBL2	R6,R9		;POINT BACK TO START OF ALLOCATED BK
	RSB			;RETURN TO CALLER
;
;      HERE IF INSUFFICIENT ROOM, TRY A GARBAGE COLLECTION
;
ALOC2::	MOVL	R7,ALLSV	;SAVE WB
	CLRL	R7		;SET NO UPWARD MOVE FOR GBCOL
	JSB	GBCOL		;GARBAGE COLLECT
;
;      SEE IF ROOM AFTER GBCOL OR SYSMM CALL
;
ALOC3::	MOVL	DNAMP,R9	;POINT TO FIRST AVAILABLE LOC
	AOV	R6,R9,ALC3A	;POINT PAST NEW BLOCK
	CMPL	R9,DNAME	;JUMP IF THERE IS ROOM NOW
	BLEQU	ALOC4
;
;      FAILED AGAIN, SEE IF WE CAN GET MORE CORE
;
ALC3A::	JSB	SYSMM		;TRY TO GET MORE MEMORY
	MOVAL	0[R9],R9	;CONVERT TO BAUS [SGD05]
	ADDL2	R9,DNAME	;BUMP PTR BY AMOUNT OBTAINED
	TSTL	R9		;JUMP IF GOT MORE CORE
	BNEQU	ALOC3
	ADDL2	RSMEM,DNAME	;GET THE RESERVE MEMORY
	CLRL	RSMEM		;ONLY PERMISSIBLE ONCE
	INCL	ERRFT		;FATAL ERROR
	JMP	ERROR_204	;MEMORY OVERFLOW
	.PAGE
;
;      HERE AFTER SUCCESSFUL GARBAGE COLLECTION
;
ALOC4::	MOVL	R5,ALLIA	;SAVE IA
	MOVL	DNAME,R7	;GET DYNAMIC END ADRS
	SUBL2	DNAMP,R7	;COMPUTE FREE STORE
	ASHL	#-2,R7,R7	;CONVERT BYTES TO WORDS
	MOVL	R7,R5		;PUT FREE STORE IN IA
	MULL2	ALFSF,R5	;MULTIPLY BY FREE STORE FACTOR
	BVS	ALOC5
	MOVL	DNAME,R7	;DYNAMIC END ADRS
	SUBL2	DNAMB,R7	;COMPUTE TOTAL AMOUNT OF DYNAMIC
	ASHL	#-2,R7,R7	;CONVERT TO WORDS
	MOVL	R7,ALDYN	;STORE IT
	SUBL2	ALDYN,R5	;SUBTRACT FROM SCALED UP FREE STORE
	BGTR	ALOC5
	JSB	SYSMM		;TRY TO GET MORE STORE
	MOVAL	0[R9],R9	;CONVERT TO BAUS [SGD05]
	ADDL2	R9,DNAME	;ADJUST DYNAMIC END ADRS
;
;      MERGE TO RESTORE IA AND WB
;
ALOC5::	MOVL	ALLIA,R5	;RECOVER IA
	MOVL	ALLSV,R7	;RESTORE WB
	JMP	ALOC1		;JUMP BACK TO EXIT
	;ENP			;END PROCEDURE ALLOC
	.PAGE
;
;      ALOCS -- ALLOCATE STRING BLOCK
;
;      ALOCS IS USED TO BUILD A FRAME FOR A STRING BLOCK INTO
;      WHICH THE ACTUAL CHARACTERS ARE PLACED BY THE CALLER.
;      ALL STRINGS ARE CREATED WITH A CALL TO ALOCS (THE
;      EXCEPTIONS OCCUR IN TRIMR AND S$RPL PROCEDURES).
;
;      (WA)                  LENGTH OF STRING TO BE ALLOCATED
;      JSR  ALOCS            CALL TO ALLOCATE SCBLK
;      (XR)                  POINTER TO RESULTING SCBLK
;      (WA)                  DESTROYED
;      (WC)                  CHARACTER COUNT (ENTRY VALUE OF WA)
;
;      THE RESULTING SCBLK HAS THE TYPE WORD AND THE LENGTH
;      FILLED IN AND THE LAST WORD IS CLEARED TO ZERO CHARACTERS
;      TO ENSURE CORRECT RIGHT PADDING OF THE FINAL WORD.
;
	.ENABLE	LOCAL_BLOCK
ALOCS::	;PRC			;ENTRY POINT
	CMPL	R6,KVMXL	;JUMP IF LENGTH EXCEEEDS MAXLENGTH
	BGTRU	ALCS2
	MOVL	R6,R8		;ELSE COPY LENGTH
	MOVAB	3+<4*SCSI$>(R6),R6 ;COMPUTE LENGTH OF SCBLK IN BYTES
	BICL2	#3,R6
	MOVL	DNAMP,R9	;POINT TO NEXT AVAILABLE LOCATION
	AOV	R6,R9,ALCS0	;POINT PAST BLOCK
	CMPL	R9,DNAME	;JUMP IF THERE IS ROOM
	BLEQU	ALCS1
;
;      INSUFFICIENT MEMORY
;
ALCS0::	CLRL	R9		;ELSE CLEAR GARBAGE XR VALUE
	JSB	ALLOC		;AND USE STANDARD ALLOCATOR
	ADDL2	R6,R9		;POINT PAST END OF BLOCK TO MERGE
;
;      MERGE HERE WITH XR POINTING BEYOND NEW BLOCK
;
ALCS1::	MOVL	R9,DNAMP	;SET UPDATED STORAGE POINTER
	CLRL	-(R9)		;STORE ZERO CHARS IN LAST WORD
	SUBL2	#4,R6		;DECREMENT LENGTH
	SUBL2	R6,R9		;POINT BACK TO START OF BLOCK
	MOVL	#B$SCL,(R9)	;SET TYPE WORD
	MOVL	R8,4*SCLEN(R9)	;STORE LENGTH IN CHARS
	RSB			;RETURN TO ALOCS CALLER
;
;      COME HERE IF STRING IS TOO LONG
;
ALCS2::	JMP	ERROR_205	;STRING LENGTH EXCEEDS VALUE OF MAXLNGTH KEYWORD
	;ENP			;END PROCEDURE ALOCS
	.PAGE
;
;      ALOST -- ALLOCATE SPACE IN STATIC REGION
;
;      (WA)                  LENGTH REQUIRED IN BYTES
;      JSR  ALOST            CALL TO ALLOCATE SPACE
;      (XR)                  POINTER TO ALLOCATED BLOCK
;      (WB)                  DESTROYED
;
;      NOTE THAT THE CODING ENSURES THAT THE RESULTING VALUE
;      OF STATE IS ALWAYS LESS THAN DNAMB. THIS FACT IS USED
;      IN TESTING A VARIABLE NAME FOR BEING IN THE STATIC REGION
;
	.ENABLE	LOCAL_BLOCK
ALOST::	;PRC			;ENTRY POINT
;
;      MERGE BACK HERE AFTER ALLOCATING NEW CHUNK
;
ALST1::	MOVL	STATE,R9	;POINT TO CURRENT END OF AREA
	AOV	R6,R9,ALST2	;POINT BEYOND PROPOSED BLOCK
	CMPL	R9,DNAMB	;JUMP IF OVERLAP WITH DYNAMIC AREA
	BGEQU	ALST2
	MOVL	R9,STATE	;ELSE STORE NEW POINTER
	SUBL2	R6,R9		;POINT BACK TO START OF BLOCK
	RSB			;RETURN TO ALOST CALLER
;
;      HERE IF NO ROOM, PREPARE TO MOVE DYNAMIC STORAGE UP
;
ALST2::	MOVL	R6,ALSTA	;SAVE WA
	CMPL	R6,#4*E$STS	;SKIP IF REQUESTED CHUNK IS LARGE
	BGEQU	ALST3
	MOVL	#4*E$STS,R6	;ELSE SET TO GET LARGE ENOUGH CHUNK
;
;      HERE WITH AMOUNT TO MOVE UP IN WA
;
ALST3::	JSB	ALLOC		;ALLOCATE BLOCK TO ENSURE ROOM
	MOVL	R9,DNAMP	;AND DELETE IT
	MOVL	R6,R7		;COPY MOVE UP AMOUNT
	JSB	GBCOL		;CALL GBCOL TO MOVE DYNAMIC AREA UP
	MOVL	ALSTA,R6	;RESTORE WA
	JMP	ALST1		;LOOP BACK TO TRY AGAIN
	;ENP			;END PROCEDURE ALOST
	.PAGE
;
;      ARITH -- FETCH ARITHMETIC OPERANDS
;
;      ARITH IS USED BY FUNCTIONS AND OPERATORS WHICH EXPECT
;      TWO NUMERIC ARGUMENTS (OPERANDS) WHICH MUST BOTH BE
;      INTEGER OR BOTH BE REAL. ARITH FETCHES TWO ARGUMENTS FROM
;      THE STACK AND PERFORMS ANY NECESSARY CONVERSIONS.
;
;      1(XS)                 FIRST ARGUMENT (LEFT OPERAND)
;      0(XS)                 SECOND ARGUMENT (RIGHT OPERAND)
;      JSR  ARITH            CALL TO FETCH NUMERIC ARGUMENTS
;      PPM  LOC              TRANSFER LOC FOR OPND 1 NON-NUMERIC
;      PPM  LOC              TRANSFER LOC FOR OPND 2 NON-NUMERIC
	.IF NOT_EQUAL CNRA
	.IF_FALSE
;      PPM  LOC              TRANSFER LOC FOR REAL OPERANDS
	.ENDC
;
;      FOR INTEGER ARGS, CONTROL RETURNS PAST THE PARAMETERS
;
;      (IA)                  LEFT OPERAND VALUE
;      (XR)                  PTR TO ICBLK FOR LEFT OPERAND
;      (XL)                  PTR TO ICBLK FOR RIGHT OPERAND
;      (XS)                  POPPED TWICE
;      (WA,WB,RA)            DESTROYED
	.IF NOT_EQUAL CNRA
	.IF_FALSE
;
;      FOR REAL ARGUMENTS, CONTROL RETURNS TO THE LOCATION
;      SPECIFIED BY THE THIRD PARAMETER.
;
;      (RA)                  LEFT OPERAND VALUE
;      (XR)                  PTR TO RCBLK FOR LEFT OPERAND
;      (XL)                  PTR TO RCBLK FOR RIGHT OPERAND
;      (WA,WB,WC)            DESTROYED
;      (XS)                  POPPED TWICE
	.ENDC
	.PAGE
;
;      ARITH (CONTINUED)
;
;      ENTRY POINT
;
	.IF NOT_EQUAL CNRA
	.ENABLE	LOCAL_BLOCK
ARITH::	MOVL	(SP)+,ARITH_SAVE;ENTRY POINT
	.SAVE_PSECT LOCAL_BLOCK
	.PSECT	PRC_SAVE,NOEXE
ARITH_SAVE::.LONG	0
	.RESTORE_PSECT
	.IF_FALSE
	.ENABLE	LOCAL_BLOCK
ARITH::	MOVL	(SP)+,ARITH_SAVE;ENTRY POINT
	.SAVE_PSECT LOCAL_BLOCK
	.PSECT	PRC_SAVE,NOEXE
ARITH_SAVE::.LONG	0
	.RESTORE_PSECT
	.ENDC
	MOVL	(SP)+,R10	;LOAD RIGHT OPERAND
	MOVL	(SP)+,R9	;LOAD LEFT OPERAND
	MOVL	(R10),R6	;GET RIGHT OPERAND TYPE WORD
	CMPL	R6,#B$ICL	;JUMP IF INTEGER
	BEQLU	ARTH1
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	CMPL	R6,#B$RCL	;JUMP IF REAL
	BEQLU	ARTH4
	.ENDC
	MOVL	R9,-(SP)	;ELSE REPLACE LEFT ARG ON STACK
	MOVL	R10,R9		;COPY LEFT ARG POINTER
	JSB	GTNUM		;CONVERT TO NUMERIC
	.ADDRESS ARTH6		;JUMP IF UNCONVERTIBLE
	MOVL	R9,R10		;ELSE COPY CONVERTED RESULT
	MOVL	(R10),R6	;GET RIGHT OPERAND TYPE WORD
	MOVL	(SP)+,R9	;RELOAD LEFT ARGUMENT
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	CMPL	R6,#B$RCL	;JUMP IF RIGHT ARG IS REAL
	BEQLU	ARTH4
	.ENDC
;
;      HERE IF RIGHT ARG IS AN INTEGER
;
ARTH1::	CMPL	(R9),#B$ICL	;JUMP IF LEFT ARG NOT INTEGER
	BNEQU	ARTH3
;
;      EXIT FOR INTEGER CASE
;
ARTH2::	MOVL	4*ICVAL(R9),R5	;LOAD LEFT OPERAND VALUE
	ADDL3	#4*3,ARITH_SAVE,R11 ;RETURN TO ARITH CALLER
	JMP	(R11)
;
;      HERE FOR RIGHT OPERAND INTEGER, LEFT OPERAND NOT
;
ARTH3::	JSB	GTNUM		;CONVERT LEFT ARG TO NUMERIC
	.ADDRESS ARTH7		;JUMP IF NOT CONVERTIBLE
	CMPL	R6,#B$ICL	;JUMP BACK IF INTEGER-INTEGER
	BEQLU	ARTH2
	.IF NOT_EQUAL CNRA
	.IF_FALSE
;
;      HERE WE MUST CONVERT REAL-INTEGER TO REAL-REAL
;
	MOVL	R9,-(SP)	;PUT LEFT ARG BACK ON STACK
	MOVL	4*ICVAL(R10),R5	;LOAD RIGHT ARGUMENT VALUE
	CVTLF	R5,R2		;CONVERT TO REAL
	JSB	RCBLD		;GET REAL BLOCK FOR RIGHT ARG, MERGE
	MOVL	R9,R10		;COPY RIGHT ARG PTR
	MOVL	(SP)+,R9	;LOAD LEFT ARGUMENT
	JMP	ARTH5		;MERGE FOR REAL-REAL CASE
	.PAGE
;
;      ARITH (CONTINUED)
;
;      HERE IF RIGHT ARGUMENT IS REAL
;
ARTH4::	CMPL	(R9),#B$RCL	;JUMP IF LEFT ARG REAL
	BEQLU	ARTH5
	JSB	GTREA		;ELSE CONVERT TO REAL
	.ADDRESS ARTH7		;ERROR IF UNCONVERTIBLE
;
;      HERE FOR REAL-REAL
;
ARTH5::	MOVF	4*RCVAL(R9),R2	;LOAD LEFT OPERAND VALUE
	ADDL3	#4*2,ARITH_SAVE,R11 ;TAKE REAL-REAL EXIT
	JMP	@(R11)+
	.ENDC
;
;      HERE FOR ERROR CONVERTING RIGHT ARGUMENT
;
ARTH6::	ADDL2	#4,SP		;POP UNWANTED LEFT ARG
	ADDL3	#4*1,ARITH_SAVE,R11 ;TAKE APPROPRIATE ERROR EXIT
	JMP	@(R11)+
;
;      HERE FOR ERROR CONVERTING LEFT OPERAND
;
ARTH7::	MOVL	ARITH_SAVE,R11	;TAKE APPROPRIATE ERROR RETURN
	JMP	@(R11)+
	;ENP			;END PROCEDURE ARITH
	.PAGE
;
;      ASIGN -- PERFORM ASSIGNMENT
;
;      ASIGN PERFORMS THE ASSIGNMENT OF A VALUE TO A VARIABLE
;      WITH APPROPRIATE CHECKS FOR OUTPUT ASSOCIATIONS AND
;      VALUE TRACE ASSOCIATIONS WHICH ARE EXECUTED AS REQUIRED.
;      ASIGN ALSO HANDLES THE SPECIAL CASES OF ASSIGNMENT TO
;      PATTERN AND EXPRESSION VARIABLES.
;
;      (WB)                  VALUE TO BE ASSIGNED
;      (XL)                  BASE POINTER FOR VARIABLE
;      (WA)                  OFFSET FOR VARIABLE
;      JSR  ASIGN            CALL TO ASSIGN VALUE TO VARIABLE
;      PPM  LOC              TRANSFER LOC FOR FAILURE
;      (XR,XL,WA,WB,WC)      DESTROYED
;      (RA)                  DESTROYED
;
;      FAILURE OCCURS IF THE EVALUATION OF AN EXPRESSION
;      ASSOCIATED WITH AN EXPRESSION VARIABLE FAILS.
;
	.ENABLE	LOCAL_BLOCK
ASIGN::	;PRC			;ENTRY POINT (RECURSIVE)
;
;      MERGE BACK HERE TO ASSIGN RESULT TO EXPRESSION VARIABLE.
;
ASG01::	ADDL2	R6,R10		;POINT TO VARIABLE VALUE
	MOVL	(R10),R9	;LOAD VARIABLE VALUE
	CMPL	(R9),#B$TRT	;JUMP IF TRAPPED
	BEQLU	ASG02
	MOVL	R7,(R10)	;ELSE PERFORM ASSIGNMENT
	CLRL	R10		;CLEAR GARBAGE VALUE IN XL
	ADDL2	#4*1,(SP)	;AND RETURN TO ASIGN CALLER
	RSB
;
;      HERE IF VALUE IS TRAPPED
;
ASG02::	SUBL2	R6,R10		;RESTORE NAME BASE
	CMPL	R9,#TRBKV	;JUMP IF KEYWORD VARIABLE
	BNEQU	5116$
	JMP	ASG14
5116$:
	CMPL	R9,#TRBEV	;JUMP IF NOT EXPRESSION VARIABLE
	BNEQU	ASG04
;
;      HERE FOR ASSIGNMENT TO EXPRESSION VARIABLE
;
	MOVL	4*EVEXP(R10),R9	;POINT TO EXPRESSION
	MOVL	R7,-(SP)	;STORE VALUE TO ASSIGN ON STACK
	MOVL	#NUM01,R7	;SET FOR EVALUATION BY NAME
	JSB	EVALX		;EVALUATE EXPRESSION BY NAME
	.ADDRESS ASG03		;JUMP IF EVALUATION FAILS
	MOVL	(SP)+,R7	;ELSE RELOAD VALUE TO ASSIGN
	JMP	ASG01		;LOOP BACK TO PERFORM ASSIGNMENT
	.PAGE
;
;      ASIGN (CONTINUED)
;
;      HERE FOR FAILURE DURING EXPRESSION EVALUATION
;
ASG03::	ADDL2	#4,SP		;REMOVE STACKED VALUE ENTRY
	MOVL	(SP)+,R11	;TAKE FAILURE EXIT
	JMP	@(R11)+
;
;      HERE IF NOT KEYWORD OR EXPRESSION VARIABLE
;
ASG04::	MOVL	R9,-(SP)	;SAVE PTR TO FIRST TRBLK
;
;      LOOP TO CHASE DOWN TRBLK CHAIN AND ASSIGN VALUE AT END
;
ASG05::	MOVL	R9,R8		;SAVE PTR TO THIS TRBLK
	MOVL	4*TRNXT(R9),R9	;POINT TO NEXT TRBLK
	CMPL	(R9),#B$TRT	;LOOP BACK IF ANOTHER TRBLK
	BEQLU	ASG05
	MOVL	R8,R9		;ELSE POINT BACK TO LAST TRBLK
	MOVL	R7,4*TRVAL(R9)	;STORE VALUE AT END OF CHAIN
	MOVL	(SP)+,R9	;RESTORE PTR TO FIRST TRBLK
;
;      LOOP TO PROCESS TRBLK ENTRIES ON CHAIN
;
ASG06::	MOVL	4*TRTYP(R9),R7	;LOAD TYPE CODE OF TRBLK
	CMPL	R7,#TRTVL	;JUMP IF VALUE TRACE
	BEQLU	ASG08
	CMPL	R7,#TRTOU	;JUMP IF OUTPUT ASSOCIATION
	BEQLU	ASG10
;
;      HERE TO MOVE TO NEXT TRBLK ON CHAIN
;
ASG07::	MOVL	4*TRNXT(R9),R9	;POINT TO NEXT TRBLK ON CHAIN
	CMPL	(R9),#B$TRT	;LOOP BACK IF ANOTHER TRBLK
	BEQLU	ASG06
	ADDL2	#4*1,(SP)	;ELSE END OF CHAIN, RETURN TO CALLER
	RSB
;
;      HERE TO PROCESS VALUE TRACE
;
ASG08::	TSTL	KVTRA		;IGNORE VALUE TRACE IF TRACE OFF
	BEQLU	ASG07
	DECL	KVTRA		;ELSE DECREMENT TRACE COUNT
	TSTL	4*TRFNC(R9)	;JUMP IF PRINT TRACE
	BEQLU	ASG09
	JSB	TRXEQ		;ELSE EXECUTE FUNCTION TRACE
	JMP	ASG07		;AND LOOP BACK
	.PAGE
;
;      ASIGN (CONTINUED)
;
;      HERE FOR PRINT TRACE
;
ASG09::	JSB	PRTSN		;PRINT STATEMENT NUMBER
	JSB	PRTNV		;PRINT NAME = VALUE
	JMP	ASG07		;LOOP BACK FOR NEXT TRBLK
;
;      HERE FOR OUTPUT ASSOCIATION
;
ASG10::	TSTL	KVOUP		;IGNORE OUTPUT ASSOC IF OUTPUT OFF
	BEQLU	ASG07
	MOVL	R9,R10		;ELSE COPY TRBLK POINTER
	MOVL	4*TRVAL(R8),-(SP);STACK VALUE TO OUTPUT [SGD01]
	JSB	GTSTG		;CONVERT TO STRING
	.ADDRESS ASG12		;GET DATATYPE NAME IF UNCONVERTIBLE
;
;      MERGE WITH STRING FOR OUTPUT
;
ASG11::	MOVL	4*TRFPT(R10),R6	;FCBLK PTR
	BEQLU	ASG13
;
;      HERE FOR OUTPUT TO NON-STANDARD OUTPUT FILE
;
	JSB	SYSOU		;CALL SYSTEM OUTPUT ROUTINE
	.ADDRESS ERROR_206	;OUTPUT CAUSED FILE OVERFLOW
	.ADDRESS ERROR_207	;OUTPUT CAUSED NON-RECOVERABLE ERROR
	ADDL2	#4*1,(SP)	;ELSE ALL DONE, RETURN TO CALLER
	RSB
;
;      IF NOT PRINTABLE, GET DATATYPE NAME INSTEAD
;
ASG12::	JSB	DTYPE		;CALL DATATYPE ROUTINE
	JMP	ASG11		;MERGE
;
;      HERE TO PRINT A STRING ON THE PRINTER
;
ASG13::	JSB	PRTST		;PRINT STRING VALUE
	CMPL	4*TRTER(R10),#V$TER ;JUMP IF TERMINAL OUTPUT
	BNEQU	5117$
	JMP	ASG20
5117$:
	JSB	PRTNL		;END OF LINE
	ADDL2	#4*1,(SP)	;RETURN TO CALLER
	RSB
	.PAGE
;
;      ASIGN (CONTINUED)
;
;      HERE FOR KEYWORD ASSIGNMENT
;
ASG14::	MOVL	4*KVNUM(R10),R10;LOAD KEYWORD NUMBER
	CMPL	R10,#K$ETX	;JUMP IF ERRTEXT
	BNEQU	5118$
	JMP	ASG19
5118$:
	MOVL	R7,R9		;COPY VALUE TO BE ASSIGNED
	JSB	GTINT		;CONVERT TO INTEGER
	.ADDRESS ERROR_208	;KEYWORD VALUE ASSIGNED IS NOT INTEGER
	MOVL	4*ICVAL(R9),R5	;ELSE LOAD VALUE
	CMPL	R10,#K$STL	;JUMP IF SPECIAL CASE OF STLIMIT
	BEQLU	ASG16
	MFI	R6,ASG18	;ELSE GET ADDR INTEGER, TEST OVFLOW
	CMPL	R6,MXLEN	;FAIL IF TOO LARGE
	BGEQU	ASG18
	CMPL	R10,#K$ERT	;JUMP IF SPECIAL CASE OF ERRTYPE
	BEQLU	ASG17
	.IF NOT_EQUAL CNPF
	.IF_FALSE
	CMPL	R10,#K$PFL	;JUMP IF SPECIAL CASE OF PROFILE
	BEQLU	ASG21
	.ENDC
	CMPL	R10,#K$P$$	;JUMP UNLESS PROTECTED
	BLSSU	ASG15
	JMP	ERROR_209	;KEYWORD IN ASSIGNMENT IS PROTECTED
;
;      HERE TO DO ASSIGNMENT IF NOT PROTECTED
;
ASG15::	MOVL	R6,L^KVABE(R10)	;STORE NEW VALUE
	ADDL2	#4*1,(SP)	;RETURN TO ASIGN CALLER
	RSB
;
;      HERE FOR SPECIAL CASE OF STLIMIT
;
;      SINCE STCOUNT IS MAINTAINED AS (STLIMIT-STCOUNT)
;      IT IS ALSO NECESSARY TO MODIFY STCOUNT APPROPRIATELY.
;
ASG16::	SUBL2	KVSTL,R5	;SUBTRACT OLD LIMIT
	ADDL2	KVSTC,R5	;ADD OLD COUNTER
	MOVL	R5,KVSTC	;STORE NEW COUNTER VALUE
	MOVL	4*ICVAL(R9),R5	;RELOAD NEW LIMIT VALUE
	MOVL	R5,KVSTL	;STORE NEW LIMIT VALUE
	ADDL2	#4*1,(SP)	;RETURN TO ASIGN CALLER
	RSB
;
;      HERE FOR SPECIAL CASE OF ERRTYPE
;
ASG17::	CMPL	R6,#NINI9	;OK TO SIGNAL IF IN RANGE
	BGTRU	5119$
	JMP	ERROR
5119$:
;
;      HERE IF VALUE ASSIGNED IS OUT OF RANGE
;
ASG18::	JMP	ERROR_210	;KEYWORD VALUE ASSIGNED IS NEGATIVE OR TOO LARGE
;
;      HERE FOR SPECIAL CASE OF ERRTEXT
;
ASG19::	MOVL	R7,-(SP)	;STACK VALUE
	JSB	GTSTG		;CONVERT TO STRING
	.ADDRESS ERROR_211	;VALUE ASSIGNED TO KEYWORD ERRTEXT NOT A STRING
	MOVL	R9,R$ETX	;MAKE ASSIGNMENT
	ADDL2	#4*1,(SP)	;RETURN TO CALLER
	RSB
;
;      PRINT STRING TO TERMINAL
;
ASG20::	JSB	PRTTR		;PRINT
	ADDL2	#4*1,(SP)	;RETURN
	RSB
;
	.IF NOT_EQUAL CNPF
	.IF_FALSE
;      HERE FOR KEYWORD PROFILE
;
ASG21::	CMPL	R6,#NUM02	;MOAN IF NOT 0,1, OR 2
	BGTRU	ASG18
	TSTL	R6		;JUST ASSIGN IF ZERO
	BEQLU	ASG15
	TSTL	PFDMP		;BRANCH IF FIRST ASSIGNMENT
	BEQLU	ASG22
	CMPL	R6,PFDMP	;ALSO IF SAME VALUE AS BEFORE
	BEQLU	ASG23
	JMP	ERROR_268	;INCONSISTENT VALUE ASSIGNED TO KEYWORD PROFILE
;
ASG22::	MOVL	R6,PFDMP	;NOTE VALUE ON FIRST ASSIGNMENT
ASG23::	JSB	SYSTM		;GET THE TIME
	MOVL	R5,PFSTM	;FUDGE SOME KIND OF START TIME
	JMP	ASG15		;AND GO ASSIGN
	.ENDC
	;ENP			;END PROCEDURE ASIGN
	.PAGE
;
;      ASINP -- ASSIGN DURING PATTERN MATCH
;
;      ASINP IS LIKE ASIGN AND HAS A SIMILAR CALLING SEQUENCE
;      AND EFFECT. THE DIFFERENCE IS THAT THE GLOBAL PATTERN
;      VARIABLES ARE SAVED AND RESTORED IF REQUIRED.
;
;      (XL)                  BASE POINTER FOR VARIABLE
;      (WA)                  OFFSET FOR VARIABLE
;      (WB)                  VALUE TO BE ASSIGNED
;      JSR  ASINP            CALL TO ASSIGN VALUE TO VARIABLE
;      PPM  LOC              TRANSFER LOC IF FAILURE
;      (XR,XL)               DESTROYED
;      (WA,WB,WC,RA)         DESTROYED
;
	.ENABLE	LOCAL_BLOCK
ASINP::	;PRC			;ENTRY POINT, RECURSIVE
	ADDL2	R6,R10		;POINT TO VARIABLE
	MOVL	(R10),R9	;LOAD CURRENT CONTENTS
	CMPL	(R9),#B$TRT	;JUMP IF TRAPPED
	BEQLU	ASNP1
	MOVL	R7,(R10)	;ELSE PERFORM ASSIGNMENT
	CLRL	R10		;CLEAR GARBAGE VALUE IN XL
	ADDL2	#4*1,(SP)	;RETURN TO ASINP CALLER
	RSB
;
;      HERE IF VARIABLE IS TRAPPED
;
ASNP1::	SUBL2	R6,R10		;RESTORE BASE POINTER
	MOVL	PMSSL,-(SP)	;STACK SUBJECT STRING LENGTH
	MOVL	PMHBS,-(SP)	;STACK HISTORY STACK BASE PTR
	MOVL	R$PMS,-(SP)	;STACK SUBJECT STRING POINTER
	MOVL	PMDFL,-(SP)	;STACK DOT FLAG
	JSB	ASIGN		;CALL FULL-BLOWN ASSIGNMENT ROUTINE
	.ADDRESS ASNP2		;JUMP IF FAILURE
	MOVL	(SP)+,PMDFL	;RESTORE DOT FLAG
	MOVL	(SP)+,R$PMS	;RESTORE SUBJECT STRING POINTER
	MOVL	(SP)+,PMHBS	;RESTORE HISTORY STACK BASE POINTER
	MOVL	(SP)+,PMSSL	;RESTORE SUBJECT STRING LENGTH
	ADDL2	#4*1,(SP)	;RETURN TO ASINP CALLER
	RSB
;
;      HERE IF FAILURE IN ASIGN CALL
;
ASNP2::	MOVL	(SP)+,PMDFL	;RESTORE DOT FLAG
	MOVL	(SP)+,R$PMS	;RESTORE SUBJECT STRING POINTER
	MOVL	(SP)+,PMHBS	;RESTORE HISTORY STACK BASE POINTER
	MOVL	(SP)+,PMSSL	;RESTORE SUBJECT STRING LENGTH
	MOVL	(SP)+,R11	;TAKE FAILURE EXIT
	JMP	@(R11)+
	;ENP			;END PROCEDURE ASINP
	.PAGE
;
;      BLKLN -- DETERMINE LENGTH OF BLOCK
;
;      BLKLN DETERMINES THE LENGTH OF A BLOCK IN DYNAMIC STORE.
;
;      (WA)                  FIRST WORD OF BLOCK
;      (XR)                  POINTER TO BLOCK
;      JSR  BLKLN            CALL TO GET BLOCK LENGTH
;      (WA)                  LENGTH OF BLOCK IN BYTES
;      (XL)                  DESTROYED
;
;      BLKLN IS USED BY THE GARBAGE COLLECTOR AND IS NOT
;      PERMITTED TO CALL GBCOL DIRECTLY OR INDIRECTLY.
;
;      THE FIRST WORD STORED IN THE BLOCK (I.E. AT XR) MAY
;      BE ANYTHING, BUT THE CONTENTS OF WA MUST BE CORRECT.
;
	.ENABLE	LOCAL_BLOCK
BLKLN::	;PRC			;ENTRY POINT
	MOVL	R6,R10		;COPY FIRST WORD
	MOVZWL	-2(R10),R10	;GET ENTRY ID (BL$XX)
	BSW	R10,BL$$$,BLN00	;SWITCH ON BLOCK TYPE
	IFF	BL$AR,BLN01	;ARBLK
	IFF	BL$CD,BLN01	;CDBLK
	IFF	BL$DF,BLN01	;DFBLK
	IFF	BL$EF,BLN01	;EFBLK
	IFF	BL$EX,BLN01	;EXBLK
	IFF	BL$PF,BLN01	;PFBLK
	IFF	BL$TB,BLN01	;TBBLK
	IFF	BL$VC,BLN01	;VCBLK
	IFF	BL$EV,BLN03	;EVBLK
	IFF	BL$KV,BLN03	;KVBLK
	IFF	BL$P0,BLN02	;P0BLK
	IFF	BL$SE,BLN02	;SEBLK
	IFF	BL$NM,BLN03	;NMBLK
	IFF	BL$P1,BLN03	;P1BLK
	IFF	BL$P2,BLN04	;P2BLK
	IFF	BL$TE,BLN04	;TEBLK
	IFF	BL$FF,BLN05	;FFBLK
	IFF	BL$TR,BLN05	;TRBLK
	IFF	BL$CT,BLN06	;CTBLK
	IFF	BL$IC,BLN07	;ICBLK
	IFF	BL$PD,BLN08	;PDBLK
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	IFF	BL$RC,BLN09	;RCBLK
	.ENDC
	IFF	BL$SC,BLN10	;SCBLK
	ESW			;END OF JUMP TABLE ON BLOCK TYPE
	.PAGE
;
;      BLKLN (CONTINUED)
;
;      HERE FOR BLOCKS WITH LENGTH IN SECOND WORD
;
BLN00::	MOVL	4*1(R9),R6	;LOAD LENGTH
	RSB			;RETURN TO BLKLN CALLER
;
;      HERE FOR LENGTH IN THIRD WORD (AR,CD,DF,EF,EX,PF,TB,VC)
;
BLN01::	MOVL	4*2(R9),R6	;LOAD LENGTH FROM THIRD WORD
	RSB			;RETURN TO BLKLN CALLER
;
;      HERE FOR TWO WORD BLOCKS (P0,SE)
;
BLN02::	MOVL	#4*NUM02,R6	;LOAD LENGTH (TWO WORDS)
	RSB			;RETURN TO BLKLN CALLER
;
;      HERE FOR THREE WORD BLOCKS (NM,P1,EV,KV)
;
BLN03::	MOVL	#4*NUM03,R6	;LOAD LENGTH (THREE WORDS)
	RSB			;RETURN TO BLKLN CALLER
;
;      HERE FOR FOUR WORD BLOCKS (P2,TE)
;
BLN04::	MOVL	#4*NUM04,R6	;LOAD LENGTH (FOUR WORDS)
	RSB			;RETURN TO BLKLN CALLER
;
;      HERE FOR FIVE WORD BLOCKS (FF,TR)
;
BLN05::	MOVL	#4*NUM05,R6	;LOAD LENGTH
	RSB			;RETURN TO BLKLN CALLER
	.PAGE
;
;      BLKLN (CONTINUED)
;
;      HERE FOR CTBLK
;
BLN06::	MOVL	#4*CTSI$,R6	;SET SIZE OF CTBLK
	RSB			;RETURN TO BLKLN CALLER
;
;      HERE FOR ICBLK
;
BLN07::	MOVL	#4*ICSI$,R6	;SET SIZE OF ICBLK
	RSB			;RETURN TO BLKLN CALLER
;
;      HERE FOR PDBLK
;
BLN08::	MOVL	4*PDDFP(R9),R10	;POINT TO DFBLK
	MOVL	4*DFPDL(R10),R6	;LOAD PDBLK LENGTH FROM DFBLK
	RSB			;RETURN TO BLKLN CALLER
	.IF NOT_EQUAL CNRA
	.IF_FALSE
;
;      HERE FOR RCBLK
;
BLN09::	MOVL	#4*RCSI$,R6	;SET SIZE OF RCBLK
	RSB			;RETURN TO BLKLN CALLER
	.ENDC
;
;      HERE FOR SCBLK
;
BLN10::	MOVL	4*SCLEN(R9),R6	;LOAD LENGTH IN CHARACTERS
	MOVAB	3+<4*SCSI$>(R6),R6 ;CALCULATE LENGTH IN BYTES
	BICL2	#3,R6
	RSB			;RETURN TO BLKLN CALLER
	;ENP			;END PROCEDURE BLKLN
	.PAGE
;
;      COPYB -- COPY A BLOCK
;
;      (XS)                  BLOCK TO BE COPIED
;      JSR  COPYB            CALL TO COPY BLOCK
;      PPM  LOC              RETURN IF BLOCK HAS NO IDVAL FIELD
;                            NORMAL RETURN IF IDVAL FIELD
;      (XR)                  COPY OF BLOCK
;      (XS)                  POPPED
;      (XL,WA,WB,WC)         DESTROYED
;
	.ENABLE	LOCAL_BLOCK
COPYB::	MOVL	(SP)+,COPYB_SAVE;ENTRY POINT
	.SAVE_PSECT LOCAL_BLOCK
	.PSECT	PRC_SAVE,NOEXE
COPYB_SAVE::.LONG	0
	.RESTORE_PSECT
	MOVL	(SP),R9		;LOAD ARGUMENT
	CMPL	R9,#NULLS	;RETURN ARGUMENT IF IT IS NULL
	BNEQU	5120$
	JMP	COP10
5120$:
	MOVL	(R9),R6		;ELSE LOAD TYPE WORD
	MOVL	R6,R7		;COPY TYPE WORD
	JSB	BLKLN		;GET LENGTH OF ARGUMENT BLOCK
	MOVL	R9,R10		;COPY POINTER
	JSB	ALLOC		;ALLOCATE BLOCK OF SAME SIZE
	MOVL	R9,(SP)		;STORE POINTER TO COPY
	MVW			;COPY CONTENTS OF OLD BLOCK TO NEW
	MOVL	(SP),R9		;RELOAD POINTER TO START OF COPY
	CMPL	R7,#B$TBT	;JUMP IF TABLE
	BEQLU	COP05
	CMPL	R7,#B$VCT	;JUMP IF VECTOR
	BEQLU	COP01
	CMPL	R7,#B$PDT	;JUMP IF PROGRAM DEFINED
	BEQLU	COP01
	CMPL	R7,#B$ART	;RETURN COPY IF NOT ARRAY
	BEQLU	5121$
	JMP	COP10
5121$:
;
;      HERE FOR ARRAY (ARBLK)
;
	ADDL2	4*AROFS(R9),R9	;POINT TO PROTOTYPE FIELD
	JMP	COP02		;JUMP TO MERGE
;
;      HERE FOR VECTOR, PROGRAM DEFINED
;
COP01::	ADDL2	#4*PDFLD,R9	;POINT TO PDFLD = VCVLS
;
;      MERGE HERE FOR ARBLK, VCBLK, PDBLK TO DELETE TRAP
;      BLOCKS FROM ALL VALUE FIELDS (THE COPY IS UNTRAPPED)
;
COP02::	MOVL	(R9),R10	;LOAD NEXT POINTER
;
;      LOOP TO GET VALUE AT END OF TRBLK CHAIN
;
COP03::	CMPL	(R10),#B$TRT	;JUMP IF NOT TRAPPED
	BNEQU	COP04
	MOVL	4*TRVAL(R10),R10;ELSE POINT TO NEXT VALUE
	JMP	COP03		;AND LOOP BACK
	.PAGE
;
;      COPYB (CONTINUED)
;
;      HERE WITH UNTRAPPED VALUE IN XL
;
COP04::	MOVL	R10,(R9)+	;STORE REAL VALUE, BUMP POINTER
	CMPL	R9,DNAMP	;LOOP BACK IF MORE TO GO
	BNEQU	COP02
	JMP	COP09		;ELSE JUMP TO EXIT
;
;      HERE TO COPY A TABLE
;
COP05::	CLRL	4*IDVAL(R9)	;ZERO ID TO STOP DUMP BLOWING UP
	MOVL	#4*TESI$,R6	;SET SIZE OF TEBLK
	MOVL	#4*TBBUK,R8	;SET INITIAL OFFSET
;
;      LOOP THROUGH BUCKETS IN TABLE
;
COP06::	MOVL	(SP),R9		;LOAD TABLE POINTER
	CMPL	R8,4*TBLEN(R9)	;JUMP TO EXIT IF ALL DONE
	BEQLU	COP09
	ADDL2	R8,R9		;ELSE POINT TO NEXT BUCKET HEADER
	ADDL2	#4,R8		;BUMP OFFSET
	SUBL2	#4*TENXT,R9	;SUBTRACT LINK OFFSET TO MERGE
;
;      LOOP THROUGH TEBLKS ON ONE CHAIN
;
COP07::	MOVL	4*TENXT(R9),R10	;LOAD POINTER TO NEXT TEBLK
	MOVL	(SP),4*TENXT(R9);SET END OF CHAIN POINTER IN CASE
	CMPL	(R10),#B$TBT	;BACK FOR NEXT BUCKET IF CHAIN END
	BEQLU	COP06
	MOVL	R9,-(SP)	;ELSE STACK PTR TO PREVIOUS BLOCK
	MOVL	#4*TESI$,R6	;SET SIZE OF TEBLK
	JSB	ALLOC		;ALLOCATE NEW TEBLK
	MOVL	R9,R7		;SAVE PTR TO NEW TEBLK
	MVW			;COPY OLD TEBLK TO NEW TEBLK
	MOVL	R7,R9		;RESTORE POINTER TO NEW TEBLK
	MOVL	(SP)+,R10	;RESTORE POINTER TO PREVIOUS BLOCK
	MOVL	R9,4*TENXT(R10)	;LINK NEW BLOCK TO PREVIOUS
	MOVL	R9,R10		;COPY POINTER TO NEW BLOCK
;
;      LOOP TO SET REAL VALUE AFTER REMOVING TRAP CHAIN
;
COP08::	MOVL	4*TEVAL(R10),R10;LOAD VALUE
	CMPL	(R10),#B$TRT	;LOOP BACK IF TRAPPED
	BEQLU	COP08
	MOVL	R10,4*TEVAL(R9)	;STORE UNTRAPPED VALUE IN TEBLK
	JMP	COP07		;BACK FOR NEXT TEBLK
;
;      COMMON EXIT POINT
;
COP09::	MOVL	(SP)+,R9	;LOAD POINTER TO BLOCK
	ADDL3	#4*1,COPYB_SAVE,R11 ;RETURN
	JMP	(R11)
;
;      ALTERNATIVE RETURN
;
COP10::	MOVL	COPYB_SAVE,R11	;RETURN
	JMP	@(R11)+
	;ENP			;END PROCEDURE COPYB
	.PAGE
;
;      CDGCG -- GENERATE CODE FOR COMPLEX GOTO
;
;      USED BY CMPIL TO PROCESS COMPLEX GOTO TREE
;
;      (WB)                  MUST BE COLLECTABLE
;      (XR)                  EXPRESSION POINTER
;      JSR  CDGCG            CALL TO GENERATE COMPLEX GOTO
;      (XL,XR,WA)            DESTROYED
;
	.ENABLE	LOCAL_BLOCK
CDGCG::	;PRC			;ENTRY POINT
	MOVL	4*CMOPN(R9),R10	;GET UNARY GOTO OPERATOR
	MOVL	4*CMROP(R9),R9	;POINT TO GOTO OPERAND
	CMPL	R10,#OPDVD	;JUMP IF DIRECT GOTO
	BEQLU	CDGC2
	JSB	CDGNM		;GENERATE OPND BY NAME IF NOT DIRECT
;
;      RETURN POINT
;
CDGC1::	MOVL	R10,R6		;GOTO OPERATOR
	JSB	CDWRD		;GENERATE IT
	RSB			;RETURN TO CALLER
;
;      DIRECT GOTO
;
CDGC2::	JSB	CDGVL		;GENERATE OPERAND BY VALUE
	JMP	CDGC1		;MERGE TO RETURN
	;ENP			;END PROCEDURE CDGCG
	.PAGE
;
;      CDGEX -- BUILD EXPRESSION BLOCK
;
;      CDGEX IS PASSED A POINTER TO AN EXPRESSION TREE (SEE
;      EXPAN) AND RETURNS AN EXPRESSION (SEBLK OR EXBLK).
;
;      (WC)                  SOME COLLECTABLE VALUE
;      (WB)                  INTEGER IN RANGE 0 LE X LE MXLEN
;      (XL)                  PTR TO EXPRESSION TREE
;      JSR  CDGEX            CALL TO BUILD EXPRESSION
;      (XR)                  PTR TO SEBLK OR EXBLK
;      (XL,WA,WB)            DESTROYED
;
	.ENABLE	LOCAL_BLOCK
CDGEX::	;PRC			;ENTRY POINT, RECURSIVE
	CMPL	(R10),#B$VR$	;JUMP IF NOT VARIABLE
	BLEQU	CDGX1
;
;      HERE FOR NATURAL VARIABLE, BUILD SEBLK
;
	MOVL	#4*SESI$,R6	;SET SIZE OF SEBLK
	JSB	ALLOC		;ALLOCATE SPACE FOR SEBLK
	MOVL	#B$SEL,(R9)	;SET TYPE WORD
	MOVL	R10,4*SEVAR(R9)	;STORE VRBLK POINTER
	RSB			;RETURN TO CDGEX CALLER
;
;      HERE IF NOT VARIABLE, BUILD EXBLK
;
CDGX1::	MOVL	R10,R9		;COPY TREE POINTER
	MOVL	R8,-(SP)	;SAVE WC
	MOVL	CWCOF,R10	;SAVE CURRENT OFFSET
	MOVL	(R9),R6		;GET TYPE WORD
	CMPL	R6,#B$CMT	;CALL BY VALUE IF NOT CMBLK
	BNEQU	CDGX2
	CMPL	4*CMTYP(R9),#C$$NM ;JUMP IF CMBLK ONLY BY VALUE
	BGEQU	CDGX2
	.PAGE
;
;      CDGEX (CONTINUED)
;
;      HERE IF EXPRESSION CAN BE EVALUATED BY NAME
;
	JSB	CDGNM		;GENERATE CODE BY NAME
	MOVL	#ORNM$,R6	;LOAD RETURN BY NAME WORD
	JMP	CDGX3		;MERGE WITH VALUE CASE
;
;      HERE IF EXPRESSION CAN ONLY BE EVALUATED BY VALUE
;
CDGX2::	JSB	CDGVL		;GENERATE CODE BY VALUE
	MOVL	#ORVL$,R6	;LOAD RETURN BY VALUE WORD
;
;      MERGE HERE TO CONSTRUCT EXBLK
;
CDGX3::	JSB	CDWRD		;GENERATE RETURN WORD
	JSB	EXBLD		;BUILD EXBLK
	MOVL	(SP)+,R8	;RESTORE WC
	RSB			;RETURN TO CDGEX CALLER
	;ENP			;END PROCEDURE CDGEX
	.PAGE
;
;      CDGNM -- GENERATE CODE BY NAME
;
;      CDGNM IS CALLED DURING THE COMPILATION PROCESS TO
;      GENERATE CODE BY NAME FOR AN EXPRESSION. SEE CDBLK
;      DESCRIPTION FOR DETAILS OF CODE GENERATED. THE INPUT
;      TO CDGNM IS AN EXPRESSION TREE AS GENERATED BY EXPAN.
;
;      CDGNM IS A RECURSIVE PROCEDURE WHICH PROCEEDS BY MAKING
;      RECURSIVE CALLS TO GENERATE CODE FOR OPERANDS.
;
;      (WB)                  INTEGER IN RANGE 0 LE N LE DNAMB
;      (XR)                  PTR TO TREE GENERATED BY EXPAN
;      (WC)                  CONSTANT FLAG (SEE BELOW)
;      JSR  CDGNM            CALL TO GENERATE CODE BY NAME
;      (XR,WA)               DESTROYED
;      (WC)                  SET NON-ZERO IF NON-CONSTANT
;
;      WC IS SET TO A NON-ZERO (COLLECTABLE) VALUE IF THE
;      EXPRESSION FOR WHICH CODE IS GENERATED CANNOT BE
;      EVALUATED AT COMPILE TIME, OTHERWISE WC IS UNCHANGED.
;
;      THE CODE IS GENERATED IN THE CURRENT CCBLK (SEE CDWRD).
;
	.ENABLE	LOCAL_BLOCK
CDGNM::	;PRC			;ENTRY POINT, RECURSIVE
	MOVL	R10,-(SP)	;SAVE ENTRY XL
	MOVL	R7,-(SP)	;SAVE ENTRY WB
	;CHK			;CHECK FOR STACK OVERFLOW
	MOVL	(R9),R6		;LOAD TYPE WORD
	CMPL	R6,#B$CMT	;JUMP IF CMBLK
	BEQLU	CGN04
	CMPL	R6,#B$VR$	;JUMP IF SIMPLE VARIABLE
	BLSSU	5122$
	JMP	CGN02
5122$:
;
;      MERGE HERE FOR OPERAND YIELDING VALUE (E.G. CONSTANT)
;
CGN01::	JMP	ERROR_212	;SYNTAX ERROR. VALUE USED WHERE NAME IS REQUIRED
;
;      HERE FOR NATURAL VARIABLE REFERENCE
;
CGN02::	MOVL	#OLVN$,R6	;LOAD VARIABLE LOAD CALL
	JSB	CDWRD		;GENERATE IT
	MOVL	R9,R6		;COPY VRBLK POINTER
	JSB	CDWRD		;GENERATE VRBLK POINTER
	.PAGE
;
;      CDGNM (CONTINUED)
;
;      HERE TO EXIT WITH WC SET CORRECTLY
;
CGN03::	MOVL	(SP)+,R7	;RESTORE ENTRY WB
	MOVL	(SP)+,R10	;RESTORE ENTRY XL
	RSB			;RETURN TO CDGNM CALLER
;
;      HERE FOR CMBLK
;
CGN04::	MOVL	R9,R10		;COPY CMBLK POINTER
	MOVL	4*CMTYP(R9),R9	;LOAD CMBLK TYPE
	CMPL	R9,#C$$NM	;ERROR IF NOT NAME OPERAND
	BGEQU	CGN01
	BSW	R9,C$$NM	;ELSE SWITCH ON TYPE
	IFF	C$ARR,CGN05	;ARRAY REFERENCE
	IFF	C$FNC,CGN08	;FUNCTION CALL
	IFF	C$DEF,CGN09	;DEFERRED EXPRESSION
	IFF	C$IND,CGN10	;INDIRECT REFERENCE
	IFF	C$KEY,CGN11	;KEYWORD REFERENCE
	IFF	C$UBO,CGN08	;UNDEFINED BINARY OP
	IFF	C$UUO,CGN08	;UNDEFINED UNARY OP
	ESW			;END SWITCH ON CMBLK TYPE
;
;      HERE TO GENERATE CODE FOR ARRAY REFERENCE
;
CGN05::	MOVL	#4*CMOPN,R7	;POINT TO ARRAY OPERAND
;
;      LOOP TO GENERATE CODE FOR ARRAY OPERAND AND SUBSCRIPTS
;
CGN06::	JSB	CMGEN		;GENERATE CODE FOR NEXT OPERAND
	MOVL	4*CMLEN(R10),R8	;LOAD LENGTH OF CMBLK
	CMPL	R7,R8		;LOOP TILL ALL GENERATED
	BLSSU	CGN06
;
;      GENERATE APPROPRIATE ARRAY CALL
;
	MOVL	#OAON$,R6	;LOAD ONE-SUBSCRIPT CASE CALL
	CMPL	R8,#4*CMAR1	;JUMP TO EXIT IF ONE SUBSCRIPT CASE
	BEQLU	CGN07
	MOVL	#OAMN$,R6	;ELSE LOAD MULTI-SUBSCRIPT CASE CALL
	JSB	CDWRD		;GENERATE CALL
	MOVL	R8,R6		;COPY CMBLK LENGTH
	ASHL	#-2,R6,R6	;CONVERT TO WORDS
	SUBL2	#CMVLS,R6	;CALCULATE NUMBER OF SUBSCRIPTS
	.PAGE
;
;      CDGNM (CONTINUED)
;
;      HERE TO EXIT GENERATING WORD (NON-CONSTANT)
;
CGN07::	MOVL	SP,R8		;SET RESULT NON-CONSTANT
	JSB	CDWRD		;GENERATE WORD
	JMP	CGN03		;BACK TO EXIT
;
;      HERE TO GENERATE CODE FOR FUNCTIONS AND UNDEFINED OPRS
;
CGN08::	MOVL	R10,R9		;COPY CMBLK POINTER
	JSB	CDGVL		;GEN CODE BY VALUE FOR CALL
	MOVL	#OFNE$,R6	;GET EXTRA CALL FOR BY NAME
	JMP	CGN07		;BACK TO GENERATE AND EXIT
;
;      HERE TO GENERATE CODE FOR DEFERED EXPRESSION
;
CGN09::	MOVL	4*CMROP(R10),R9	;CHECK IF VARIABLE
	CMPL	(R9),#B$VR$	;TREAT *VARIABLE AS SIMPLE VAR
	BLSSU	5123$
	JMP	CGN02
5123$:
	MOVL	R9,R10		;COPY PTR TO EXPRESSION TREE
	JSB	CDGEX		;ELSE BUILD EXBLK
	MOVL	#OLEX$,R6	;SET CALL TO LOAD EXPR BY NAME
	JSB	CDWRD		;GENERATE IT
	MOVL	R9,R6		;COPY EXBLK POINTER
	JSB	CDWRD		;GENERATE EXBLK POINTER
	JMP	CGN03		;BACK TO EXIT
;
;      HERE TO GENERATE CODE FOR INDIRECT REFERENCE
;
CGN10::	MOVL	4*CMROP(R10),R9	;GET OPERAND
	JSB	CDGVL		;GENERATE CODE BY VALUE FOR IT
	MOVL	#OINN$,R6	;LOAD CALL FOR INDIRECT BY NAME
	JMP	CGN12		;MERGE
;
;      HERE TO GENERATE CODE FOR KEYWORD REFERENCE
;
CGN11::	MOVL	4*CMROP(R10),R9	;GET OPERAND
	JSB	CDGNM		;GENERATE CODE BY NAME FOR IT
	MOVL	#OKWN$,R6	;LOAD CALL FOR KEYWORD BY NAME
;
;      KEYWORD, INDIRECT MERGE HERE
;
CGN12::	JSB	CDWRD		;GENERATE CODE FOR OPERATOR
	JMP	CGN03		;EXIT
	;ENP			;END PROCEDURE CDGNM
	.PAGE
;
;      CDGVL -- GENERATE CODE BY VALUE
;
;      CDGVL IS CALLED DURING THE COMPILATION PROCESS TO
;      GENERATE CODE BY VALUE FOR AN EXPRESSION. SEE CDBLK
;      DESCRIPTION FOR DETAILS OF THE CODE GENERATED. THE INPUT
;      TO CDGVL IS AN EXPRESSION TREE AS GENERATED BY EXPAN.
;
;      CDGVL IS A RECURSIVE PROCEDURE WHICH PROCEEDS BY MAKING
;      RECURSIVE CALLS TO GENERATE CODE FOR OPERANDS.
;
;      (WB)                  INTEGER IN RANGE 0 LE N LE DNAMB
;      (XR)                  PTR TO TREE GENERATED BY EXPAN
;      (WC)                  CONSTANT FLAG (SEE BELOW)
;      JSR  CDGVL            CALL TO GENERATE CODE BY VALUE
;      (XR,WA)               DESTROYED
;      (WC)                  SET NON-ZERO IF NON-CONSTANT
;
;      WC IS SET TO A NON-ZERO (COLLECTABLE) VALUE IF THE
;      EXPRESSION FOR WHICH CODE IS GENERATED CANNOT BE
;      EVALUATED AT COMPILE TIME, OTHERWISE WC IS UNCHANGED.
;
;      IF WC IS NON-ZERO ON ENTRY, THEN PREEVALUATION IS NOT
;      ALLOWED REGARDLESS OF THE NATURE OF THE OPERAND.
;
;      THE CODE IS GENERATED IN THE CURRENT CCBLK (SEE CDWRD).
;
	.ENABLE	LOCAL_BLOCK
CDGVL::	;PRC			;ENTRY POINT, RECURSIVE
	MOVL	(R9),R6		;LOAD TYPE WORD
	CMPL	R6,#B$CMT	;JUMP IF CMBLK
	BEQLU	CGV01
	CMPL	R6,#B$VRA	;JUMP IF ICBLK, RCBLK, SCBLK
	BLSSU	CGV00
	TSTL	4*VRLEN(R9)	;JUMP IF NOT SYSTEM VARIABLE
	BNEQU	CGVL0
	MOVL	R9,-(SP)	;STACK XR
	MOVL	4*VRSVP(R9),R9	;POINT TO SVBLK
	MOVL	4*SVBIT(R9),R6	;GET SVBLK PROPERTY BITS
	MOVL	(SP)+,R9	;RECOVER XR
	MCOML	BTCKW,R11	;CHECK IF CONSTANT KEYWORD
	BICL2	R11,R6
	BNEQU	CGV00
;
;      HERE FOR VARIABLE VALUE REFERENCE
;
CGVL0::	MOVL	SP,R8		;INDICATE NON-CONSTANT VALUE
;
;      MERGE HERE FOR SIMPLE CONSTANT (ICBLK,RCBLK,SCBLK)
;      AND FOR VARIABLES CORRESPONDING TO CONSTANT KEYWORDS.
;
CGV00::	MOVL	R9,R6		;COPY PTR TO VAR OR CONSTANT
	JSB	CDWRD		;GENERATE AS CODE WORD
	RSB			;RETURN TO CALLER
	.PAGE
;
;      CDGVL (CONTINUED)
;
;      HERE FOR TREE NODE (CMBLK)
;
CGV01::	MOVL	R7,-(SP)	;SAVE ENTRY WB
	MOVL	R10,-(SP)	;SAVE ENTRY XL
	MOVL	R8,-(SP)	;SAVE ENTRY CONSTANT FLAG
	MOVL	CWCOF,-(SP)	;SAVE INITIAL CODE OFFSET
	;CHK			;CHECK FOR STACK OVERFLOW
;
;      PREPARE TO GENERATE CODE FOR CMBLK. WC IS SET TO THE
;      VALUE OF CSWNO (ZERO IF -OPTIMISE, 1 IF -NOOPT) TO
;      START WITH AND IS RESET NON-ZERO FOR ANY NON-CONSTANT
;      CODE GENERATED. IF IT IS STILL ZERO AFTER GENERATING ALL
;      THE CMBLK CODE, THEN ITS VALUE IS COMPUTED AS THE RESULT.
;
	MOVL	R9,R10		;COPY CMBLK POINTER
	MOVL	4*CMTYP(R9),R9	;LOAD CMBLK TYPE
	MOVL	CSWNO,R8	;RESET CONSTANT FLAG
	CMPL	R9,#C$PR$	;JUMP IF NOT PREDICATE VALUE
	BLEQU	CGV02
	MOVL	SP,R8		;ELSE FORCE NON-CONSTANT CASE
;
;      HERE WITH WC SET APPROPRIATELY
;
CGV02::	BSW	R9,C$$NV	;SWITCH TO APPROPRIATE GENERATOR
	IFF	C$ARR,CGV03	;ARRAY REFERENCE
	IFF	C$FNC,CGV05	;FUNCTION CALL
	IFF	C$DEF,CGV14	;DEFERRED EXPRESSION
	IFF	C$SEL,CGV15	;SELECTION
	IFF	C$IND,CGV31	;INDIRECT REFERENCE
	IFF	C$KEY,CGV27	;KEYWORD REFERENCE
	IFF	C$UBO,CGV29	;UNDEFINED BINOP
	IFF	C$UUO,CGV30	;UNDEFINED UNOP
	IFF	C$BVL,CGV18	;BINOPS WITH VAL OPDS
	IFF	C$ALT,CGV18	;ALTERNATION
	IFF	C$UVL,CGV19	;UNOPS WITH VALU OPND
	IFF	C$ASS,CGV21	;ASSIGNMENT
	IFF	C$CNC,CGV24	;CONCATENATION
	IFF	C$CNP,CGV24	;CONCATENATION (NOT PATTERN MATCH)
	IFF	C$UNM,CGV27	;UNOPS WITH NAME OPND
	IFF	C$BVN,CGV26	;BINARY $ AND .
	IFF	C$INT,CGV31	;INTERROGATION
	IFF	C$NEG,CGV28	;NEGATION
	IFF	C$PMT,CGV18	;PATTERN MATCH
	ESW			;END SWITCH ON CMBLK TYPE
	.PAGE
;
;      CDGVL (CONTINUED)
;
;      HERE TO GENERATE CODE FOR ARRAY REFERENCE
;
CGV03::	MOVL	#4*CMOPN,R7	;SET OFFSET TO ARRAY OPERAND
;
;      LOOP TO GENERATE CODE FOR ARRAY OPERAND AND SUBSCRIPTS
;
CGV04::	JSB	CMGEN		;GEN VALUE CODE FOR NEXT OPERAND
	MOVL	4*CMLEN(R10),R8	;LOAD CMBLK LENGTH
	CMPL	R7,R8		;LOOP BACK IF MORE TO GO
	BLSSU	CGV04
;
;      GENERATE CALL TO APPROPRIATE ARRAY REFERENCE ROUTINE
;
	MOVL	#OAOV$,R6	;SET ONE SUBSCRIPT CALL IN CASE
	CMPL	R8,#4*CMAR1	;JUMP TO EXIT IF 1-SUB CASE
	BNEQU	5124$
	JMP	CGV32
5124$:
	MOVL	#OAMV$,R6	;ELSE SET CALL FOR MULTI-SUBSCRIPTS
	JSB	CDWRD		;GENERATE CALL
	MOVL	R8,R6		;COPY LENGTH OF CMBLK
	SUBL2	#4*CMVLS,R6	;SUBTRACT STANDARD LENGTH
	ASHL	#-2,R6,R6	;GET NUMBER OF WORDS
	JMP	CGV32		;JUMP TO GENERATE SUBSCRIPT COUNT
;
;      HERE TO GENERATE CODE FOR FUNCTION CALL
;
CGV05::	MOVL	#4*CMVLS,R7	;SET OFFSET TO FIRST ARGUMENT
;
;      LOOP TO GENERATE CODE FOR ARGUMENTS
;
CGV06::	CMPL	R7,4*CMLEN(R10)	;JUMP IF ALL GENERATED
	BEQLU	CGV07
	JSB	CMGEN		;ELSE GEN VALUE CODE FOR NEXT ARG
	JMP	CGV06		;BACK TO GENERATE NEXT ARGUMENT
;
;      HERE TO GENERATE ACTUAL FUNCTION CALL
;
CGV07::	SUBL2	#4*CMVLS,R7	;GET NUMBER OF ARG PTRS (BYTES)
	ASHL	#-2,R7,R7	;CONVERT BYTES TO WORDS
	MOVL	4*CMOPN(R10),R9	;LOAD FUNCTION VRBLK POINTER
	TSTL	4*VRLEN(R9)	;JUMP IF NOT SYSTEM FUNCTION
	BNEQU	CGV12
	MOVL	4*VRSVP(R9),R10	;LOAD SVBLK PTR IF SYSTEM VAR
	MOVL	4*SVBIT(R10),R6	;LOAD BIT MASK
	MCOML	BTFFC,R11	;TEST FOR FAST FUNCTION CALL ALLOWED
	BICL2	R11,R6
	BEQLU	CGV12
	.PAGE
;
;      CDGVL (CONTINUED)
;
;      HERE IF FAST FUNCTION CALL IS ALLOWED
;
	MOVL	4*SVBIT(R10),R6	;RELOAD BIT INDICATORS
	MCOML	BTPRE,R11	;TEST FOR PREEVALUATION OK
	BICL2	R11,R6
	BNEQU	CGV08
	MOVL	SP,R8		;ELSE SET RESULT NON-CONSTANT
;
;      TEST FOR CORRECT NUMBER OF ARGS FOR FAST CALL
;
CGV08::	MOVL	4*VRFNC(R9),R10	;LOAD PTR TO SVFNC FIELD
	MOVL	4*FARGS(R10),R6	;LOAD SVNAR FIELD VALUE
	CMPL	R6,R7		;JUMP IF ARGUMENT COUNT IS CORRECT
	BEQLU	CGV11
	CMPL	R6,R7		;JUMP IF TOO FEW ARGUMENTS GIVEN
	BGEQU	CGV09
;
;      HERE IF TOO MANY ARGUMENTS, PREPARE TO GENERATE O$POPS
;
	SUBL2	R6,R7		;GET NUMBER OF EXTRA ARGS
				;SET AS COUNT TO CONTROL LOOP
	MOVL	#OPOP$,R6	;SET POP CALL
	JMP	CGV10		;JUMP TO COMMON LOOP
;
;      HERE IF TOO FEW ARGUMENTS, PREPARE TO GENERATE NULLS
;
CGV09::	SUBL2	R7,R6		;GET NUMBER OF MISSING ARGUMENTS
	MOVL	R6,R7		;LOAD AS COUNT TO CONTROL LOOP
	MOVL	#NULLS,R6	;LOAD PTR TO NULL CONSTANT
;
;      LOOP TO GENERATE CALLS TO FIX ARGUMENT COUNT
;
CGV10::	JSB	CDWRD		;GENERATE ONE CALL
	SOBGTR	R7,CGV10	;LOOP TILL ALL GENERATED
;
;      HERE AFTER ADJUSTING ARG COUNT AS REQUIRED
;
CGV11::	MOVL	R10,R6		;COPY POINTER TO SVFNC FIELD
	JMP	CGV36		;JUMP TO GENERATE CALL
	.PAGE
;
;      CDGVL (CONTINUED)
;
;      COME HERE IF FAST CALL IS NOT PERMITTED
;
CGV12::	MOVL	#OFNS$,R6	;SET ONE ARG CALL IN CASE
	CMPL	R7,#NUM01	;JUMP IF ONE ARG CASE
	BEQLU	CGV13
	MOVL	#OFNC$,R6	;ELSE LOAD CALL FOR MORE THAN 1 ARG
	JSB	CDWRD		;GENERATE IT
	MOVL	R7,R6		;COPY ARGUMENT COUNT
;
;      ONE ARG CASE MERGES HERE
;
CGV13::	JSB	CDWRD		;GENERATE =O$FNS OR ARG COUNT
	MOVL	R9,R6		;COPY VRBLK POINTER
	JMP	CGV32		;JUMP TO GENERATE VRBLK PTR
;
;      HERE FOR DEFERRED EXPRESSION
;
CGV14::	MOVL	4*CMROP(R10),R10;POINT TO EXPRESSION TREE
	JSB	CDGEX		;BUILD EXBLK OR SEBLK
	MOVL	R9,R6		;COPY BLOCK PTR
	JSB	CDWRD		;GENERATE PTR TO EXBLK OR SEBLK
	JMP	CGV34		;JUMP TO EXIT, CONSTANT TEST
;
;      HERE TO GENERATE CODE FOR SELECTION
;
CGV15::	CLRL	-(SP)		;ZERO PTR TO CHAIN OF FORWARD JUMPS
	CLRL	-(SP)		;ZERO PTR TO PREV O$SLC FORWARD PTR
	MOVL	#4*CMVLS,R7	;POINT TO FIRST ALTERNATIVE
	MOVL	#OSLA$,R6	;SET INITIAL CODE WORD
;
;      0(XS)                 IS THE OFFSET TO THE PREVIOUS WORD
;                            WHICH REQUIRES FILLING IN WITH AN
;                            OFFSET TO THE FOLLOWING O$SLC,O$SLD
;
;      1(XS)                 IS THE HEAD OF A CHAIN OF OFFSET
;                            POINTERS INDICATING THOSE LOCATIONS
;                            TO BE FILLED WITH OFFSETS PAST
;                            THE END OF ALL THE ALTERNATIVES
;
CGV16::	JSB	CDWRD		;GENERATE O$SLC (O$SLA FIRST TIME)
	MOVL	CWCOF,(SP)	;SET CURRENT LOC AS PTR TO FILL IN
	JSB	CDWRD		;GENERATE GARBAGE WORD THERE FOR NOW
	JSB	CMGEN		;GEN VALUE CODE FOR ALTERNATIVE
	MOVL	#OSLB$,R6	;LOAD O$SLB POINTER
	JSB	CDWRD		;GENERATE O$SLB CALL
	MOVL	4*1(SP),R6	;LOAD OLD CHAIN PTR
	MOVL	CWCOF,4*1(SP)	;SET CURRENT LOC AS NEW CHAIN HEAD
	JSB	CDWRD		;GENERATE FORWARD CHAIN LINK
	.PAGE
;
;      CDGVL (CONTINUED)
;
;      NOW TO FILL IN THE SKIP OFFSET TO O$SLC,O$SLD
;
	MOVL	(SP),R9		;LOAD OFFSET TO WORD TO PLUG
	ADDL2	R$CCB,R9	;POINT TO ACTUAL LOCATION TO PLUG
	MOVL	CWCOF,(R9)	;PLUG PROPER OFFSET IN
	MOVL	#OSLC$,R6	;LOAD O$SLC PTR FOR NEXT ALTERNATIVE
	MOVL	R7,R9		;COPY OFFSET (DESTROY GARBAGE XR)
	ADDL2	#4,R9		;BUMP EXTRA TIME FOR TEST
	CMPL	R9,4*CMLEN(R10)	;LOOP BACK IF NOT LAST ALTERNATIVE
	BLSSU	CGV16
;
;      HERE TO GENERATE CODE FOR LAST ALTERNATIVE
;
	MOVL	#OSLD$,R6	;GET HEADER CALL
	JSB	CDWRD		;GENERATE O$SLD CALL
	JSB	CMGEN		;GENERATE CODE FOR LAST ALTERNATIVE
	ADDL2	#4,SP		;POP OFFSET PTR
	MOVL	(SP)+,R9	;LOAD CHAIN PTR
;
;      LOOP TO PLUG OFFSETS PAST STRUCTURE
;
CGV17::	ADDL2	R$CCB,R9	;MAKE NEXT PTR ABSOLUTE
	MOVL	(R9),R6		;LOAD FORWARD PTR
	MOVL	CWCOF,(R9)	;PLUG REQUIRED OFFSET
	MOVL	R6,R9		;COPY FORWARD PTR
	TSTL	R6		;LOOP BACK IF MORE TO GO
	BNEQU	CGV17
	JMP	CGV33		;ELSE JUMP TO EXIT (NOT CONSTANT)
;
;      HERE FOR BINARY OPS WITH VALUE OPERANDS
;
CGV18::	MOVL	4*CMLOP(R10),R9	;LOAD LEFT OPERAND POINTER
	JSB	CDGVL		;GEN VALUE CODE FOR LEFT OPERAND
;
;      HERE FOR UNARY OPS WITH VALUE OPERAND (BINOPS MERGE)
;
CGV19::	MOVL	4*CMROP(R10),R9	;LOAD RIGHT (ONLY) OPERAND PTR
	JSB	CDGVL		;GEN CODE BY VALUE
	.PAGE
;
;      CDGVL (CONTINUED)
;
;      MERGE HERE TO GENERATE OPERATOR CALL FROM CMOPN FIELD
;
CGV20::	MOVL	4*CMOPN(R10),R6	;LOAD OPERATOR CALL POINTER
	JMP	CGV36		;JUMP TO GENERATE IT WITH CONS TEST
;
;      HERE FOR ASSIGNMENT
;
CGV21::	MOVL	4*CMLOP(R10),R9	;LOAD LEFT OPERAND POINTER
	CMPL	(R9),#B$VR$	;JUMP IF NOT VARIABLE
	BLEQU	CGV22
;
;      HERE FOR ASSIGNMENT TO SIMPLE VARIABLE
;
	MOVL	4*CMROP(R10),R9	;LOAD RIGHT OPERAND PTR
	JSB	CDGVL		;GENERATE CODE BY VALUE
	MOVL	4*CMLOP(R10),R6	;RELOAD LEFT OPERAND VRBLK PTR
	ADDL2	#4*VRSTO,R6	;POINT TO VRSTO FIELD
	JMP	CGV32		;JUMP TO GENERATE STORE PTR
;
;      HERE IF NOT SIMPLE VARIABLE ASSIGNMENT
;
CGV22::	JSB	EXPAP		;TEST FOR PATTERN MATCH ON LEFT SIDE
	.ADDRESS CGV23		;JUMP IF NOT PATTERN MATCH
;
;      HERE FOR PATTERN REPLACEMENT
;
	MOVL	4*CMROP(R9),4*CMLOP(R10) ;SAVE PATTERN PTR IN SAFE PLACE
	MOVL	4*CMLOP(R9),R9	;LOAD SUBJECT PTR
	JSB	CDGNM		;GEN CODE BY NAME FOR SUBJECT
	MOVL	4*CMLOP(R10),R9	;LOAD PATTERN PTR
	JSB	CDGVL		;GEN CODE BY VALUE FOR PATTERN
	MOVL	#OPMN$,R6	;LOAD MATCH BY NAME CALL
	JSB	CDWRD		;GENERATE IT
	MOVL	4*CMROP(R10),R9	;LOAD REPLACEMENT VALUE PTR
	JSB	CDGVL		;GEN CODE BY VALUE
	MOVL	#ORPL$,R6	;LOAD REPLACE CALL
	JMP	CGV32		;JUMP TO GEN AND EXIT (NOT CONSTANT)
;
;      HERE FOR ASSIGNMENT TO COMPLEX VARIABLE
;
CGV23::	MOVL	SP,R8		;INHIBIT PRE-EVALUATION
	JSB	CDGNM		;GEN CODE BY NAME FOR LEFT SIDE
	JMP	CGV31		;MERGE WITH UNOP CIRCUIT
	.PAGE
;
;      CDGVL (CONTINUED)
;
;      HERE FOR CONCATENATION
;
CGV24::	MOVL	4*CMLOP(R10),R9	;LOAD LEFT OPERAND PTR
	CMPL	(R9),#B$CMT	;ORDINARY BINOP IF NOT CMBLK
	BEQLU	5125$
	JMP	CGV18
5125$:
	MOVL	4*CMTYP(R9),R7	;LOAD CMBLK TYPE CODE
	CMPL	R7,#C$INT	;SPECIAL CASE IF INTERROGATION
	BEQLU	CGV25
	CMPL	R7,#C$NEG	;OR NEGATION
	BEQLU	CGV25
	CMPL	R7,#C$FNC	;ELSE ORDINARY BINOP IF NOT FUNCTION
	BEQLU	5126$
	JMP	CGV18
5126$:
	MOVL	4*CMOPN(R9),R9	;ELSE LOAD FUNCTION VRBLK PTR
	TSTL	4*VRLEN(R9)	;ORDINARY BINOP IF NOT SYSTEM VAR
	BEQLU	5127$
	JMP	CGV18
5127$:
	MOVL	4*VRSVP(R9),R9	;ELSE POINT TO SVBLK
	MOVL	4*SVBIT(R9),R6	;LOAD BIT INDICATORS
	MCOML	BTPRD,R11	;TEST FOR PREDICATE FUNCTION
	BICL2	R11,R6
	BNEQU	5128$
	JMP	CGV18
5128$:
;
;      HERE IF LEFT ARG OF CONCATENATION IS PREDICATE FUNCTION
;
CGV25::	MOVL	4*CMLOP(R10),R9	;RELOAD LEFT ARG
	JSB	CDGVL		;GEN CODE BY VALUE
	MOVL	#OPOP$,R6	;LOAD POP CALL
	JSB	CDWRD		;GENERATE IT
	MOVL	4*CMROP(R10),R9	;LOAD RIGHT OPERAND
	JSB	CDGVL		;GEN CODE BY VALUE AS RESULT CODE
	JMP	CGV33		;EXIT (NOT CONSTANT)
;
;      HERE TO GENERATE CODE FOR PATTERN, IMMEDIATE ASSIGNMENT
;
CGV26::	MOVL	4*CMLOP(R10),R9	;LOAD LEFT OPERAND
	JSB	CDGVL		;GEN CODE BY VALUE, MERGE
;
;      HERE FOR UNOPS WITH ARG BY NAME (BINARY $ . MERGE)
;
CGV27::	MOVL	4*CMROP(R10),R9	;LOAD RIGHT OPERAND PTR
	JSB	CDGNM		;GEN CODE BY NAME FOR RIGHT ARG
	MOVL	4*CMOPN(R10),R9	;GET OPERATOR CODE WORD
	CMPL	(R9),#O$KWV	;GEN CALL UNLESS KEYWORD VALUE
	BEQLU	5129$
	JMP	CGV20
5129$:
	.PAGE
;
;      CDGVL (CONTINUED)
;
;      HERE FOR KEYWORD BY VALUE. THIS IS CONSTANT ONLY IF
;      THE OPERAND IS ONE OF THE SPECIAL SYSTEM VARIABLES WITH
;      THE SVCKW BIT SET TO INDICATE A CONSTANT KEYWORD VALUE.
;      NOTE THAT THE ONLY CONSTANT OPERAND BY NAME IS A VARIABLE
;
	TSTL	R8		;GEN CALL IF NON-CONSTANT (NOT VAR)
	BEQLU	5130$
	JMP	CGV20
5130$:
	MOVL	SP,R8		;ELSE SET NON-CONSTANT IN CASE
	MOVL	4*CMROP(R10),R9	;LOAD PTR TO OPERAND VRBLK
	TSTL	4*VRLEN(R9)	;GEN (NON-CONSTANT) IF NOT SYS VAR
	BEQLU	5131$
	JMP	CGV20
5131$:
	MOVL	4*VRSVP(R9),R9	;ELSE LOAD PTR TO SVBLK
	MOVL	4*SVBIT(R9),R6	;LOAD BIT MASK
	MCOML	BTCKW,R11	;TEST FOR CONSTANT KEYWORD
	BICL2	R11,R6
	BNEQU	5132$
	JMP	CGV20
5132$:
	CLRL	R8		;ELSE SET RESULT CONSTANT
	JMP	CGV20		;AND JUMP BACK TO GENERATE CALL
;
;      HERE TO GENERATE CODE FOR NEGATION
;
CGV28::	MOVL	#ONTA$,R6	;GET INITIAL WORD
	JSB	CDWRD		;GENERATE IT
	MOVL	CWCOF,R7	;SAVE NEXT OFFSET
	JSB	CDWRD		;GENERATE GUNK WORD FOR NOW
	MOVL	4*CMROP(R10),R9	;LOAD RIGHT OPERAND PTR
	JSB	CDGVL		;GEN CODE BY VALUE
	MOVL	#ONTB$,R6	;LOAD END OF EVALUATION CALL
	JSB	CDWRD		;GENERATE IT
	MOVL	R7,R9		;COPY OFFSET TO WORD TO PLUG
	ADDL2	R$CCB,R9	;POINT TO ACTUAL WORD TO PLUG
	MOVL	CWCOF,(R9)	;PLUG WORD WITH CURRENT OFFSET
	MOVL	#ONTC$,R6	;LOAD FINAL CALL
	JMP	CGV32		;JUMP TO GENERATE IT (NOT CONSTANT)
;
;      HERE TO GENERATE CODE FOR UNDEFINED BINARY OPERATOR
;
CGV29::	MOVL	4*CMLOP(R10),R9	;LOAD LEFT OPERAND PTR
	JSB	CDGVL		;GENERATE CODE BY VALUE
	.PAGE
;
;      CDGVL (CONTINUED)
;
;      HERE TO GENERATE CODE FOR UNDEFINED UNARY OPERATOR
;
CGV30::	MOVL	#C$UO$,R7	;SET UNOP CODE + 1
	SUBL2	4*CMTYP(R10),R7	;SET NUMBER OF ARGS (1 OR 2)
;
;      MERGE HERE FOR UNDEFINED OPERATORS
;
	MOVL	4*CMROP(R10),R9	;LOAD RIGHT (ONLY) OPERAND POINTER
	JSB	CDGVL		;GEN VALUE CODE FOR RIGHT OPERAND
	MOVL	4*CMOPN(R10),R9	;LOAD POINTER TO OPERATOR DV
	MOVL	4*DVOPN(R9),R9	;LOAD POINTER OFFSET
	MOVAL	0[R9],R9	;CONVERT WORD OFFSET TO BYTES
	ADDL2	#R$UBA,R9	;POINT TO PROPER FUNCTION PTR
	SUBL2	#4*VRFNC,R9	;SET STANDARD FUNCTION OFFSET
	JMP	CGV12		;MERGE WITH FUNCTION CALL CIRCUIT
;
;      HERE TO GENERATE CODE FOR INTERROGATION, INDIRECTION
;
CGV31::	MOVL	SP,R8		;SET NON CONSTANT
	JMP	CGV19		;MERGE
;
;      HERE TO EXIT GENERATING A WORD, RESULT NOT CONSTANT
;
CGV32::	JSB	CDWRD		;GENERATE WORD, MERGE
;
;      HERE TO EXIT WITH NO WORD GENERATED, NOT CONSTANT
;
CGV33::	MOVL	SP,R8		;INDICATE RESULT IS NOT CONSTANT
;
;      COMMON EXIT POINT
;
CGV34::	ADDL2	#4,SP		;POP INITIAL CODE OFFSET
	MOVL	(SP)+,R6	;RESTORE OLD CONSTANT FLAG
	MOVL	(SP)+,R10	;RESTORE ENTRY XL
	MOVL	(SP)+,R7	;RESTORE ENTRY WB
	TSTL	R8		;JUMP IF NOT CONSTANT
	BNEQU	CGV35
	MOVL	R6,R8		;ELSE RESTORE ENTRY CONSTANT FLAG
;
;      HERE TO RETURN AFTER DEALING WITH WC SETTING
;
CGV35::	RSB			;RETURN TO CDGVL CALLER
;
;      EXIT HERE TO GENERATE WORD AND TEST FOR CONSTANT
;
CGV36::	JSB	CDWRD		;GENERATE WORD
	TSTL	R8		;JUMP TO EXIT IF NOT CONSTANT
	BNEQU	CGV34
	.PAGE
;
;      CDGVL (CONTINUED)
;
;      HERE TO PREEVALUATE CONSTANT SUB-EXPRESSION
;
	MOVL	#ORVL$,R6	;LOAD CALL TO RETURN VALUE
	JSB	CDWRD		;GENERATE IT
	MOVL	(SP),R10	;LOAD INITIAL CODE OFFSET
	JSB	EXBLD		;BUILD EXBLK FOR EXPRESSION
	CLRL	R7		;SET TO EVALUATE BY VALUE
	JSB	EVALX		;EVALUATE EXPRESSION
	.ADDRESS INVALID$	;SHOULD NOT FAIL
	MOVL	(R9),R6		;LOAD TYPE WORD OF RESULT
	CMPL	R6,#P$AAA	;JUMP IF NOT PATTERN
	BLEQU	CGV37
	MOVL	#OLPT$,R6	;ELSE LOAD SPECIAL PATTERN LOAD CALL
	JSB	CDWRD		;GENERATE IT
;
;      MERGE HERE TO GENERATE POINTER TO RESULTING CONSTANT
;
CGV37::	MOVL	R9,R6		;COPY CONSTANT POINTER
	JSB	CDWRD		;GENERATE PTR
	CLRL	R8		;SET RESULT CONSTANT
	JMP	CGV34		;JUMP BACK TO EXIT
	;ENP			;END PROCEDURE CDGVL
	.PAGE
;
;      CDWRD -- GENERATE ONE WORD OF CODE
;
;      CDWRD WRITES ONE WORD INTO THE CURRENT CODE BLOCK UNDER
;      CONSTRUCTION. A NEW, LARGER, BLOCK IS ALLOCATED IF THERE
;      IS INSUFFICIENT ROOM IN THE CURRENT BLOCK. CDWRD ENSURES
;      THAT THERE ARE AT LEAST THREE WORDS LEFT IN THE BLOCK
;      AFTER ENTERING THE NEW WORD. THIS GUARANTEES THAT ANY
;      EXTRA SPACE AT THE END CAN BE SPLIT OFF AS A CCBLK.
;
;      (WA)                  WORD TO BE GENERATED
;      JSR  CDWRD            CALL TO GENERATE WORD
;
	.ENABLE	LOCAL_BLOCK
CDWRD::	;PRC			;ENTRY POINT
	MOVL	R9,-(SP)	;SAVE ENTRY XR
	MOVL	R6,-(SP)	;SAVE CODE WORD TO BE GENERATED
;
;      MERGE BACK HERE AFTER ALLOCATING LARGER BLOCK
;
CDWD1::	MOVL	R$CCB,R9	;LOAD PTR TO CCBLK BEING BUILT
	BNEQU	CDWD2
;
;      HERE WE ALLOCATE AN ENTIRELY FRESH BLOCK
;
	MOVL	#4*E$CBS,R6	;LOAD INITIAL LENGTH
	JSB	ALLOC		;ALLOCATE CCBLK
	MOVL	#B$CCT,(R9)	;STORE TYPE WORD
	MOVL	#4*CCCOD,CWCOF	;SET INITIAL OFFSET
	MOVL	R6,4*CCLEN(R9)	;STORE BLOCK LENGTH
	MOVL	R9,R$CCB	;STORE PTR TO NEW BLOCK
;
;      HERE WE HAVE A BLOCK WE CAN USE
;
CDWD2::	MOVL	CWCOF,R6	;LOAD CURRENT OFFSET
	ADDL2	#4*NUM04,R6	;ADJUST FOR TEST (FOUR WORDS)
	CMPL	R6,4*CCLEN(R9)	;JUMP IF ROOM IN THIS BLOCK
	BGTRU	5133$
	JMP	CDWD4
5133$:
;
;      HERE IF NO ROOM IN CURRENT BLOCK
;
	CMPL	R6,MXLEN	;JUMP IF ALREADY AT MAX SIZE
	BLSSU	5134$
	JMP	CDWD5
5134$:
	ADDL2	#4*E$CBS,R6	;ELSE GET NEW SIZE
	MOVL	R10,-(SP)	;SAVE ENTRY XL
	MOVL	R9,R10		;COPY POINTER
	CMPL	R6,MXLEN	;JUMP IF NOT TOO LARGE
	BLSSU	CDWD3
	MOVL	MXLEN,R6	;ELSE RESET TO MAX ALLOWED SIZE
	.PAGE
;
;      CDWRD (CONTINUED)
;
;      HERE WITH NEW BLOCK SIZE IN WA
;
CDWD3::	JSB	ALLOC		;ALLOCATE NEW BLOCK
	MOVL	R9,R$CCB	;STORE POINTER TO NEW BLOCK
	MOVL	#B$CCT,(R9)+	;STORE TYPE WORD IN NEW BLOCK
	MOVL	R6,(R9)+	;STORE BLOCK LENGTH
	ADDL2	#4*CCUSE,R10	;POINT TO CCUSE,CCCOD FIELDS IN OLD
	MOVL	(R10),R6	;LOAD CCUSE VALUE
	MVW			;COPY USEFUL WORDS FROM OLD BLOCK
	MOVL	(SP)+,R10	;RESTORE XL
	JMP	CDWD1		;MERGE BACK TO TRY AGAIN
;
;      HERE WITH ROOM IN CURRENT BLOCK
;
CDWD4::	MOVL	CWCOF,R6	;LOAD CURRENT OFFSET
	ADDL2	#4,R6		;GET NEW OFFSET
	MOVL	R6,CWCOF	;STORE NEW OFFSET
	MOVL	R6,4*CCUSE(R9)	;STORE IN CCBLK FOR GBCOL
	SUBL2	#4,R6		;RESTORE PTR TO THIS WORD
	ADDL2	R6,R9		;POINT TO CURRENT ENTRY
	MOVL	(SP)+,R6	;RELOAD WORD TO GENERATE
	MOVL	R6,(R9)		;STORE WORD IN BLOCK
	MOVL	(SP)+,R9	;RESTORE ENTRY XR
	RSB			;RETURN TO CALLER
;
;      HERE IF COMPILED CODE IS TOO LONG FOR CDBLK
;
CDWD5::	JMP	ERROR_213	;SYNTAX ERROR. STATEMENT IS TOO COMPLICATED.
	;ENP			;END PROCEDURE CDWRD
	.PAGE
;
;      CMGEN -- GENERATE CODE FOR CMBLK PTR
;
;      CMGEN IS A SUBSIDIARY PROCEDURE USED TO GENERATE VALUE
;      CODE FOR A CMBLK PTR FROM THE MAIN CODE GENERATORS.
;
;      (XL)                  CMBLK POINTER
;      (WB)                  OFFSET TO POINTER IN CMBLK
;      JSR  CMGEN            CALL TO GENERATE CODE
;      (XR,WA)               DESTROYED
;      (WB)                  BUMPED BY ONE WORD
;
	.ENABLE	LOCAL_BLOCK
CMGEN::	;PRC			;ENTRY POINT, RECURSIVE
	MOVL	R10,R9		;COPY CMBLK POINTER
	ADDL2	R7,R9		;POINT TO CMBLK POINTER
	MOVL	(R9),R9		;LOAD CMBLK POINTER
	JSB	CDGVL		;GENERATE CODE BY VALUE
	ADDL2	#4,R7		;BUMP OFFSET
	RSB			;RETURN TO CALLER
	;ENP			;END PROCEDURE CMGEN
	.PAGE
;
;      CMPIL (COMPILE SOURCE CODE)
;
;      CMPIL IS USED TO CONVERT SNOBOL4 SOURCE CODE TO INTERNAL
;      FORM (SEE CDBLK FORMAT). IT IS USED BOTH FOR THE INITIAL
;      COMPILE AND AT RUN TIME BY THE CODE AND CONVERT FUNCTIONS
;      THIS PROCEDURE HAS CONTROL FOR THE ENTIRE DURATION OF
;      INITIAL COMPILATION. AN ERROR IN ANY PROCEDURE CALLED
;      DURING COMPILATION WILL LEAD FIRST TO THE ERROR SECTION
;      AND ULTIMATELY BACK HERE FOR RESUMED COMPILATION. THE
;      RE-ENTRY POINTS AFTER AN ERROR ARE SPECIALLY LABELLED -
;
;      CMPCE                 RESUME AFTER CONTROL CARD ERROR
;      CMPLE                 RESUME AFTER LABEL ERROR
;      CMPSE                 RESUME AFTER STATEMENT ERROR
;
;      JSR  CMPIL            CALL TO COMPILE CODE
;      (XR)                  PTR TO CDBLK FOR ENTRY STATEMENT
;      (XL,WA,WB,WC,RA)      DESTROYED
;
;      THE FOLLOWING GLOBAL VARIABLES ARE REFERENCED
;
;      CMPSN                 NUMBER OF NEXT STATEMENT
;                            TO BE COMPILED.
;
;      CSWXX                 CONTROL CARD SWITCH VALUES ARE
;                            CHANGED WHEN RELEVANT CONTROL
;                            CARDS ARE MET.
;
;      CWCOF                 OFFSET TO NEXT WORD IN CODE BLOCK
;                            BEING BUILT (SEE CDWRD).
;
;      LSTSN                 NUMBER OF STATEMENT MOST RECENTLY
;                            COMPILED (INITIALLY SET TO ZERO).
;
;      R$CIM                 CURRENT (INITIAL) COMPILER IMAGE
;                            (ZERO FOR INITIAL COMPILE CALL)
;
;      R$CNI                 USED TO POINT TO FOLLOWING IMAGE.
;                            (SEE READR PROCEDURE).
;
;      SCNGO                 GOTO SWITCH FOR SCANE PROCEDURE
;
;      SCNIL                 LENGTH OF CURRENT IMAGE EXCLUDING
;                            CHARACTERS REMOVED BY -INPUT.
;
;      SCNPT                 CURRENT SCAN OFFSET, SEE SCANE.
;
;      SCNRS                 RESCAN SWITCH FOR SCANE PROCEDURE.
;
;      SCNSE                 OFFSET (IN R$CIM) OF MOST RECENTLY
;                            SCANNED ELEMENT. SET ZERO IF NOT
;                            CURRENTLY SCANNING ITEMS
	.PAGE
;
;      CMPIL (CONTINUED)
;
;      STAGE               STGIC  INITIAL COMPILE IN PROGRESS
;                          STGXC  CODE/CONVERT COMPILE
;                          STGEV  BUILDING EXBLK FOR EVAL
;                          STGXT  EXECUTE TIME (OUTSIDE COMPILE)
;                          STGCE  INITIAL COMPILE AFTER END LINE
;                          STGXE  EXECUTE COMPILE AFTER END LINE
;
;      CMPIL ALSO USES A FIXED NUMBER OF LOCATIONS ON THE
;      MAIN STACK AS FOLLOWS. (THE DEFINITIONS OF THE ACTUAL
;      OFFSETS ARE IN THE DEFINITIONS SECTION).
;
;      CMSTM(XS)             POINTER TO EXPAN TREE FOR BODY OF
;                            STATEMENT (SEE EXPAN PROCEDURE).
;
;      CMSGO(XS)             POINTER TO TREE REPRESENTATION OF
;                            SUCCESS GOTO (SEE PROCEDURE SCNGO)9
;                            ZERO IF NO SUCCESS GOTO IS GIVEN
;
;      CMFGO(XS)             LIKE CMSGO FOR FAILURE GOTO.
;
;      CMCGO(XS)             SET NON-ZERO ONLY IF THERE IS A
;                            CONDITIONAL GOTO. USED FOR -FAIL,
;                            -NOFAIL CODE GENERATION.
;
;      CMPCD(XS)             POINTER TO CDBLK FOR PREVIOUS
;                            STATEMENT. ZERO FOR 1ST STATEMENT.
;
;      CMFFP(XS)             SET NON-ZERO IF CDFAL IN PREVIOUS
;                            CDBLK NEEDS FILLING WITH FORWARD
;                            POINTER, ELSE SET TO ZERO.
;
;      CMFFC(XS)             SAME AS CMFFP FOR CURRENT CDBLK
;
;      CMSOP(XS)             OFFSET TO WORD IN PREVIOUS CDBLK
;                            TO BE FILLED IN WITH FORWARD PTR
;                            TO NEXT CDBLK FOR SUCCESS GOTO.
;                            ZERO IF NO FILL IN IS REQUIRED.
;
;      CMSOC(XS)             SAME AS CMSOP FOR CURRENT CDBLK.
;
;      CMLBL(XS)             POINTER TO VRBLK FOR LABEL OF
;                            CURRENT STATEMENT. ZERO IF NO LABEL
;
;      CMTRA(XS)             POINTER TO CDBLK FOR ENTRY STMNT.
	.PAGE
;
;      CMPIL (CONTINUED)
;
;      ENTRY POINT
;
	.ENABLE	LOCAL_BLOCK
CMPIL::	;PRC			;ENTRY POINT
	MOVL	#CMNEN,R7	;SET NUMBER OF STACK WORK LOCATIONS
;
;      LOOP TO INITIALIZE STACK WORKING LOCATIONS
;
CMP00::	CLRL	-(SP)		;STORE A ZERO, MAKE ONE ENTRY
	SOBGTR	R7,CMP00	;LOOP BACK UNTIL ALL SET
	MOVL	SP,CMPXS	;SAVE STACK POINTER FOR ERROR SEC
	;SSS	CMPSS		;SAVE S-R STACK POINTER IF ANY
;
;      LOOP THROUGH STATEMENTS
;
CMP01::	MOVL	SCNPT,R7	;SET SCAN POINTER OFFSET
	MOVL	R7,SCNSE	;SET START OF ELEMENT LOCATION
	MOVL	#OCER$,R6	;POINT TO COMPILE ERROR CALL
	JSB	CDWRD		;GENERATE AS TEMPORARY CDFAL
	CMPL	R7,SCNIL	;JUMP IF CHARS LEFT ON THIS IMAGE
	BLSSU	CMP04
;
;      LOOP HERE AFTER COMMENT OR CONTROL CARD
;      ALSO SPECIAL ENTRY AFTER CONTROL CARD ERROR
;
CMPCE::	CLRL	R9		;CLEAR POSSIBLE GARBAGE XR VALUE
	CMPL	STAGE,#STGIC	;SKIP UNLESS INITIAL COMPILE
	BNEQU	CMP02
	JSB	READR		;READ NEXT INPUT IMAGE
	TSTL	R9		;JUMP IF NO INPUT AVAILABLE
	BNEQU	5135$
	JMP	CMP09
5135$:
	JSB	NEXTS		;ACQUIRE NEXT SOURCE IMAGE
	MOVL	CMPSN,LSTSN	;STORE STMT NO FOR USE BY LISTR
	CLRL	SCNPT		;RESET SCAN POINTER
	JMP	CMP04		;GO PROCESS IMAGE
;
;      FOR EXECUTE TIME COMPILE, PERMIT EMBEDDED CONTROL CARDS
;      AND COMMENTS (BY SKIPPING TO NEXT SEMI-COLON)
;
CMP02::	MOVL	R$CIM,R9	;GET CURRENT IMAGE
	MOVL	SCNPT,R7	;GET CURRENT OFFSET
	MOVAB	CFP$F(R9)[R7],R9;PREPARE TO GET CHARS
;
;      SKIP TO SEMI-COLON
;
CMP03::	MOVZBL	(R9)+,R8	;GET CHAR
	INCL	SCNPT		;ADVANCE OFFSET
	CMPL	R8,#CH$SM	;SKIP IF SEMI-COLON FOUND
	BEQLU	CMP04
	CMPL	SCNPT,SCNIL	;LOOP IF MORE CHARS
	BLSSU	CMP03
	CLRL	R9		;CLEAR GARBAGE XR VALUE
	JMP	CMP09		;END OF IMAGE
	.PAGE
;
;      CMPIL (CONTINUED)
;
;      HERE WITH IMAGE AVAILABLE TO SCAN. NOTE THAT IF THE INPUT
;      STRING IS NULL, THEN EVERYTHING IS OK SINCE NULL IS
;      ACTUALLY ASSEMBLED AS A WORD OF BLANKS.
;
CMP04::	MOVL	R$CIM,R9	;POINT TO CURRENT IMAGE
	MOVL	SCNPT,R7	;LOAD CURRENT OFFSET
	MOVL	R7,R6		;COPY FOR LABEL SCAN
	MOVAB	CFP$F(R9)[R7],R9;POINT TO FIRST CHARACTER
	MOVZBL	(R9)+,R8	;LOAD FIRST CHARACTER
	CMPL	R8,#CH$SM	;NO LABEL IF SEMICOLON
	BNEQU	5136$
	JMP	CMP12
5136$:
	CMPL	R8,#CH$AS	;LOOP BACK IF COMMENT CARD
	BNEQU	5137$
	JMP	CMPCE
5137$:
	CMPL	R8,#CH$MN	;JUMP IF CONTROL CARD
	BNEQU	5138$
	JMP	CMP32
5138$:
	MOVL	R$CIM,R$CMP	;ABOUT TO DESTROY R$CIM
	MOVL	#CMLAB,R10	;POINT TO LABEL WORK STRING
	MOVL	R10,R$CIM	;SCANE IS TO SCAN WORK STRING
	MOVAB	CFP$F(R10),R10	;POINT TO FIRST CHARACTER POSITION
	MOVB	R8,(R10)+	;STORE CHAR JUST LOADED
	MOVL	#CH$SM,R8	;GET A SEMICOLON
	MOVB	R8,(R10)	;STORE AFTER FIRST CHAR
	;CSC	R10		;FINISHED CHARACTER STORING
	CLRL	R10		;CLEAR POINTER
	CLRL	SCNPT		;START AT FIRST CHARACTER
	MOVL	SCNIL,-(SP)	;PRESERVE IMAGE LENGTH
	MOVL	#NUM02,SCNIL	;READ 2 CHARS AT MOST
	JSB	SCANE		;SCAN FIRST CHAR FOR TYPE
	MOVL	(SP)+,SCNIL	;RESTORE IMAGE LENGTH
	MOVL	R10,R8		;NOTE RETURN CODE
	MOVL	R$CMP,R10	;GET OLD R$CIM
	MOVL	R10,R$CIM	;PUT IT BACK
	MOVL	R7,SCNPT	;REINSTATE OFFSET
	TSTL	SCNBL		;BLANK SEEN - CANT BE LABEL
	BEQLU	5139$
	JMP	CMP12
5139$:
	MOVL	R10,R9		;POINT TO CURRENT IMAGE
	MOVAB	CFP$F(R9)[R7],R9;POINT TO FIRST CHAR AGAIN
	CMPL	R8,#T$VAR	;OK IF LETTER
	BEQLU	CMP06
	CMPL	R8,#T$CON	;OK IF DIGIT
	BEQLU	CMP06
;
;      DROP IN OR JUMP FROM ERROR SECTION IF SCANE FAILED
;
CMPLE::	MOVL	R$CMP,R$CIM	;POINT TO BAD LINE
	JMP	ERROR_214	;BAD LABEL OR MISPLACED CONTINUATION LINE
;
;      LOOP TO SCAN LABEL
;
CMP05::	CMPL	R8,#CH$SM	;SKIP IF SEMICOLON
	BEQLU	CMP07
	INCL	R6		;BUMP OFFSET
	CMPL	R6,SCNIL	;JUMP IF END OF IMAGE (LABEL END)
	BEQLU	CMP07
	.PAGE
;
;      CMPIL (CONTINUED)
;
;      ENTER LOOP AT THIS POINT
;
CMP06::	MOVZBL	(R9)+,R8	;ELSE LOAD NEXT CHARACTER
	.IF NOT_EQUAL CAHT
	CMPL	R8,#CH$HT	;JUMP IF HORIZONTAL TAB
	BEQLU	CMP07
	.ENDC
	.IF NOT_EQUAL CAVT
	CMPL	R8,#CH$VT	;JUMP IF VERTICAL TAB
	BEQLU	CMP07
	.ENDC
	CMPL	R8,#CH$BL	;LOOP BACK IF NON-BLANK
	BNEQU	CMP05
;
;      HERE AFTER SCANNING OUT LABEL
;
CMP07::	MOVL	R6,SCNPT	;SAVE UPDATED SCAN OFFSET
	SUBL2	R7,R6		;GET LENGTH OF LABEL
	BNEQU	5140$
	JMP	CMP12
5140$:
	CLRL	R9		;CLEAR GARBAGE XR VALUE
	JSB	SBSTR		;BUILD SCBLK FOR LABEL NAME
	JSB	GTNVR		;LOCATE/CONTRUCT VRBLK
	.ADDRESS INVALID$	;DUMMY (IMPOSSIBLE) ERROR RETURN
	MOVL	R9,4*CMLBL(SP)	;STORE LABEL POINTER
	TSTL	4*VRLEN(R9)	;JUMP IF NOT SYSTEM LABEL
	BNEQU	CMP11
	CMPL	4*VRSVP(R9),#V$END ;JUMP IF NOT END LABEL
	BNEQU	CMP11
;
;      HERE FOR END LABEL SCANNED OUT
;
	ADDL2	#STGND,STAGE	;ADJUST STAGE APPROPRIATELY
	JSB	SCANE		;SCAN OUT NEXT ELEMENT
	CMPL	R10,#T$SMC	;JUMP IF END OF IMAGE
	BNEQU	5141$
	JMP	CMP10
5141$:
	CMPL	R10,#T$VAR	;ELSE ERROR IF NOT VARIABLE
	BNEQU	CMP08
;
;      HERE CHECK FOR VALID INITIAL TRANSFER
;
	CMPL	4*VRLBL(R9),#STNDL ;JUMP IF NOT DEFINED (ERROR)
	BEQLU	CMP08
	MOVL	4*VRLBL(R9),4*CMTRA(SP) ;ELSE SET INITIAL ENTRY POINTER
	JSB	SCANE		;SCAN NEXT ELEMENT
	CMPL	R10,#T$SMC	;JUMP IF OK (END OF IMAGE)
	BNEQU	5142$
	JMP	CMP10
5142$:
;
;      HERE FOR BAD TRANSFER LABEL
;
CMP08::	JMP	ERROR_215	;SYNTAX ERROR. UNDEFINED OR ERRONEOUS ENTRY LABEL
;
;      HERE FOR END OF INPUT (NO END LABEL DETECTED)
;
CMP09::	ADDL2	#STGND,STAGE	;ADJUST STAGE APPROPRIATELY
	CMPL	STAGE,#STGXE	;JUMP IF CODE CALL (OK)
	BNEQU	5143$
	JMP	CMP10
5143$:
	JMP	ERROR_216	;SYNTAX ERROR. MISSING END LINE
;
;      HERE AFTER PROCESSING END LINE (MERGE HERE ON END ERROR)
;
CMP10::	MOVL	#OSTP$,R6	;SET STOP CALL POINTER
	JSB	CDWRD		;GENERATE AS STATEMENT CALL
	JMP	CMPSE		;JUMP TO GENERATE AS FAILURE
	.PAGE
;
;      CMPIL (CONTINUED)
;
;      HERE AFTER PROCESSING LABEL OTHER THAN END
;
CMP11::	CMPL	STAGE,#STGIC	;JUMP IF CODE CALL - REDEF. OK
	BEQLU	5144$
	JMP	CMP12
5144$:
	CMPL	4*VRLBL(R9),#STNDL ;ELSE CHECK FOR REDEFINITION
	BNEQU	5145$
	JMP	CMP12
5145$:
	CLRL	4*CMLBL(SP)	;LEAVE FIRST LABEL DECLN UNDISTURBED
	JMP	ERROR_217	;SYNTAX ERROR. DUPLICATE LABEL
;
;      HERE AFTER DEALING WITH LABEL
;
CMP12::	CLRL	R7		;SET FLAG FOR STATEMENT BODY
	JSB	EXPAN		;GET TREE FOR STATEMENT BODY
	MOVL	R9,4*CMSTM(SP)	;STORE FOR LATER USE
	CLRL	4*CMSGO(SP)	;CLEAR SUCCESS GOTO POINTER
	CLRL	4*CMFGO(SP)	;CLEAR FAILURE GOTO POINTER
	CLRL	4*CMCGO(SP)	;CLEAR CONDITIONAL GOTO FLAG
	JSB	SCANE		;SCAN NEXT ELEMENT
	CMPL	R10,#T$COL	;JUMP IT NOT COLON (NO GOTO)
	BEQLU	5146$
	JMP	CMP18
5146$:
;
;      LOOP TO PROCESS GOTO FIELDS
;
CMP13::	MOVL	SP,SCNGO	;SET GOTO FLAG
	JSB	SCANE		;SCAN NEXT ELEMENT
	CMPL	R10,#T$SMC	;JUMP IF NO FIELDS LEFT
	BNEQU	5147$
	JMP	CMP31
5147$:
	CMPL	R10,#T$SGO	;JUMP IF S FOR SUCCESS GOTO
	BEQLU	CMP14
	CMPL	R10,#T$FGO	;JUMP IF F FOR FAILURE GOTO
	BEQLU	CMP16
;
;      HERE FOR UNCONDITIONAL GOTO (I.E. NOT F OR S)
;
	MOVL	SP,SCNRS	;SET TO RESCAN ELEMENT NOT F,S
	JSB	SCNGF		;SCAN OUT GOTO FIELD
	TSTL	4*CMFGO(SP)	;ERROR IF FGOTO ALREADY
	BNEQU	CMP17
	MOVL	R9,4*CMFGO(SP)	;ELSE SET AS FGOTO
	JMP	CMP15		;MERGE WITH SGOTO CIRCUIT
;
;      HERE FOR SUCCESS GOTO
;
CMP14::	JSB	SCNGF		;SCAN SUCCESS GOTO FIELD
	MOVL	#NUM01,4*CMCGO(SP) ;SET CONDITIONAL GOTO FLAG
;
;      UNCONTIONAL GOTO MERGES HERE
;
CMP15::	TSTL	4*CMSGO(SP)	;ERROR IF SGOTO ALREADY GIVEN
	BNEQU	CMP17
	MOVL	R9,4*CMSGO(SP)	;ELSE SET SGOTO
	JMP	CMP13		;LOOP BACK FOR NEXT GOTO FIELD
;
;      HERE FOR FAILURE GOTO
;
CMP16::	JSB	SCNGF		;SCAN GOTO FIELD
	MOVL	#NUM01,4*CMCGO(SP) ;SET CONDITONAL GOTO FLAG
	TSTL	4*CMFGO(SP)	;ERROR IF FGOTO ALREADY GIVEN
	BNEQU	CMP17
	MOVL	R9,4*CMFGO(SP)	;ELSE STORE FGOTO POINTER
	JMP	CMP13		;LOOP BACK FOR NEXT FIELD
	.PAGE
;
;      CMPIL (CONTINUED)
;
;      HERE FOR DUPLICATED GOTO FIELD
;
CMP17::	JMP	ERROR_218	;SYNTAX ERROR. DUPLICATED GOTO FIELD
;
;      HERE TO GENERATE CODE
;
CMP18::	CLRL	SCNSE		;STOP POSITIONAL ERROR FLAGS
	MOVL	4*CMSTM(SP),R9	;LOAD TREE PTR FOR STATEMENT BODY
	CLRL	R7		;COLLECTABLE VALUE FOR WB FOR CDGVL
	CLRL	R8		;RESET CONSTANT FLAG FOR CDGVL
	JSB	EXPAP		;TEST FOR PATTERN MATCH
	.ADDRESS CMP19		;JUMP IF NOT PATTERN MATCH
	MOVL	#OPMS$,4*CMOPN(R9) ;ELSE SET PATTERN MATCH POINTER
	MOVL	#C$PMT,4*CMTYP(R9)
;
;      HERE AFTER DEALING WITH SPECIAL PATTERN MATCH CASE
;
CMP19::	JSB	CDGVL		;GENERATE CODE FOR BODY OF STATEMENT
	MOVL	4*CMSGO(SP),R9	;LOAD SGOTO POINTER
	MOVL	R9,R6		;COPY IT
	TSTL	R9		;JUMP IF NO SUCCESS GOTO
	BEQLU	CMP21
	CLRL	4*CMSOC(SP)	;CLEAR SUCCESS OFFSET FILLIN PTR
	CMPL	R9,STATE	;JUMP IF COMPLEX GOTO
	BGEQU	CMP20
;
;      HERE FOR SIMPLE SUCCESS GOTO (LABEL)
;
	ADDL2	#4*VRTRA,R6	;POINT TO VRTRA FIELD AS REQUIRED
	JSB	CDWRD		;GENERATE SUCCESS GOTO
	JMP	CMP22		;JUMP TO DEAL WITH FGOTO
;
;      HERE FOR COMPLEX SUCCESS GOTO
;
CMP20::	CMPL	R9,4*CMFGO(SP)	;NO CODE IF SAME AS FGOTO
	BEQLU	CMP22
	CLRL	R7		;ELSE SET OK VALUE FOR CDGVL IN WB
	JSB	CDGCG		;GENERATE CODE FOR SUCCESS GOTO
	JMP	CMP22		;JUMP TO DEAL WITH FGOTO
;
;      HERE FOR NO SUCCESS GOTO
;
CMP21::	MOVL	CWCOF,4*CMSOC(SP);SET SUCCESS FILL IN OFFSET
	MOVL	#OCER$,R6	;POINT TO COMPILE ERROR CALL
	JSB	CDWRD		;GENERATE AS TEMPORARY VALUE
	.PAGE
;
;      CMPIL (CONTINUED)
;
;      HERE TO DEAL WITH FAILURE GOTO
;
CMP22::	MOVL	4*CMFGO(SP),R9	;LOAD FAILURE GOTO POINTER
	MOVL	R9,R6		;COPY IT
	CLRL	4*CMFFC(SP)	;SET NO FILL IN REQUIRED YET
	TSTL	R9		;JUMP IF NO FAILURE GOTO GIVEN
	BEQLU	CMP23
	ADDL2	#4*VRTRA,R6	;POINT TO VRTRA FIELD IN CASE
	CMPL	R9,STATE	;JUMP TO GEN IF SIMPLE FGOTO
	BLEQU	CMPSE
;
;      HERE FOR COMPLEX FAILURE GOTO
;
	MOVL	CWCOF,R7	;SAVE OFFSET TO O$GOF CALL
	MOVL	#OGOF$,R6	;POINT TO FAILURE GOTO CALL
	JSB	CDWRD		;GENERATE
	MOVL	#OFIF$,R6	;POINT TO FAIL IN FAIL WORD
	JSB	CDWRD		;GENERATE
	JSB	CDGCG		;GENERATE CODE FOR FAILURE GOTO
	MOVL	R7,R6		;COPY OFFSET TO O$GOF FOR CDFAL
	MOVL	#B$CDC,R7	;SET COMPLEX CASE CDTYP
	JMP	CMP25		;JUMP TO BUILD CDBLK
;
;      HERE IF NO FAILURE GOTO GIVEN
;
CMP23::	MOVL	#OUNF$,R6	;LOAD UNEXPECTED FAILURE CALL IN CAS
	MOVL	CSWFL,R8	;GET -NOFAIL FLAG
	BISL2	4*CMCGO(SP),R8	;CHECK IF CONDITIONAL GOTO
	BEQLU	CMPSE
	MOVL	SP,4*CMFFC(SP)	;ELSE SET FILL IN FLAG
	MOVL	#OCER$,R6	;AND SET COMPILE ERROR FOR TEMPORARY
;
;      MERGE HERE WITH CDFAL VALUE IN WA, SIMPLE CDBLK
;      ALSO SPECIAL ENTRY AFTER STATEMENT ERROR
;
CMPSE::	MOVL	#B$CDS,R7	;SET CDTYP FOR SIMPLE CASE
	.PAGE
;
;      CMPIL (CONTINUED)
;
;      MERGE HERE TO BUILD CDBLK
;
;      (WA)                  CDFAL VALUE TO BE GENERATED
;      (WB)                  CDTYP VALUE TO BE GENERATED
;
;      AT THIS STAGE, WE CHOP OFF AN APPROPRIATE CHUNK OF THE
;      CURRENT CCBLK AND CONVERT IT INTO A CDBLK. THE REMAINDER
;      OF THE CCBLK IS REFORMATTED TO BE THE NEW CCBLK.
;
CMP25::	MOVL	R$CCB,R9	;POINT TO CCBLK
	MOVL	4*CMLBL(SP),R10	;GET POSSIBLE LABEL POINTER
	TSTL	R10		;SKIP IF NO LABEL
	BEQLU	CMP26
	CLRL	4*CMLBL(SP)	;CLEAR FLAG FOR NEXT STATEMENT
	MOVL	R9,4*VRLBL(R10)	;PUT CDBLK PTR IN VRBLK LABEL FIELD
;
;      MERGE AFTER DOING LABEL
;
CMP26::	MOVL	R7,(R9)		;SET TYPE WORD FOR NEW CDBLK
	MOVL	R6,4*CDFAL(R9)	;SET FAILURE WORD
	MOVL	R9,R10		;COPY POINTER TO CCBLK
	MOVL	4*CCUSE(R9),R7	;LOAD LENGTH GEN (= NEW CDLEN)
	MOVL	4*CCLEN(R9),R8	;LOAD TOTAL CCBLK LENGTH
	ADDL2	R7,R10		;POINT PAST CDBLK
	SUBL2	R7,R8		;GET LENGTH LEFT FOR CHOP OFF
	MOVL	#B$CCT,(R10)	;SET TYPE CODE FOR NEW CCBLK AT END
	MOVL	#4*CCCOD,4*CCUSE(R10) ;SET INITIAL CODE OFFSET
	MOVL	#4*CCCOD,CWCOF	;REINITIALISE CWCOF
	MOVL	R8,4*CCLEN(R10)	;SET NEW LENGTH
	MOVL	R10,R$CCB	;SET NEW CCBLK POINTER
	MOVL	CMPSN,4*CDSTM(R9);SET STATEMENT NUMBER
	INCL	CMPSN		;BUMP STATEMENT NUMBER
;
;      SET POINTERS IN PREVIOUS CODE BLOCK AS REQUIRED
;
	MOVL	4*CMPCD(SP),R10	;LOAD PTR TO PREVIOUS CDBLK
	TSTL	4*CMFFP(SP)	;JUMP IF NO FAILURE FILL IN REQUIRED
	BEQLU	CMP27
	MOVL	R9,4*CDFAL(R10)	;ELSE SET FAILURE PTR IN PREVIOUS
;
;      HERE TO DEAL WITH SUCCESS FORWARD POINTER
;
CMP27::	MOVL	4*CMSOP(SP),R6	;LOAD SUCCESS OFFSET
	BEQLU	CMP28
	ADDL2	R6,R10		;ELSE POINT TO FILL IN LOCATION
	MOVL	R9,(R10)	;STORE FORWARD POINTER
	CLRL	R10		;CLEAR GARBAGE XL VALUE
	.PAGE
;
;      CMPIL (CONTINUED)
;
;      NOW SET FILL IN POINTERS FOR THIS STATEMENT
;
CMP28::	MOVL	4*CMFFC(SP),4*CMFFP(SP) ;COPY FAILURE FILL IN FLAG
	MOVL	4*CMSOC(SP),4*CMSOP(SP) ;COPY SUCCESS FILL IN OFFSET
	MOVL	R9,4*CMPCD(SP)	;SAVE PTR TO THIS CDBLK
	TSTL	4*CMTRA(SP)	;JUMP IF INITIAL ENTRY ALREADY SET
	BNEQU	CMP29
	MOVL	R9,4*CMTRA(SP)	;ELSE SET PTR HERE AS DEFAULT
;
;      HERE AFTER COMPILING ONE STATEMENT
;
CMP29::	CMPL	STAGE,#STGCE	;JUMP IF NOT END LINE JUST DONE
	BGEQU	5148$
	JMP	CMP01
5148$:
	TSTL	CSWLS		;SKIP IF -NOLIST
	BEQLU	CMP30
	JSB	LISTR		;LIST LAST LINE
;
;      RETURN
;
CMP30::	MOVL	4*CMTRA(SP),R9	;LOAD INITIAL ENTRY CDBLK POINTER
	ADDL2	#4*CMNEN,SP	;POP WORK LOCATIONS OFF STACK
	RSB			;AND RETURN TO CMPIL CALLER
;
;      HERE AT END OF GOTO FIELD
;
CMP31::	MOVL	4*CMFGO(SP),R7	;GET FAIL GOTO
	BISL2	4*CMSGO(SP),R7	;OR IN SUCCESS GOTO
	TSTL	R7		;OK IF NON-NULL FIELD
	BEQLU	5149$
	JMP	CMP18
5149$:
	JMP	ERROR_219	;SYNTAX ERROR. EMPTY GOTO FIELD
;
;      CONTROL CARD FOUND
;
CMP32::	INCL	R7		;POINT PAST CH$MN
	JSB	CNCRD		;PROCESS CONTROL CARD
	CLRL	SCNSE		;CLEAR START OF ELEMENT LOC.
	JMP	CMPCE		;LOOP FOR NEXT STATEMENT
	;ENP			;END PROCEDURE CMPIL
	.PAGE
;
;      CNCRD -- CONTROL CARD PROCESSOR
;
;      CALLED TO DEAL WITH CONTROL CARDS
;
;      R$CIM                 POINTS TO CURRENT IMAGE
;      (WB)                  OFFSET TO 1ST CHAR OF CONTROL CARD
;      JSR  CNCRD            CALL TO PROCESS CONTROL CARDS
;      (XL,XR,WA,WB,WC,IA)   DESTROYED
;
	.ENABLE	LOCAL_BLOCK
CNCRD::	;PRC			;ENTRY POINT
	MOVL	R7,SCNPT	;OFFSET FOR CONTROL CARD SCAN
	MOVL	#CCNOC,R6	;NUMBER OF CHARS FOR COMPARISON
	MOVAB	3+<4*0>(R6),R6	;CONVERT TO WORD COUNT
	ASHL	#-2,R6,R6
	MOVL	R6,CNSWC	;SAVE WORD COUNT
;
;      LOOP HERE IF MORE THAN ONE CONTROL CARD
;
CNC01::	CMPL	SCNPT,SCNIL	;RETURN IF END OF IMAGE
	BLSSU	5150$
	JMP	CNC09
5150$:
	MOVL	R$CIM,R9	;POINT TO IMAGE
	MOVL	SCNPT,R11	;[GET IN SCRATCH REGISTER]
	MOVAB	CFP$F(R9)[R11],R9;CHAR PTR FOR FIRST CHAR
	MOVZBL	(R9)+,R6	;GET FIRST CHAR
	CMPL	R6,#CH$LI	;SPECIAL CASE OF -INXXX
	BNEQU	5151$
	JMP	CNC07
5151$:
	MOVL	SP,SCNCC	;SET FLAG FOR SCANE
	JSB	SCANE		;SCAN CARD NAME
	CLRL	SCNCC		;CLEAR SCANE FLAG
	TSTL	R10		;FAIL UNLESS CONTROL CARD NAME
	BEQLU	5152$
	JMP	CNC06
5152$:
	MOVL	#CCNOC,R6	;NO. OF CHARS TO BE COMPARED
	CMPL	4*SCLEN(R9),R6	;FAIL IF TOO FEW CHARS
	BGEQU	5153$
	JMP	CNC06
5153$:
	MOVL	R9,R10		;POINT TO CONTROL CARD NAME
	CLRL	R7		;ZERO OFFSET FOR SUBSTRING
	JSB	SBSTR		;EXTRACT SUBSTRING FOR COMPARISON
	MOVL	R9,CNSCC	;KEEP CONTROL CARD SUBSTRING PTR
	MOVL	#CCNMS,R9	;POINT TO LIST OF STANDARD NAMES
	CLRL	R7		;INITIALISE NAME OFFSET
	MOVL	#CC$NC,R8	;NUMBER OF STANDARD NAMES
;
;      TRY TO MATCH NAME
;
CNC02::	MOVL	CNSCC,R10	;POINT TO NAME
	MOVL	CNSWC,R6	;COUNTER FOR INNER LOOP
	JMP	CNC04		;JUMP INTO LOOP
;
;      INNER LOOP TO MATCH CARD NAME CHARS
;
CNC03::	ADDL2	#4,R9		;BUMP STANDARD NAMES PTR
	ADDL2	#4,R10		;BUMP NAME POINTER
;
;      HERE TO INITIATE THE LOOP
;
CNC04::	CMPL	4*SCHAR(R10),(R9);COMP. UP TO CFP$C CHARS AT ONCE
	BNEQU	CNC05
	SOBGTR	R6,CNC03	;LOOP IF MORE WORDS TO COMPARE
	.PAGE
;
;      CNCRD (CONTINUED)
;
;      MATCHED - BRANCH ON CARD OFFSET
;
	MOVL	R7,R10		;GET NAME OFFSET
	BSW	R10,CC$NC	;SWITCH
	IFF	CC$DO,CNC10	;-DOUBLE
	IFF	CC$DU,CNC11	;-DUMP
	IFF	CC$EJ,CNC12	;-EJECT
	IFF	CC$ER,CNC13	;-ERRORS
	IFF	CC$EX,CNC14	;-EXECUTE
	IFF	CC$FA,CNC15	;-FAIL
	IFF	CC$LI,CNC16	;-LIST
	IFF	CC$NR,CNC17	;-NOERRORS
	IFF	CC$NX,CNC18	;-NOEXECUTE
	IFF	CC$NF,CNC19	;-NOFAIL
	IFF	CC$NL,CNC20	;-NOLIST
	IFF	CC$NO,CNC21	;-NOOPT
	IFF	CC$NP,CNC22	;-NOPRINT
	IFF	CC$OP,CNC24	;-OPTIMISE
	IFF	CC$PR,CNC25	;-PRINT
	IFF	CC$SI,CNC27	;-SINGLE
	IFF	CC$SP,CNC28	;-SPACE
	IFF	CC$ST,CNC31	;-STITLE
	IFF	CC$TI,CNC32	;-TITLE
	IFF	CC$TR,CNC36	;-TRACE
	ESW			;END SWITCH
;
;      NOT MATCHED YET. ALIGN STD NAMES PTR AND TRY AGAIN
;
CNC05::	ADDL2	#4,R9		;BUMP STANDARD NAMES PTR
	SOBGTR	R6,CNC05	;LOOP
	INCL	R7		;BUMP NAMES OFFSET
	SOBGTR	R8,CNC02	;CONTINUE IF MORE NAMES
;
;      INVALID CONTROL CARD NAME
;
CNC06::	JMP	ERROR_247	;INVALID CONTROL CARD
;
;      SPECIAL PROCESSING FOR -INXXX
;
CNC07::	MOVZBL	(R9),R6		;GET NEXT CHAR
	CMPL	R6,#CH$LN	;FAIL IF NOT LETTER N
	BEQLU	5154$
	JMP	CNC06
5154$:
	ADDL2	#NUM02,SCNPT	;BUMP OFFSET PAST -IN
	JSB	SCANE		;SCAN INTEGER AFTER -IN
	MOVL	R9,-(SP)	;STACK SCANNED ITEM
	JSB	GTSMI		;CHECK IF INTEGER
	.ADDRESS CNC06		;FAIL IF NOT INTEGER
	.ADDRESS CNC06		;FAIL IF NEGATIVE OR LARGE
	MOVL	R9,CSWIN	;KEEP INTEGER
	.PAGE
;
;      CNCRD (CONTINUED)
;
;      CHECK FOR MORE CONTROL CARDS BEFORE RETURNING
;
CNC08::	MOVL	SCNPT,R6	;PRESERVE IN CASE XEQ TIME COMPILE
	JSB	SCANE		;LOOK FOR COMMA
	CMPL	R10,#T$CMA	;LOOP IF COMMA FOUND
	BNEQU	5155$
	JMP	CNC01
5155$:
	MOVL	R6,SCNPT	;RESTORE SCNPT IN CASE XEQ TIME
;
;      RETURN POINT
;
CNC09::	RSB			;RETURN
;
;      -DOUBLE
;
CNC10::	MOVL	SP,CSWDB	;SET SWITCH
	JMP	CNC08		;MERGE
;
;      -DUMP
;      THIS IS USED FOR SYSTEM DEBUGGING . IT HAS THE EFFECT OF
;      PRODUCING A CORE DUMP AT COMPILATION TIME
;
CNC11::	JSB	SYSDM		;CALL DUMPER
	JMP	CNC09		;FINISHED
;
;      -EJECT
;
CNC12::	TSTL	CSWLS		;RETURN IF -NOLIST
	BNEQU	5156$
	JMP	CNC09
5156$:
	JSB	PRTPS		;EJECT
	JSB	LISTT		;LIST TITLE
	JMP	CNC09		;FINISHED
;
;      -ERRORS
;
CNC13::	CLRL	CSWER		;CLEAR SWITCH
	JMP	CNC08		;MERGE
;
;      -EXECUTE
;
CNC14::	CLRL	CSWEX		;CLEAR SWITCH
	JMP	CNC08		;MERGE
;
;      -FAIL
;
CNC15::	MOVL	SP,CSWFL	;SET SWITCH
	JMP	CNC08		;MERGE
;
;      -LIST
;
CNC16::	MOVL	SP,CSWLS	;SET SWITCH
	CMPL	STAGE,#STGIC	;DONE IF COMPILE TIME
	BEQLU	CNC08
;
;      LIST CODE LINE IF EXECUTE TIME COMPILE
;
	CLRL	LSTPF		;PERMIT LISTING
	JSB	LISTR		;LIST LINE
	JMP	CNC08		;MERGE
	.PAGE
;
;      CNCRD (CONTINUED)
;
;      -NOERRORS
;
CNC17::	MOVL	SP,CSWER	;SET SWITCH
	JMP	CNC08		;MERGE
;
;      -NOEXECUTE
;
CNC18::	MOVL	SP,CSWEX	;SET SWITCH
	JMP	CNC08		;MERGE
;
;      -NOFAIL
;
CNC19::	CLRL	CSWFL		;CLEAR SWITCH
	JMP	CNC08		;MERGE
;
;      -NOLIST
;
CNC20::	CLRL	CSWLS		;CLEAR SWITCH
	JMP	CNC08		;MERGE
;
;      -NOOPTIMISE
;
CNC21::	MOVL	SP,CSWNO	;SET SWITCH
	JMP	CNC08		;MERGE
;
;      -NOPRINT
;
CNC22::	CLRL	CSWPR		;CLEAR SWITCH
	JMP	CNC08		;MERGE
;
;      -OPTIMISE
;
CNC24::	CLRL	CSWNO		;CLEAR SWITCH
	JMP	CNC08		;MERGE
;
;      -PRINT
;
CNC25::	MOVL	SP,CSWPR	;SET SWITCH
	JMP	CNC08		;MERGE
	.PAGE
;
;      CNCRD (CONTINUED)
;
;      -SINGLE
;
CNC27::	CLRL	CSWDB		;CLEAR SWITCH
	JMP	CNC08		;MERGE
;
;      -SPACE
;
CNC28::	TSTL	CSWLS		;RETURN IF -NOLIST
	BNEQU	5157$
	JMP	CNC09
5157$:
	JSB	SCANE		;SCAN INTEGER AFTER -SPACE
	MOVL	#NUM01,R8	;1 SPACE IN CASE
	CMPL	R9,#T$SMC	;JUMP IF NO INTEGER
	BEQLU	CNC29
	MOVL	R9,-(SP)	;STACK IT
	JSB	GTSMI		;CHECK INTEGER
	.ADDRESS CNC06		;FAIL IF NOT INTEGER
	.ADDRESS CNC06		;FAIL IF NEGATIVE OR LARGE
	TSTL	R8		;JUMP IF NON ZERO
	BNEQU	CNC29
	MOVL	#NUM01,R8	;ELSE 1 SPACE
;
;      MERGE WITH COUNT OF LINES TO SKIP
;
CNC29::	ADDL2	R8,LSTLC	;BUMP LINE COUNT
				;CONVERT TO LOOP COUNTER
	CMPL	LSTLC,LSTNP	;JUMP IF FITS ON PAGE
	BLSSU	CNC30
	JSB	PRTPS		;EJECT
	JSB	LISTT		;LIST TITLE
	JMP	CNC09		;MERGE
;
;      SKIP LINES
;
CNC30::	JSB	PRTNL		;PRINT A BLANK
	SOBGTR	R8,CNC30	;LOOP
	JMP	CNC09		;MERGE
	.PAGE
;
;      CNCRD (CONTINUED)
;
;      -STITL
;
CNC31::	MOVL	#R$STL,CNR$T	;PTR TO R$STL
	JMP	CNC33		;MERGE
;
;      -TITLE
;
CNC32::	MOVL	#NULLS,R$STL	;CLEAR SUBTITLE
	MOVL	#R$TTL,CNR$T	;PTR TO R$TTL
;
;      COMMON PROCESSING FOR -TITLE, -STITL
;
CNC33::	MOVL	#NULLS,R9	;NULL IN CASE NEEDED
	MOVL	SP,CNTTL	;SET FLAG FOR NEXT LISTR CALL
	MOVL	#CCOFS,R7	;OFFSET TO TITLE/SUBTITLE
	MOVL	SCNIL,R6	;INPUT IMAGE LENGTH
	CMPL	R6,R7		;JUMP IF NO CHARS LEFT
	BLEQU	CNC34
	SUBL2	R7,R6		;NO OF CHARS TO EXTRACT
	MOVL	R$CIM,R10	;POINT TO IMAGE
	JSB	SBSTR		;GET TITLE/SUBTITLE
;
;      STORE TITLE/SUBTITLE
;
CNC34::	MOVL	CNR$T,R10	;POINT TO STORAGE LOCATION
	MOVL	R9,(R10)	;STORE TITLE/SUBTITLE
	CMPL	R10,#R$STL	;RETURN IF STITL
	BNEQU	5158$
	JMP	CNC09
5158$:
	TSTL	PRECL		;RETURN IF EXTENDED LISTING
	BEQLU	5159$
	JMP	CNC09
5159$:
	TSTL	PRICH		;RETURN IF REGULAR PRINTER
	BNEQU	5160$
	JMP	CNC09
5160$:
	MOVL	4*SCLEN(R9),R10	;GET LENGTH OF TITLE
	MOVL	R10,R6		;COPY IT
	TSTL	R10		;JUMP IF NULL
	BEQLU	CNC35
	ADDL2	#NUM10,R10	;INCREMENT
	CMPL	R10,PRLEN	;USE DEFAULT LSTP0 VAL IF TOO LONG
	BLSSU	5161$
	JMP	CNC09
5161$:
	ADDL2	#NUM04,R6	;POINT JUST PAST TITLE
;
;      STORE OFFSET TO PAGE NN MESSAGE FOR SHORT TITLE
;
CNC35::	MOVL	R6,LSTPO	;STORE OFFSET
	JMP	CNC09		;RETURN
;
;      -TRACE
;      PROVIDED FOR SYSTEM DEBUGGING.  TOGGLES THE SYSTEM LABEL
;      TRACE SWITCH AT COMPILE TIME
;
CNC36::	JSB	SYSTT		;TOGGLE SWITCH
	JMP	CNC08		;MERGE
	;ENP			;END PROCEDURE CNCRD
	.PAGE
;
;      DFFNC -- DEFINE FUNCTION
;
;      DFFNC IS CALLED WHENEVER A NEW FUNCTION IS ASSIGNED TO
;      A VARIABLE. IT DEALS WITH EXTERNAL FUNCTION USE COUNTS.
;
;      (XR)                  POINTER TO VRBLK
;      (XL)                  POINTER TO NEW FUNCTION BLOCK
;      JSR  DFFNC            CALL TO DEFINE FUNCTION
;      (WA,WB)               DESTROYED
;
	.ENABLE	LOCAL_BLOCK
DFFNC::	;PRC			;ENTRY POINT
	CMPL	(R10),#B$EFC	;SKIP IF NEW FUNCTION NOT EXTERNAL
	BNEQU	DFFN1
	INCL	4*EFUSE(R10)	;ELSE INCREMENT ITS USE COUNT
;
;      HERE AFTER DEALING WITH NEW FUNCTION USE COUNT
;
DFFN1::	MOVL	R9,R6		;SAVE VRBLK POINTER
	.IF NOT_EQUAL CNLD
	.IF_FALSE
	MOVL	4*VRFNC(R9),R9	;LOAD OLD FUNCTION POINTER
	CMPL	(R9),#B$EFC	;JUMP IF OLD FUNCTION NOT EXTERNAL
	BNEQU	DFFN2
	MOVL	4*EFUSE(R9),R7	;ELSE GET USE COUNT
	DECL	R7		;DECREMENT
	MOVL	R7,4*EFUSE(R9)	;STORE DECREMENTED VALUE
	TSTL	R7		;JUMP IF USE COUNT STILL NON-ZERO
	BNEQU	DFFN2
	JSB	SYSUL		;ELSE CALL SYSTEM UNLOAD FUNCTION
	.ENDC
;
;      HERE AFTER DEALING WITH OLD FUNCTION USE COUNT
;
DFFN2::	MOVL	R6,R9		;RESTORE VRBLK POINTER
	MOVL	R10,R6		;COPY FUNCTION BLOCK PTR
	CMPL	R9,#R$YYY	;SKIP CHECKS IF OPSYN OP DEFINITION
	BLSSU	DFFN3
	TSTL	4*VRLEN(R9)	;JUMP IF NOT SYSTEM VARIABLE
	BNEQU	DFFN3
;
;      FOR SYSTEM VARIABLE, CHECK FOR ILLEGAL REDEFINITION
;
	MOVL	4*VRSVP(R9),R10	;POINT TO SVBLK
	MOVL	4*SVBIT(R10),R7	;LOAD BIT INDICATORS
	MCOML	BTFNC,R11	;IS IT A SYSTEM FUNCTION
	BICL2	R11,R7
	BEQLU	DFFN3
	JMP	ERROR_248	;ATTEMPTED REDEFINITION OF SYSTEM FUNCTION
;
;      HERE IF REDEFINITION IS PERMITTED
;
DFFN3::	MOVL	R6,4*VRFNC(R9)	;STORE NEW FUNCTION POINTER
	MOVL	R6,R10		;RESTORE FUNCTION BLOCK POINTER
	RSB			;RETURN TO DFFNC CALLER
	;ENP			;END PROCEDURE DFFNC
	.PAGE
;
;      DTACH -- DETACH I/O ASSOCIATED NAMES
;
;      DETACHES TRBLKS FROM I/O ASSOCIATED VARIABLES, REMOVES
;      ENTRY FROM IOCHN CHAIN ATTACHED TO FILEARG1 VRBLK AND MAY
;      REMOVE VRBLK ACCESS AND STORE TRAPS.
;      INPUT, OUTPUT, TERMINAL ARE HANDLED SPECIALLY.
;
;      (XL)                  I/O ASSOC. VBL NAME BASE PTR
;      (WA)                  OFFSET TO NAME
;      JSR  DTACH            CALL FOR DETACH OPERATION
;      (XL,XR,WA,WB,WC)      DESTROYED
;
	.ENABLE	LOCAL_BLOCK
DTACH::	;PRC			;ENTRY POINT
	MOVL	R10,DTCNB	;STORE NAME BASE (GBCOL NOT CALLED)
	ADDL2	R6,R10		;POINT TO NAME LOCATION
	MOVL	R10,DTCNM	;STORE IT
;
;      LOOP TO SEARCH FOR I/O TRBLK
;
DTCH1::	MOVL	R10,R9		;COPY NAME POINTER
;
;      CONTINUE AFTER BLOCK DELETION
;
DTCH2::	MOVL	(R10),R10	;POINT TO NEXT VALUE
	CMPL	(R10),#B$TRT	;JUMP AT CHAIN END
	BNEQU	DTCH6
	MOVL	4*TRTYP(R10),R6	;GET TRAP BLOCK TYPE
	CMPL	R6,#TRTIN	;JUMP IF INPUT
	BEQLU	DTCH3
	CMPL	R6,#TRTOU	;JUMP IF OUTPUT
	BEQLU	DTCH3
	ADDL2	#4*TRNXT,R10	;POINT TO NEXT LINK
	JMP	DTCH1		;LOOP
;
;      DELETE AN OLD ASSOCIATION
;
DTCH3::	MOVL	4*TRVAL(R10),(R9);DELETE TRBLK
	MOVL	R10,R6		;DUMP XL ...
	MOVL	R9,R7		;... AND XR
	MOVL	4*TRTRF(R10),R10;POINT TO TRTRF TRAP BLOCK
	TSTL	R10		;JUMP IF NO IOCHN
	BEQLU	DTCH5
	CMPL	(R10),#B$TRT	;JUMP IF INPUT, OUTPUT, TERMINAL
	BNEQU	DTCH5
;
;      LOOP TO SEARCH IOCHN CHAIN FOR NAME PTR
;
DTCH4::	MOVL	R10,R9		;REMEMBER LINK PTR
	MOVL	4*TRTRF(R10),R10;POINT TO NEXT LINK
	TSTL	R10		;JUMP IF END OF CHAIN
	BEQLU	DTCH5
	MOVL	4*IONMB(R10),R8	;GET NAME BASE
	ADDL2	4*IONMO(R10),R8	;ADD OFFSET
	CMPL	R8,DTCNM	;LOOP IF NO MATCH
	BNEQU	DTCH4
	MOVL	4*TRTRF(R10),4*TRTRF(R9) ;REMOVE NAME FROM CHAIN
	.PAGE
;
;      DTACH (CONTINUED)
;
;      PREPARE TO RESUME I/O TRBLK SCAN
;
DTCH5::	MOVL	R6,R10		;RECOVER XL ...
	MOVL	R7,R9		;... AND XR
	ADDL2	#4*TRVAL,R10	;POINT TO VALUE FIELD
	JMP	DTCH2		;CONTINUE
;
;      EXIT POINT
;
DTCH6::	MOVL	DTCNB,R9	;POSSIBLE VRBLK PTR
	JSB	SETVR		;RESET VRBLK IF NECESSARY
	RSB			;RETURN
	;ENP			;END PROCEDURE DTACH
	.PAGE
;
;      DTYPE -- GET DATATYPE NAME
;
;      (XR)                  OBJECT WHOSE DATATYPE IS REQUIRED
;      JSR  DTYPE            CALL TO GET DATATYPE
;      (XR)                  RESULT DATATYPE
;
	.ENABLE	LOCAL_BLOCK
DTYPE::	;PRC			;ENTRY POINT
	CMPL	(R9),#B$PDT	;JUMP IF PROG.DEFINED
	BEQLU	DTYP1
	MOVL	(R9),R9		;LOAD TYPE WORD
	MOVZWL	-2(R9),R9	;GET ENTRY POINT ID (BLOCK CODE)
	MOVAL	0[R9],R9	;CONVERT TO BYTE OFFSET
	MOVL	L^SCNMT(R9),R9	;LOAD TABLE ENTRY
	RSB			;EXIT TO DTYPE CALLER
;
;      HERE IF PROGRAM DEFINED
;
DTYP1::	MOVL	4*PDDFP(R9),R9	;POINT TO DFBLK
	MOVL	4*DFNAM(R9),R9	;GET DATATYPE NAME FROM DFBLK
	RSB			;RETURN TO DTYPE CALLER
	;ENP			;END PROCEDURE DTYPE
	.PAGE
;
;      DUMPR -- PRINT DUMP OF STORAGE
;
;      (XR)                  DUMP ARGUMENT (SEE BELOW)
;      JSR  DUMPR            CALL TO PRINT DUMP
;      (XR,XL)               DESTROYED
;      (WA,WB,WC,RA)         DESTROYED
;
;      THE DUMP ARGUMENT HAS THE FOLLOWING SIGNIFICANCE
;
;      DMARG = 0             NO DUMP PRINTED
;      DMARG = 1             PARTIAL DUMP (NAT VARS, KEYWORDS)
;      DMARG EQ 2            FULL DUMP (INCL ARRAYS ETC.)
;      DMARG GE 3            CORE DUMP
;
;      SINCE DUMPR SCRAMBLES STORE, IT IS NOT PERMISSIBLE TO
;      COLLECT IN MID-DUMP. HENCE A COLLECT IS DONE INITIALLY
;      AND THEN IF STORE RUNS OUT AN ERROR MESSAGE IS PRODUCED.
;
	.ENABLE	LOCAL_BLOCK
DUMPR::	;PRC			;ENTRY POINT
	TSTL	R9		;SKIP DUMP IF ARGUMENT IS ZERO
	BNEQU	5162$
	JMP	DMP28
5162$:
	CMPL	R9,#NUM02	;JUMP IF CORE DUMP REQUIRED
	BLEQU	5163$
	JMP	DMP29
5163$:
	CLRL	R10		;CLEAR XL
	CLRL	R7		;ZERO MOVE OFFSET
	MOVL	R9,DMARG	;SAVE DUMP ARGUMENT
	JSB	GBCOL		;COLLECT GARBAGE
	JSB	PRTPG		;EJECT PRINTER
	MOVL	#DMHDV,R9	;POINT TO HEADING FOR VARIABLES
	JSB	PRTST		;PRINT IT
	JSB	PRTNL		;TERMINATE PRINT LINE
	JSB	PRTNL		;AND PRINT A BLANK LINE
;
;      FIRST ALL NATURAL VARIABLE BLOCKS (VRBLK) WHOSE VALUES
;      ARE NON-NULL ARE LINKED IN LEXICAL ORDER USING DMVCH AS
;      THE CHAIN HEAD AND CHAINING THROUGH THE VRGET FIELDS.
;      NOTE THAT THIS SCRAMBLES STORE IF THE PROCESS IS
;      INTERRUPTED BEFORE COMPLETION E.G. BY EXCEEDING TIME  OR
;      PRINT LIMITS. SINCE THE SUBSEQUENT CORE DUMPS AND
;      FAILURES IF EXECUTION IS RESUMED ARE VERY CONFUSING, THE
;      EXECUTION TIME ERROR ROUTINE CHECKS FOR THIS EVENT AND
;      ATTEMPTS AN UNSCRAMBLE. SIMILAR PRECAUTIONS SHOULD BE
;      OBSERVED IF TRANSLATE TIME DUMPING IS IMPLEMENTED.
;
	CLRL	DMVCH		;SET NULL CHAIN TO START
	MOVL	HSHTB,R6	;POINT TO HASH TABLE
;
;      LOOP THROUGH HEADERS IN HASH TABLE
;
DMP00::	MOVL	R6,R9		;COPY HASH BUCKET POINTER
	ADDL2	#4,R6		;BUMP POINTER
	SUBL2	#4*VRNXT,R9	;SET OFFSET TO MERGE
;
;      LOOP THROUGH VRBLKS ON ONE CHAIN
;
DMP01::	MOVL	4*VRNXT(R9),R9	;POINT TO NEXT VRBLK ON CHAIN
	BNEQU	5164$
	JMP	DMP09
5164$:
	MOVL	R9,R10		;ELSE COPY VRBLK POINTER
	.PAGE
;
;      DUMPR (CONTINUED)
;
;      LOOP TO FIND VALUE AND SKIP IF NULL
;
DMP02::	MOVL	4*VRVAL(R10),R10;LOAD VALUE
	CMPL	R10,#NULLS	;LOOP FOR NEXT VRBLK IF NULL VALUE
	BEQLU	DMP01
	CMPL	(R10),#B$TRT	;LOOP BACK IF VALUE IS TRAPPED
	BEQLU	DMP02
;
;      NON-NULL VALUE, PREPARE TO SEARCH CHAIN
;
	MOVL	R9,R8		;SAVE VRBLK POINTER
	ADDL2	#4*VRSOF,R9	;ADJUST PTR TO BE LIKE SCBLK PTR
	TSTL	4*SCLEN(R9)	;JUMP IF NON-SYSTEM VARIABLE
	BNEQU	DMP03
	MOVL	4*VRSVO(R9),R9	;ELSE LOAD PTR TO NAME IN SVBLK
;
;      HERE WITH NAME POINTER FOR NEW BLOCK IN XR
;
DMP03::	MOVL	R9,R7		;SAVE POINTER TO CHARS
	MOVL	R6,DMPSV	;SAVE HASH BUCKET POINTER
	MOVL	#DMVCH,R6	;POINT TO CHAIN HEAD
;
;      LOOP TO SEARCH CHAIN FOR CORRECT INSERTION POINT
;
DMP04::	MOVL	R6,DMPCH	;SAVE CHAIN POINTER
	MOVL	R6,R10		;COPY IT
	MOVL	(R10),R9	;LOAD POINTER TO NEXT ENTRY
	TSTL	R9		;JUMP IF END OF CHAIN TO INSERT
	BNEQU	5165$
	JMP	DMP08
5165$:
	ADDL2	#4*VRSOF,R9	;ELSE GET NAME PTR FOR CHAINED VRBLK
	TSTL	4*SCLEN(R9)	;JUMP IF NOT SYSTEM VARIABLE
	BNEQU	DMP05
	MOVL	4*VRSVO(R9),R9	;ELSE POINT TO NAME IN SVBLK
;
;      HERE PREPARE TO COMPARE THE NAMES
;
;      (WA)                  SCRATCH
;      (WB)                  POINTER TO STRING OF ENTERING VRBLK
;      (WC)                  POINTER TO ENTERING VRBLK
;      (XR)                  POINTER TO STRING OF CURRENT BLOCK
;      (XL)                  SCRATCH
;
DMP05::	MOVL	R7,R10		;POINT TO ENTERING VRBLK STRING
	MOVL	4*SCLEN(R10),R6	;LOAD ITS LENGTH
	MOVAB	CFP$F(R10),R10	;POINT TO CHARS OF ENTERING STRING
	CMPL	R6,4*SCLEN(R9)	;JUMP IF ENTERING LENGTH HIGH
	BGEQU	DMP06
	MOVAB	CFP$F(R9),R9	;ELSE POINT TO CHARS OF OLD STRING
	CMC	DMP08,DMP07	;COMPARE, INSERT IF NEW IS LLT OLD
	JMP	DMP08		;OR IF LEQ (WE HAD SHORTER LENGTH)
;
;      HERE WHEN NEW LENGTH IS LONGER THAN OLD LENGTH
;
DMP06::	MOVL	4*SCLEN(R9),R6	;LOAD SHORTER LENGTH
	MOVAB	CFP$F(R9),R9	;POINT TO CHARS OF OLD STRING
	CMC	DMP08,DMP07	;COMPARE, INSERT IF NEW ONE LOW
	.PAGE
;
;      DUMPR (CONTINUED)
;
;      HERE WE MOVE OUT ON THE CHAIN
;
DMP07::	MOVL	DMPCH,R10	;COPY CHAIN POINTER
	MOVL	(R10),R6	;MOVE TO NEXT ENTRY ON CHAIN
	JMP	DMP04		;LOOP BACK
;
;      HERE AFTER LOCATING THE PROPER INSERTION POINT
;
DMP08::	MOVL	DMPCH,R10	;COPY CHAIN POINTER
	MOVL	DMPSV,R6	;RESTORE HASH BUCKET POINTER
	MOVL	R8,R9		;RESTORE VRBLK POINTER
	MOVL	(R10),4*VRGET(R9);LINK VRBLK TO REST OF CHAIN
	MOVL	R9,(R10)	;LINK VRBLK INTO CURRENT CHAIN LOC
	JMP	DMP01		;LOOP BACK FOR NEXT VRBLK
;
;      HERE AFTER PROCESSING ALL VRBLKS ON ONE CHAIN
;
DMP09::	CMPL	R6,HSHTE	;LOOP BACK IF MORE BUCKETS TO GO
	BEQLU	5166$
	JMP	DMP00
5166$:
;
;      LOOP TO GENERATE DUMP OF NATURAL VARIABLE VALUES
;
DMP10::	MOVL	DMVCH,R9	;LOAD POINTER TO NEXT ENTRY ON CHAIN
	BEQLU	DMP11
	MOVL	(R9),DMVCH	;ELSE UPDATE CHAIN PTR TO NEXT ENTRY
	JSB	SETVR		;RESTORE VRGET FIELD
	MOVL	R9,R10		;COPY VRBLK POINTER (NAME BASE)
	MOVL	#4*VRVAL,R6	;SET OFFSET FOR VRBLK NAME
	JSB	PRTNV		;PRINT NAME = VALUE
	JMP	DMP10		;LOOP BACK TILL ALL PRINTED
;
;      PREPARE TO PRINT KEYWORDS
;
DMP11::	JSB	PRTNL		;PRINT BLANK LINE
	JSB	PRTNL		;AND ANOTHER
	MOVL	#DMHDK,R9	;POINT TO KEYWORD HEADING
	JSB	PRTST		;PRINT HEADING
	JSB	PRTNL		;END LINE
	JSB	PRTNL		;PRINT ONE BLANK LINE
	MOVL	#VDMKW,R10	;POINT TO LIST OF KEYWORD SVBLK PTRS
	.PAGE
;
;      DUMPR (CONTINUED)
;
;      LOOP TO DUMP KEYWORD VALUES
;
DMP12::	MOVL	(R10)+,R9	;LOAD NEXT SVBLK PTR FROM TABLE
	BEQLU	DMP13
	MOVL	#CH$AM,R6	;LOAD AMPERSAND
	JSB	PRTCH		;PRINT AMPERSAND
	JSB	PRTST		;PRINT KEYWORD NAME
	MOVL	4*SVLEN(R9),R6	;LOAD NAME LENGTH FROM SVBLK
	MOVAB	3+<4*SVCHS>(R6),R6 ;GET LENGTH OF NAME
	BICL2	#3,R6
	ADDL2	R6,R9		;POINT TO SVKNM FIELD
	MOVL	(R9),DMPKN	;STORE IN DUMMY KVBLK
	MOVL	#TMBEB,R9	;POINT TO BLANK-EQUAL-BLANK
	JSB	PRTST		;PRINT IT
	MOVL	R10,DMPSV	;SAVE TABLE POINTER
	MOVL	#DMPKB,R10	;POINT TO DUMMY KVBLK
	MOVL	#4*KVVAR,R6	;SET ZERO OFFSET
	JSB	ACESS		;GET KEYWORD VALUE
	.ADDRESS INVALID$	;FAILURE IS IMPOSSIBLE
	JSB	PRTVL		;PRINT KEYWORD VALUE
	JSB	PRTNL		;TERMINATE PRINT LINE
	MOVL	DMPSV,R10	;RESTORE TABLE POINTER
	JMP	DMP12		;LOOP BACK TILL ALL PRINTED
;
;      HERE AFTER COMPLETING PARTIAL DUMP
;
DMP13::	CMPL	DMARG,#NUM01	;EXIT IF PARTIAL DUMP COMPLETE
	BNEQU	5167$
	JMP	DMP27
5167$:
	MOVL	DNAMB,R9	;ELSE POINT TO FIRST DYNAMIC BLOCK
;
;      LOOP THROUGH BLOCKS IN DYNAMIC STORAGE
;
DMP14::	CMPL	R9,DNAMP	;JUMP IF END OF USED REGION
	BNEQU	5168$
	JMP	DMP27
5168$:
	MOVL	(R9),R6		;ELSE LOAD FIRST WORD OF BLOCK
	CMPL	R6,#B$VCT	;JUMP IF VECTOR
	BEQLU	DMP16
	CMPL	R6,#B$ART	;JUMP IF ARRAY
	BEQLU	DMP17
	CMPL	R6,#B$PDT	;JUMP IF PROGRAM DEFINED
	BEQLU	DMP18
	CMPL	R6,#B$TBT	;JUMP IF TABLE
	BEQLU	DMP19
;
;      MERGE HERE TO MOVE TO NEXT BLOCK
;
DMP15::	JSB	BLKLN		;GET LENGTH OF BLOCK
	ADDL2	R6,R9		;POINT PAST THIS BLOCK
	JMP	DMP14		;LOOP BACK FOR NEXT BLOCK
	.PAGE
;
;      DUMPR (CONTINUED)
;
;      HERE FOR VECTOR
;
DMP16::	MOVL	#4*VCVLS,R7	;SET OFFSET TO FIRST VALUE
	JMP	DMP19		;JUMP TO MERGE
;
;      HERE FOR ARRAY
;
DMP17::	MOVL	4*AROFS(R9),R7	;SET OFFSET TO ARPRO FIELD
	ADDL2	#4,R7		;BUMP TO GET OFFSET TO VALUES
	JMP	DMP19		;JUMP TO MERGE
;
;      HERE FOR PROGRAM DEFINED
;
DMP18::	MOVL	#4*PDFLD,R7	;POINT TO VALUES, MERGE
;
;      HERE FOR TABLE (OTHERS MERGE)
;
DMP19::	TSTL	4*IDVAL(R9)	;IGNORE BLOCK IF ZERO ID VALUE
	BEQLU	DMP15
	JSB	BLKLN		;ELSE GET BLOCK LENGTH
	MOVL	R9,R10		;COPY BLOCK POINTER
	MOVL	R6,DMPSV	;SAVE LENGTH
	MOVL	R7,R6		;COPY OFFSET TO FIRST VALUE
	JSB	PRTNL		;PRINT BLANK LINE
	MOVL	R6,DMPSA	;PRESERVE OFFSET
	JSB	PRTVL		;PRINT BLOCK VALUE (FOR TITLE)
	MOVL	DMPSA,R6	;RECOVER OFFSET
	JSB	PRTNL		;END PRINT LINE
	CMPL	(R9),#B$TBT	;JUMP IF TABLE
	BEQLU	DMP22
	SUBL2	#4,R6		;POINT BEFORE FIRST WORD
;
;      LOOP TO PRINT CONTENTS OF ARRAY, VECTOR, OR PROGRAM DEF
;
DMP20::	MOVL	R10,R9		;COPY BLOCK POINTER
	ADDL2	#4,R6		;BUMP OFFSET
	ADDL2	R6,R9		;POINT TO NEXT VALUE
	CMPL	R6,DMPSV	;EXIT IF END (XR PAST BLOCK)
	BNEQU	5169$
	JMP	DMP14
5169$:
	SUBL2	#4*VRVAL,R9	;SUBTRACT OFFSET TO MERGE INTO LOOP
;
;      LOOP TO FIND VALUE AND IGNORE NULLS
;
DMP21::	MOVL	4*VRVAL(R9),R9	;LOAD NEXT VALUE
	CMPL	R9,#NULLS	;LOOP BACK IF NULL VALUE
	BEQLU	DMP20
	CMPL	(R9),#B$TRT	;LOOP BACK IF TRAPPED
	BEQLU	DMP21
	JSB	PRTNV		;ELSE PRINT NAME = VALUE
	JMP	DMP20		;LOOP BACK FOR NEXT FIELD
	.PAGE
;
;      DUMPR (CONTINUED)
;
;      HERE TO DUMP A TABLE
;
DMP22::	MOVL	#4*TBBUK,R8	;SET OFFSET TO FIRST BUCKET
	MOVL	#4*TEVAL,R6	;SET NAME OFFSET FOR ALL TEBLKS
;
;      LOOP THROUGH TABLE BUCKETS
;
DMP23::	MOVL	R10,-(SP)	;SAVE TBBLK POINTER
	ADDL2	R8,R10		;POINT TO NEXT BUCKET HEADER
	ADDL2	#4,R8		;BUMP BUCKET OFFSET
	SUBL2	#4*TENXT,R10	;SUBTRACT OFFSET TO MERGE INTO LOOP
;
;      LOOP TO PROCESS TEBLKS ON ONE CHAIN
;
DMP24::	MOVL	4*TENXT(R10),R10;POINT TO NEXT TEBLK
	CMPL	R10,(SP)	;JUMP IF END OF CHAIN
	BEQLU	DMP26
	MOVL	R10,R9		;ELSE COPY TEBLK POINTER
;
;      LOOP TO FIND VALUE AND IGNORE IF NULL
;
DMP25::	MOVL	4*TEVAL(R9),R9	;LOAD NEXT VALUE
	CMPL	R9,#NULLS	;IGNORE IF NULL VALUE
	BEQLU	DMP24
	CMPL	(R9),#B$TRT	;LOOP BACK IF TRAPPED
	BEQLU	DMP25
	MOVL	R8,DMPSV	;ELSE SAVE OFFSET POINTER
	JSB	PRTNV		;PRINT NAME = VALUE
	MOVL	DMPSV,R8	;RELOAD OFFSET
	JMP	DMP24		;LOOP BACK FOR NEXT TEBLK
;
;      HERE TO MOVE TO NEXT HASH CHAIN
;
DMP26::	MOVL	(SP)+,R10	;RESTORE TBBLK POINTER
	CMPL	R8,4*TBLEN(R10)	;LOOP BACK IF MORE BUCKETS TO GO
	BNEQU	DMP23
	MOVL	R10,R9		;ELSE COPY TABLE POINTER
	ADDL2	R8,R9		;POINT TO FOLLOWING BLOCK
	JMP	DMP14		;LOOP BACK TO PROCESS NEXT BLOCK
;
;      HERE AFTER COMPLETING DUMP
;
DMP27::	JSB	PRTPG		;EJECT PRINTER
;
;      MERGE HERE IF NO DUMP GIVEN (DMARG=0)
;
DMP28::	RSB			;RETURN TO DUMP CALLER
;
;      CALL SYSTEM CORE DUMP ROUTINE
;
DMP29::	JSB	SYSDM		;CALL IT
	JMP	DMP28		;RETURN
	;ENP			;END PROCEDURE DUMPR
	.PAGE
;
;      ERMSG -- PRINT ERROR CODE AND ERROR MESSAGE
;
;      KVERT                 ERROR CODE
;      JSR  ERMSG            CALL TO PRINT MESSAGE
;      (XR,XL,WA,WB,WC,IA)   DESTROYED
;
	.ENABLE	LOCAL_BLOCK
ERMSG::	;PRC			;ENTRY POINT
	JSB	PRTIS		;PRINT ERROR PTR OR BLANK LINE
	MOVL	KVERT,R6	;LOAD ERROR CODE
	MOVL	#ERMMS,R9	;POINT TO ERROR MESSAGE /ERROR/
	JSB	PRTST		;PRINT IT
	JSB	ERTEX		;GET ERROR MESSAGE TEXT
	ADDL2	#THSND,R6	;BUMP ERROR CODE FOR PRINT
	MOVL	R6,R5		;FAIL CODE IN INT ACC
	JSB	PRTIN		;PRINT CODE (NOW HAVE ERROR1XXX)
	MOVL	PRBUF,R10	;POINT TO PRINT BUFFER
	MOVL	#NUM05,R11	;[GET IN SCRATCH REGISTER]
	MOVAB	CFP$F(R10)[R11],R10 ;POINT TO THE 1
	MOVL	#CH$BL,R6	;LOAD A BLANK
	MOVB	R6,(R10)	;STORE BLANK OVER 1 (ERROR XXX)
	;CSC	R10		;COMPLETE STORE CHARACTERS
	CLRL	R10		;CLEAR GARBAGE POINTER IN XL
	MOVL	R9,R6		;KEEP ERROR TEXT
	MOVL	#ERMNS,R9	;POINT TO / -- /
	JSB	PRTST		;PRINT IT
	MOVL	R6,R9		;GET ERROR TEXT AGAIN
	JSB	PRTST		;PRINT ERROR MESSAGE TEXT
	JSB	PRTIS		;PRINT LINE
	JSB	PRTIS		;PRINT BLANK LINE
	RSB			;RETURN TO ERMSG CALLER
	;ENP			;END PROCEDURE ERMSG
	.PAGE
;
;      ERTEX -- GET ERROR MESSAGE TEXT
;
;      (WA)                  ERROR CODE
;      JSR  ERTEX            CALL TO GET ERROR TEXT
;      (XR)                  PTR TO ERROR TEXT IN DYNAMIC
;      (R$ETX)               COPY OF PTR TO ERROR TEXT
;      (XL,WC,IA)            DESTROYED
;
	.ENABLE	LOCAL_BLOCK
ERTEX::	;PRC			;ENTRY POINT
	MOVL	R6,ERTWA	;SAVE WA
	MOVL	R7,ERTWB	;SAVE WB
	JSB	SYSEM		;GET FAILURE MESSAGE TEXT
	MOVL	R9,R10		;COPY POINTER TO IT
	MOVL	4*SCLEN(R9),R6	;GET LENGTH OF STRING
	TSTL	R6		;JUMP IF NULL
	BEQLU	ERT02
	CLRL	R7		;OFFSET OF ZERO
	JSB	SBSTR		;COPY INTO DYNAMIC STORE
	MOVL	R9,R$ETX	;STORE FOR RELOCATION
;
;      RETURN
;
ERT01::	MOVL	ERTWB,R7	;RESTORE WB
	MOVL	ERTWA,R6	;RESTORE WA
	RSB			;RETURN TO CALLER
;
;      RETURN ERRTEXT CONTENTS INSTEAD OF NULL
;
ERT02::	MOVL	R$ETX,R9	;GET ERRTEXT
	JMP	ERT01		;RETURN
	;ENP
	.PAGE
;
;      EVALI -- EVALUATE INTEGER ARGUMENT
;
;      EVALI IS USED BY PATTERN PRIMITIVES LEN,TAB,RTAB,POS,RPOS
;      WHEN THEIR ARGUMENT IS AN EXPRESSION VALUE.
;
;      (XR)                  NODE POINTER
;      (WB)                  CURSOR
;      JSR  EVALI            CALL TO EVALUATE INTEGER
;      PPM  LOC              TRANSFER LOC FOR NON-INTEGER ARG
;      PPM  LOC              TRANSFER LOC FOR OUT OF RANGE ARG
;      PPM  LOC              TRANSFER LOC FOR EVALUATION FAILURE
;      PPM  LOC              TRANSFER LOC FOR SUCCESSFUL EVAL
;      (THE NORMAL RETURN IS NEVER TAKEN)
;      (XR)                  PTR TO NODE WITH INTEGER ARGUMENT
;      (WC,XL,RA)            DESTROYED
;
;      ON RETURN, THE NODE POINTED TO HAS THE INTEGER ARGUMENT
;      IN PARM1 AND THE PROPER SUCCESSOR POINTER IN PTHEN.
;      THIS ALLOWS MERGING WITH THE NORMAL (INTEGER ARG) CASE.
;
	.ENABLE	LOCAL_BLOCK
EVALI::	;PRC			;ENTRY POINT (RECURSIVE)
	JSB	EVALP		;EVALUATE EXPRESSION
	.ADDRESS EVLI1		;JUMP ON FAILURE
	MOVL	R10,-(SP)	;STACK RESULT FOR GTSMI
	MOVL	4*PTHEN(R9),R10	;LOAD SUCCESSOR POINTER
	JSB	GTSMI		;CONVERT ARG TO SMALL INTEGER
	.ADDRESS EVLI2		;JUMP IF NOT INTEGER
	.ADDRESS EVLI3		;JUMP IF OUT OF RANGE
	MOVL	R9,EVLIV	;STORE RESULT IN SPECIAL DUMMY NODE
	MOVL	R10,EVLIS	;STORE SUCCESSOR POINTER
	MOVL	#EVLIN,R9	;POINT TO DUMMY NODE WITH RESULT
	ADDL3	#4*3,(SP)+,R11	;TAKE SUCCESSFUL EXIT
	JMP	@(R11)+
;
;      HERE IF EVALUATION FAILS
;
EVLI1::	ADDL3	#4*2,(SP)+,R11	;TAKE FAILURE RETURN
	JMP	@(R11)+
;
;      HERE IF ARGUMENT IS NOT INTEGER
;
EVLI2::	MOVL	(SP)+,R11	;TAKE NON-INTEGER ERROR EXIT
	JMP	@(R11)+
;
;      HERE IF ARGUMENT IS OUT OF RANGE
;
EVLI3::	ADDL3	#4*1,(SP)+,R11	;TAKE OUT-OF-RANGE ERROR EXIT
	JMP	@(R11)+
	;ENP			;END PROCEDURE EVALI
	.PAGE
;
;      EVALP -- EVALUATE EXPRESSION DURING PATTERN MATCH
;
;      EVALP IS USED TO EVALUATE AN EXPRESSION (BY VALUE) DURING
;      A PATTERN MATCH. THE EFFECT IS LIKE EVALX, BUT PATTERN
;      VARIABLES ARE STACKED AND RESTORED IF NECESSARY.
;
;      EVALP ALSO DIFFERS FROM EVALX IN THAT IF THE RESULT IS
;      AN EXPRESSION IT IS REEVALUATED. THIS OCCURS REPEATEDLY.
;
;      (XR)                  NODE POINTER
;      (WB)                  PATTERN MATCH CURSOR
;      JSR  EVALP            CALL TO EVALUATE EXPRESSION
;      PPM  LOC              TRANSFER LOC IF EVALUATION FAILS
;      (XL)                  RESULT
;      (WA)                  FIRST WORD OF RESULT BLOCK
;      (XR,WB)               DESTROYED (FAILURE CASE ONLY)
;      (WC,RA)               DESTROYED
;
;      THE EXPRESSION POINTER IS STORED IN PARM1 OF THE NODE
;
;      CONTROL RETURNS TO FAILP ON FAILURE OF EVALUATION
;
	.ENABLE	LOCAL_BLOCK
EVALP::	;PRC			;ENTRY POINT (RECURSIVE)
	MOVL	4*PARM1(R9),R10	;LOAD EXPRESSION POINTER
	CMPL	(R10),#B$EXL	;JUMP IF EXBLK CASE
	BEQLU	EVLP1
;
;      HERE FOR CASE OF SEBLK
;
;      WE CAN GIVE A FAST RETURN IF THE VALUE OF THE VRBLK IS
;      NOT AN EXPRESSION AND IS NOT TRAPPED.
;
	MOVL	4*SEVAR(R10),R10;LOAD VRBLK POINTER
	MOVL	4*VRVAL(R10),R10;LOAD VALUE OF VRBLK
	MOVL	(R10),R6	;LOAD FIRST WORD OF VALUE
	CMPL	R6,#B$T$$	;JUMP IF NOT SEBLK, TRBLK OR EXBLK
	BGEQU	EVLP3
;
;      HERE FOR EXBLK OR SEBLK WITH EXPR VALUE OR TRAPPED VALUE
;
EVLP1::	MOVL	R9,-(SP)	;STACK NODE POINTER
	MOVL	R7,-(SP)	;STACK CURSOR
	MOVL	R$PMS,-(SP)	;STACK SUBJECT STRING POINTER
	MOVL	PMSSL,-(SP)	;STACK SUBJECT STRING LENGTH
	MOVL	PMDFL,-(SP)	;STACK DOT FLAG
	MOVL	PMHBS,-(SP)	;STACK HISTORY STACK BASE POINTER
	MOVL	4*PARM1(R9),R9	;LOAD EXPRESSION POINTER
	.PAGE
;
;      EVALP (CONTINUED)
;
;      LOOP BACK HERE TO REEVALUATE EXPRESSION RESULT
;
EVLP2::	CLRL	R7		;SET FLAG FOR BY VALUE
	JSB	EVALX		;EVALUATE EXPRESSION
	.ADDRESS EVLP4		;JUMP ON FAILURE
	MOVL	(R9),R6		;ELSE LOAD FIRST WORD OF VALUE
	CMPL	R6,#B$E$$	;LOOP BACK TO REEVALUATE EXPRESSION
	BLEQU	EVLP2
;
;      HERE TO RESTORE PATTERN VALUES AFTER SUCCESSFUL EVAL
;
	MOVL	R9,R10		;COPY RESULT POINTER
	MOVL	(SP)+,PMHBS	;RESTORE HISTORY STACK BASE POINTER
	MOVL	(SP)+,PMDFL	;RESTORE DOT FLAG
	MOVL	(SP)+,PMSSL	;RESTORE SUBJECT STRING LENGTH
	MOVL	(SP)+,R$PMS	;RESTORE SUBJECT STRING POINTER
	MOVL	(SP)+,R7	;RESTORE CURSOR
	MOVL	(SP)+,R9	;RESTORE NODE POINTER
;
;      COMMON EXIT POINT
;
EVLP3::	ADDL2	#4*1,(SP)	;RETURN TO EVALP CALLER
	RSB
;
;      HERE FOR FAILURE DURING EVALUATION
;
EVLP4::	MOVL	(SP)+,PMHBS	;RESTORE HISTORY STACK BASE POINTER
	MOVL	(SP)+,PMDFL	;RESTORE DOT FLAG
	MOVL	(SP)+,PMSSL	;RESTORE SUBJECT STRING LENGTH
	MOVL	(SP)+,R$PMS	;RESTORE SUBJECT STRING POINTER
	ADDL2	#4*NUM02,SP	;REMOVE NODE PTR, CURSOR
	MOVL	(SP)+,R11	;TAKE FAILURE EXIT
	JMP	@(R11)+
	;ENP			;END PROCEDURE EVALP
	.PAGE
;
;      EVALS -- EVALUATE STRING ARGUMENT
;
;      EVALS IS USED BY SPAN, ANY, NOTANY, BREAK, BREAKX WHEN
;      THEY ARE PASSED AN EXPRESSION ARGUMENT.
;
;      (XR)                  NODE POINTER
;      (WB)                  CURSOR
;      JSR  EVALS            CALL TO EVALUATE STRING
;      PPM  LOC              TRANSFER LOC FOR NON-STRING ARG
;      PPM  LOC              TRANSFER LOC FOR EVALUATION FAILURE
;      PPM  LOC              TRANSFER LOC FOR SUCCESSFUL EVAL
;      (THE NORMAL RETURN IS NEVER TAKEN)
;      (XR)                  PTR TO NODE WITH PARMS SET
;      (XL,WC,RA)            DESTROYED
;
;      ON RETURN, THE NODE POINTED TO HAS A CHARACTER TABLE
;      POINTER IN PARM1 AND A BIT MASK IN PARM2. THE PROPER
;      SUCCESSOR IS STORED IN PTHEN OF THIS NODE. THUS IT IS
;      OK FOR MERGING WITH THE NORMAL (MULTI-CHAR STRING) CASE.
;
	.ENABLE	LOCAL_BLOCK
EVALS::	;PRC			;ENTRY POINT (RECURSIVE)
	JSB	EVALP		;EVALUATE EXPRESSION
	.ADDRESS EVLS1		;JUMP IF EVALUATION FAILS
	MOVL	4*PTHEN(R9),-(SP);SAVE SUCCESSOR POINTER
	MOVL	R7,-(SP)	;SAVE CURSOR
	MOVL	R10,-(SP)	;STACK RESULT PTR FOR PATST
	CLRL	R7		;DUMMY PCODE FOR ONE CHAR STRING
	CLRL	R8		;DUMMY PCODE FOR EXPRESSION ARG
	MOVL	#P$BRK,R10	;APPROPRIATE PCODE FOR OUR USE
	JSB	PATST		;CALL ROUTINE TO BUILD NODE
	.ADDRESS EVLS2		;JUMP IF NOT STRING
	MOVL	(SP)+,R7	;RESTORE CURSOR
	MOVL	(SP)+,4*PTHEN(R9);STORE SUCCESSOR POINTER
	ADDL3	#4*2,(SP)+,R11	;TAKE SUCCESS RETURN
	JMP	@(R11)+
;
;      HERE IF EVALUATION FAILS
;
EVLS1::	ADDL3	#4*1,(SP)+,R11	;TAKE FAILURE RETURN
	JMP	@(R11)+
;
;      HERE IF ARGUMENT IS NOT STRING
;
EVLS2::	ADDL2	#4*NUM02,SP	;POP SUCCESSOR AND CURSOR
	MOVL	(SP)+,R11	;TAKE NON-STRING ERROR EXIT
	JMP	@(R11)+
	;ENP			;END PROCEDURE EVALS
	.PAGE
;
;      EVALX -- EVALUATE EXPRESSION
;
;      EVALX IS CALLED TO EVALUATE AN EXPRESSION
;
;      (XR)                  POINTER TO EXBLK OR SEBLK
;      (WB)                  0 IF BY VALUE, 1 IF BY NAME
;      JSR  EVALX            CALL TO EVALUATE EXPRESSION
;      PPM  LOC              TRANSFER LOC IF EVALUATION FAILS
;      (XR)                  RESULT IF CALLED BY VALUE
;      (XL,WA)               RESULT NAME BASE,OFFSET IF BY NAME
;      (XR)                  DESTROYED (NAME CASE ONLY)
;      (XL,WA)               DESTROYED (VALUE CASE ONLY)
;      (WB,WC,RA)            DESTROYED
;
	.ENABLE	LOCAL_BLOCK
EVALX::	;PRC			;ENTRY POINT, RECURSIVE
	CMPL	(R9),#B$EXL	;JUMP IF EXBLK CASE
	BEQLU	EVLX2
;
;      HERE FOR SEBLK
;
	MOVL	4*SEVAR(R9),R10	;LOAD VRBLK POINTER (NAME BASE)
	MOVL	#4*VRVAL,R6	;SET NAME OFFSET
	TSTL	R7		;JUMP IF CALLED BY NAME
	BEQLU	5170$
	JMP	EVLX1
5170$:
	JSB	ACESS		;CALL ROUTINE TO ACCESS VALUE
	.ADDRESS EVLX9		;JUMP IF FAILURE ON ACCESS
;
;      MERGE HERE TO EXIT FOR SEBLK CASE
;
EVLX1::	ADDL2	#4*1,(SP)	;RETURN TO EVALX CALLER
	RSB
	.PAGE
;
;      EVALX (CONTINUED)
;
;      HERE FOR FULL EXPRESSION (EXBLK) CASE
;
;      IF AN ERROR OCCURS IN THE EXPRESSION CODE AT EXECUTION
;      TIME, CONTROL IS PASSED VIA ERROR SECTION TO EXFAL
;      WITHOUT RETURNING TO THIS ROUTINE.
;      THE FOLLOWING ENTRIES ARE MADE ON THE STACK BEFORE
;      GIVING CONTROL TO THE EXPRESSION CODE
;
;                            EVALX RETURN POINT
;                            SAVED VALUE OF R$COD
;                            CODE POINTER (-R$COD)
;                            SAVED VALUE OF FLPTR
;                            0 IF BY VALUE, 1 IF BY NAME
;      FLPTR --------------- *EXFLC, FAIL OFFSET IN EXBLK
;
EVLX2::	MOVL	R3,R8		;GET CODE POINTER
	MOVL	R$COD,R6	;LOAD CODE BLOCK POINTER
	SUBL2	R6,R8		;GET CODE POINTER AS OFFSET
	MOVL	R6,-(SP)	;STACK OLD CODE BLOCK POINTER
	MOVL	R8,-(SP)	;STACK RELATIVE CODE OFFSET
	MOVL	FLPTR,-(SP)	;STACK OLD FAILURE POINTER
	MOVL	R7,-(SP)	;STACK NAME/VALUE INDICATOR
	MOVL	#4*EXFLC,-(SP)	;STACK NEW FAIL OFFSET
	MOVL	FLPTR,GTCEF	;KEEP IN CASE OF ERROR
	MOVL	R$COD,R$GTC	;KEEP CODE BLOCK POINTER SIMILARLY
	MOVL	SP,FLPTR	;SET NEW FAILURE POINTER
	MOVL	R9,R$COD	;SET NEW CODE BLOCK POINTER
	MOVL	KVSTN,4*EXSTM(R9);REMEMBER STMNT NUMBER
	ADDL2	#4*EXCOD,R9	;POINT TO FIRST CODE WORD
	MOVL	R9,R3		;SET CODE POINTER
	CMPL	STAGE,#STGXT	;JUMP IF NOT EXECUTION TIME
	BEQLU	5171$
	JMP	EXITS
5171$:
	MOVL	#STGEE,STAGE	;EVALUATING EXPRESSION
	JMP	EXITS		;JUMP TO EXECUTE FIRST CODE WORD
	.PAGE
;
;      EVALX (CONTINUED)
;
;      COME HERE IF SUCCESSFUL RETURN BY VALUE (SEE O$RVL)
;
EVLX3::	MOVL	(SP)+,R9	;LOAD VALUE
	TSTL	4*1(SP)	;JUMP IF CALLED BY VALUE
	BEQLU	EVLX5
	JMP	ERROR_249	;EXPRESSION EVALUATED BY NAME RETURNED VALUE
;
;      HERE FOR EXPRESSION RETURNING BY NAME (SEE O$RNM)
;
EVLX4::	MOVL	(SP)+,R6	;LOAD NAME OFFSET
	MOVL	(SP)+,R10	;LOAD NAME BASE
	TSTL	4*1(SP)	;JUMP IF CALLED BY NAME
	BNEQU	EVLX5
	JSB	ACESS		;ELSE ACCESS VALUE FIRST
	.ADDRESS EVLX6		;JUMP IF FAILURE DURING ACCESS
;
;      HERE AFTER LOADING CORRECT RESULT INTO XR OR XL,WA
;
EVLX5::	CLRL	R7		;NOTE SUCCESSFUL
	JMP	EVLX7		;MERGE
;
;      HERE FOR FAILURE IN EXPRESSION EVALUATION (SEE O$FEX)
;
EVLX6::	MOVL	SP,R7		;NOTE UNSUCCESSFUL
;
;      RESTORE ENVIRONMENT
;
EVLX7::	CMPL	STAGE,#STGEE	;SKIP IF WAS NOT PREVIOUSLY XT
	BNEQU	EVLX8
	MOVL	#STGXT,STAGE	;EXECUTE TIME
;
;      MERGE WITH STAGE SET UP
;
EVLX8::	ADDL2	#4*NUM02,SP	;POP NAME/VALUE INDICATOR, *EXFAL
	MOVL	(SP)+,FLPTR	;RESTORE OLD FAILURE POINTER
	MOVL	(SP)+,R8	;LOAD CODE OFFSET
	ADDL2	(SP),R8		;MAKE CODE POINTER ABSOLUTE
	MOVL	(SP)+,R$COD	;RESTORE OLD CODE BLOCK POINTER
	MOVL	R8,R3		;RESTORE OLD CODE POINTER
	TSTL	R7		;JUMP FOR SUCCESSFUL RETURN
	BNEQU	5172$
	JMP	EVLX1
5172$:
;
;      MERGE HERE FOR FAILURE IN SEBLK CASE
;
EVLX9::	MOVL	(SP)+,R11	;TAKE FAILURE EXIT
	JMP	@(R11)+
	;ENP			;END OF PROCEDURE EVALX
	.PAGE
;
;      EXBLD -- BUILD EXBLK
;
;      EXBLD IS USED TO BUILD AN EXPRESSION BLOCK FROM THE
;      CODE COMPILED MOST RECENTLY IN THE CURRENT CCBLK.
;
;      (XL)                  OFFSET IN CCBLK TO START OF CODE
;      (WB)                  INTEGER IN RANGE 0 LE N LE MXLEN
;      JSR  EXBLD            CALL TO BUILD EXBLK
;      (XR)                  PTR TO CONSTRUCTED EXBLK
;      (WA,WB,XL)            DESTROYED
;
	.ENABLE	LOCAL_BLOCK
EXBLD::	;PRC			;ENTRY POINT
	MOVL	R10,R6		;COPY OFFSET TO START OF CODE
	SUBL2	#4*EXCOD,R6	;CALC REDUCTION IN OFFSET IN EXBLK
	MOVL	R6,-(SP)	;STACK FOR LATER
	MOVL	CWCOF,R6	;LOAD FINAL OFFSET
	SUBL2	R10,R6		;COMPUTE LENGTH OF CODE
	ADDL2	#4*EXSI$,R6	;ADD SPACE FOR STANDARD FIELDS
	JSB	ALLOC		;ALLOCATE SPACE FOR EXBLK
	MOVL	R9,-(SP)	;SAVE POINTER TO EXBLK
	MOVL	#B$EXL,4*EXTYP(R9) ;STORE TYPE WORD
	CLRL	4*EXSTM(R9)	;ZEROISE STMNT NUMBER FIELD
	MOVL	R6,4*EXLEN(R9)	;STORE LENGTH
	MOVL	#OFEX$,4*EXFLC(R9) ;STORE FAILURE WORD
	ADDL2	#4*EXSI$,R9	;SET XR FOR SYSMW
	MOVL	R10,CWCOF	;RESET OFFSET TO START OF CODE
	ADDL2	R$CCB,R10	;POINT TO START OF CODE
	SUBL2	#4*EXSI$,R6	;LENGTH OF CODE TO MOVE
	MOVL	R6,-(SP)	;STACK LENGTH OF CODE
	MVW			;MOVE CODE TO EXBLK
	MOVL	(SP)+,R6	;GET LENGTH OF CODE
	ASHL	#-2,R6,R6	;CONVERT BYTE COUNT TO WORD COUNT
				;PREPARE COUNTER FOR LOOP
	MOVL	(SP),R10	;COPY EXBLK PTR, DONT UNSTACK
	ADDL2	#4*EXCOD,R10	;POINT TO CODE ITSELF
	MOVL	4*1(SP),R7	;GET REDUCTION IN OFFSET
;
;      THIS LOOP SEARCHES FOR NEGATION AND SELECTION CODE SO
;      THAT THE OFFSETS COMPUTED WHILST CODE WAS IN CODE BLOCK
;      CAN BE TRANSFORMED TO REDUCED VALUES APPLICABLE IN AN
;      EXBLK.
;
EXBL1::	MOVL	(R10)+,R9	;GET NEXT CODE WORD
	CMPL	R9,#OSLA$	;JUMP IF SELECTION FOUND
	BEQLU	EXBL3
	CMPL	R9,#ONTA$	;JUMP IF NEGATION FOUND
	BEQLU	EXBL3
	SOBGTR	R6,EXBL1	;LOOP TO END OF CODE
;
;      NO SELECTION FOUND OR MERGE TO EXIT ON TERMINATION
;
EXBL2::	MOVL	(SP)+,R9	;POP EXBLK PTR INTO XR
	MOVL	(SP)+,R10	;POP REDUCTION CONSTANT
	RSB			;RETURN TO CALLER
	.PAGE
;
;      EXBLD (CONTINUED)
;
;      SELECTION OR NEGATION FOUND
;      REDUCE THE OFFSETS AS NEEDED. OFFSETS OCCUR IN WORDS
;      FOLLOWING CODE WORDS -
;           =ONTA$, =OSLA$, =OSLB$, =OSLC$
;
EXBL3::	SUBL2	R7,(R10)+	;ADJUST OFFSET
	SOBGTR	R6,EXBL4	;DECREMENT COUNT
;
EXBL4::	SOBGTR	R6,EXBL5	;DECREMENT COUNT
;
;      CONTINUE SEARCH FOR MORE OFFSETS
;
EXBL5::	MOVL	(R10)+,R9	;GET NEXT CODE WORD
	CMPL	R9,#OSLA$	;JUMP IF OFFSET FOUND
	BEQLU	EXBL3
	CMPL	R9,#OSLB$	;JUMP IF OFFSET FOUND
	BEQLU	EXBL3
	CMPL	R9,#OSLC$	;JUMP IF OFFSET FOUND
	BEQLU	EXBL3
	CMPL	R9,#ONTA$	;JUMP IF OFFSET FOUND
	BEQLU	EXBL3
	SOBGTR	R6,EXBL5	;LOOP
	JMP	EXBL2		;MERGE TO RETURN
	;ENP			;END PROCEDURE EXBLD
	.PAGE
;
;      EXPAN -- ANALYZE EXPRESSION
;
;      THE EXPRESSION ANALYZER (EXPAN) PROCEDURE IS USED TO SCAN
;      AN EXPRESSION AND CONVERT IT INTO A TREE REPRESENTATION.
;      SEE DESCRIPTIONS OF CMBLK, CUBLK, CBBLK IN THE STRUCTURES
;      SECTION FOR DETAILED FORMAT OF TREE BLOCKS.
;
;      THE ANALYZER USES A SIMPLE PRECEDENCE SCHEME IN WHICH
;      OPERANDS AND OPERATORS ARE PLACED ON A SINGLE STACK
;      AND CONDENSATIONS ARE MADE WHEN LOW PRECEDENCE OPERATORS
;      ARE STACKED AFTER A HIGHER PRECEDENCE OPERATOR. A GLOBAL
;      VARIABLE (IN WB) KEEPS TRACK OF THE LEVEL AS FOLLOWS.
;
;      0    SCANNING OUTER LEVEL OF STATEMENT OR EXPRESSION
;      1    SCANNING OUTER LEVEL OF NORMAL GOTO
;      2    SCANNING OUTER LEVEL OF DIRECT GOTO
;      3    SCANNING INSIDE ARRAY BRACKETS
;      4    SCANNING INSIDE GROUPING PARENTHESES
;      5    SCANNING INSIDE FUNCTION PARENTHESES
;
;      THIS VARIABLE IS SAVED ON THE STACK ON ENCOUNTERING A
;      GROUPING AND RESTORED AT THE END OF THE GROUPING.
;
;      ANOTHER GLOBAL VARIABLE (IN WC) COUNTS THE NUMBER OF
;      ITEMS AT ONE GROUPING LEVEL AND IS INCREMENTED FOR EACH
;      COMMA ENCOUNTERED. IT IS STACKED WITH THE LEVEL INDICATOR
;
;      THE SCAN IS CONTROLLED BY A THREE STATE FINITE MACHINE.
;      A GLOBAL VARIABLE STORED IN WA IS THE CURRENT STATE.
;
;      WA=0                  NOTHING SCANNED AT THIS LEVEL
;      WA=1                  OPERAND EXPECTED
;      WA=2                  OPERATOR EXPECTED
;
;      (WB)                  CALL TYPE (SEE BELOW)
;      JSR  EXPAN            CALL TO ANALYZE EXPRESSION
;      (XR)                  POINTER TO RESULTING TREE
;      (XL,WA,WB,WC,RA)      DESTROYED
;
;      THE ENTRY VALUE OF WB INDICATES THE CALL TYPE AS FOLLOWS.
;
;      0    SCANNING EITHER THE MAIN BODY OF A STATEMENT OR THE
;           TEXT OF AN EXPRESSION (FROM EVAL CALL). VALID
;           TERMINATORS ARE COLON, SEMICOLON. THE RESCAN FLAG IS
;           SET TO RETURN THE TERMINATOR ON THE NEXT SCANE CALL.
;
;      1    SCANNING A NORMAL GOTO. THE ONLY VALID
;           TERMINATOR IS A RIGHT PAREN.
;
;      2    SCANNING A DIRECT GOTO. THE ONLY VALID
;           TERMINATOR IS A RIGHT BRACKET.
	.PAGE
;
;      EXPAN (CONTINUED)
;
;      ENTRY POINT
;
	.ENABLE	LOCAL_BLOCK
EXPAN::	;PRC			;ENTRY POINT
	CLRL	-(SP)		;SET TOP OF STACK INDICATOR
	CLRL	R6		;SET INITIAL STATE TO ZERO
	CLRL	R8		;ZERO COUNTER VALUE
;
;      LOOP HERE FOR SUCCESSIVE ENTRIES
;
EXP01::	JSB	SCANE		;SCAN NEXT ELEMENT
	ADDL2	R6,R10		;ADD STATE TO SYNTAX CODE
	BSW	R10,T$NES	;SWITCH ON ELEMENT TYPE/STATE
	IFF	T$VA0,EXP03	;VARIABLE, S=0
	IFF	T$VA1,EXP03	;VARIABLE, STATE ONE
	IFF	T$VA2,EXP04	;VARIABLE, S=2
	IFF	T$CO0,EXP03	;CONSTANT, S=0
	IFF	T$CO1,EXP03	;CONSTANT, S=1
	IFF	T$CO2,EXP04	;CONSTANT, S=2
	IFF	T$LP0,EXP06	;LEFT PAREN, S=0
	IFF	T$LP1,EXP06	;LEFT PAREN, S=1
	IFF	T$LP2,EXP04	;LEFT PAREN, S=2
	IFF	T$FN0,EXP10	;FUNCTION, S=0
	IFF	T$FN1,EXP10	;FUNCTION, S=1
	IFF	T$FN2,EXP04	;FUNCTION, S=2
	IFF	T$RP0,EXP02	;RIGHT PAREN, S=0
	IFF	T$RP1,EXP05	;RIGHT PAREN, S=1
	IFF	T$RP2,EXP12	;RIGHT PAREN, S=2
	IFF	T$LB0,EXP08	;LEFT BRKT, S=0
	IFF	T$LB1,EXP08	;LEFT BRKT, S=1
	IFF	T$LB2,EXP09	;LEFT BRKT, S=2
	IFF	T$RB0,EXP02	;RIGHT BRKT, S=0
	IFF	T$RB1,EXP05	;RIGHT BRKT, S=1
	IFF	T$RB2,EXP18	;RIGHT BRKT, S=2
	IFF	T$UO0,EXP27	;UNOP, S=0
	IFF	T$UO1,EXP27	;UNOP, S=1
	IFF	T$UO2,EXP04	;UNOP, S=2
	IFF	T$BO0,EXP05	;BINOP, S=0
	IFF	T$BO1,EXP05	;BINOP, S=1
	IFF	T$BO2,EXP26	;BINOP, S=2
	IFF	T$CM0,EXP02	;COMMA, S=0
	IFF	T$CM1,EXP05	;COMMA, S=1
	IFF	T$CM2,EXP11	;COMMA, S=2
	IFF	T$CL0,EXP02	;COLON, S=0
	IFF	T$CL1,EXP05	;COLON, S=1
	IFF	T$CL2,EXP19	;COLON, S=2
	IFF	T$SM0,EXP02	;SEMICOLON, S=0
	IFF	T$SM1,EXP05	;SEMICOLON, S=1
	IFF	T$SM2,EXP19	;SEMICOLON, S=2
	ESW			;END SWITCH ON ELEMENT TYPE/STATE
	.PAGE
;
;      EXPAN (CONTINUED)
;
;      HERE FOR RBR,RPR,COL,SMC,CMA IN STATE 0
;
;      SET TO RESCAN THE TERMINATOR ENCOUNTERED AND CREATE
;      A NULL CONSTANT (CASE OF OMITTED NULL)
;
EXP02::	MOVL	SP,SCNRS	;SET TO RESCAN ELEMENT
	MOVL	#NULLS,R9	;POINT TO NULL, MERGE
;
;      HERE FOR VAR OR CON IN STATES 0,1
;
;      STACK THE VARIABLE/CONSTANT AND SET STATE=2
;
EXP03::	MOVL	R9,-(SP)	;STACK POINTER TO OPERAND
	MOVL	#NUM02,R6	;SET STATE 2
	JMP	EXP01		;JUMP FOR NEXT ELEMENT
;
;      HERE FOR VAR,CON,LPR,FNC,UOP IN STATE 2
;
;      WE RESCAN THE ELEMENT AND CREATE A CONCATENATION OPERATOR
;      THIS IS THE CASE OF THE BLANK CONCATENATION OPERATOR.
;
EXP04::	MOVL	SP,SCNRS	;SET TO RESCAN ELEMENT
	MOVL	#OPDVC,R9	;POINT TO CONCAT OPERATOR DV
	TSTL	R7		;OK IF AT TOP LEVEL
	BEQLU	EXP4A
	MOVL	#OPDVP,R9	;ELSE POINT TO UNMISTAKABLE CONCAT.
;
;      MERGE HERE WHEN XR SET UP WITH PROPER CONCATENATION DVBLK
;
EXP4A::	TSTL	SCNBL		;MERGE BOP IF BLANKS, ELSE ERROR
	BEQLU	5173$
	JMP	EXP26
5173$:
	DECL	SCNSE		;ADJUST START OF ELEMENT LOCATION
	JMP	ERROR_220	;SYNTAX ERROR. MISSING OPERATOR
;
;      HERE FOR CMA,RPR,RBR,COL,SMC,BOP(S=1) BOP(S=0)
;
;      THIS IS AN ERRONOUS CONTRUCTION
;
EXP05::	DECL	SCNSE		;ADJUST START OF ELEMENT LOCATION
	JMP	ERROR_221	;SYNTAX ERROR. MISSING OPERAND
;
;      HERE FOR LPR (S=0,1)
;
EXP06::	MOVL	#NUM04,R10	;SET NEW LEVEL INDICATOR
	CLRL	R9		;SET ZERO VALUE FOR CMOPN
	.PAGE
;
;      EXPAN (CONTINUED)
;
;      MERGE HERE TO STORE OLD LEVEL ON STACK AND START NEW ONE
;
EXP07::	MOVL	R9,-(SP)	;STACK CMOPN VALUE
	MOVL	R8,-(SP)	;STACK OLD COUNTER
	MOVL	R7,-(SP)	;STACK OLD LEVEL INDICATOR
	;CHK			;CHECK FOR STACK OVERFLOW
	CLRL	R6		;SET NEW STATE TO ZERO
	MOVL	R10,R7		;SET NEW LEVEL INDICATOR
	MOVL	#NUM01,R8	;INITIALIZE NEW COUNTER
	JMP	EXP01		;JUMP TO SCAN NEXT ELEMENT
;
;      HERE FOR LBR (S=0,1)
;
;      THIS IS AN ILLEGAL USE OF LEFT BRACKET
;
EXP08::	JMP	ERROR_222	;SYNTAX ERROR. INVALID USE OF LEFT BRACKET
;
;      HERE FOR LBR (S=2)
;
;      SET NEW LEVEL AND START TO SCAN SUBSCRIPTS
;
EXP09::	MOVL	(SP)+,R9	;LOAD ARRAY PTR FOR CMOPN
	MOVL	#NUM03,R10	;SET NEW LEVEL INDICATOR
	JMP	EXP07		;JUMP TO STACK OLD AND START NEW
;
;      HERE FOR FNC (S=0,1)
;
;      STACK OLD LEVEL AND START TO SCAN ARGUMENTS
;
EXP10::	MOVL	#NUM05,R10	;SET NEW LEV INDIC (XR=VRBLK=CMOPN)
	JMP	EXP07		;JUMP TO STACK OLD AND START NEW
;
;      HERE FOR CMA (S=2)
;
;      INCREMENT ARGUMENT COUNT AND CONTINUE
;
EXP11::	INCL	R8		;INCREMENT COUNTER
	JSB	EXPDM		;DUMP OPERATORS AT THIS LEVEL
	CLRL	-(SP)		;SET NEW LEVEL FOR PARAMETER
	CLRL	R6		;SET NEW STATE
	CMPL	R7,#NUM02	;LOOP BACK UNLESS OUTER LEVEL
	BLEQU	5174$
	JMP	EXP01
5174$:
	JMP	ERROR_223	;SYNTAX ERROR. INVALID USE OF COMMA
	.PAGE
;
;      EXPAN (CONTINUED)
;
;      HERE FOR RPR (S=2)
;
;      AT OUTER LEVEL IN A NORMAL GOTO THIS IS A TERMINATOR
;      OTHERWISE IT MUST TERMINATE A FUNCTION OR GROUPING
;
EXP12::	CMPL	R7,#NUM01	;END OF NORMAL GOTO
	BNEQU	5175$
	JMP	EXP20
5175$:
	CMPL	R7,#NUM05	;END OF FUNCTION ARGUMENTS
	BEQLU	EXP13
	CMPL	R7,#NUM04	;END OF GROUPING / SELECTION
	BEQLU	EXP14
	JMP	ERROR_224	;SYNTAX ERROR. UNBALANCED RIGHT PARENTHESIS
;
;      HERE AT END OF FUNCTION ARGUMENTS
;
EXP13::	MOVL	#C$FNC,R10	;SET CMTYP VALUE FOR FUNCTION
	JMP	EXP15		;JUMP TO BUILD CMBLK
;
;      HERE FOR END OF GROUPING
;
EXP14::	CMPL	R8,#NUM01	;JUMP IF END OF GROUPING
	BEQLU	EXP17
	MOVL	#C$SEL,R10	;ELSE SET CMTYP FOR SELECTION
;
;      MERGE HERE TO BUILD CMBLK FOR LEVEL JUST SCANNED AND
;      TO POP UP TO THE PREVIOUS SCAN LEVEL BEFORE CONTINUING.
;
EXP15::	JSB	EXPDM		;DUMP OPERATORS AT THIS LEVEL
	MOVL	R8,R6		;COPY COUNT
	ADDL2	#CMVLS,R6	;ADD FOR STANDARD FIELDS AT START
	MOVAL	0[R6],R6	;CONVERT LENGTH TO BYTES
	JSB	ALLOC		;ALLOCATE SPACE FOR CMBLK
	MOVL	#B$CMT,(R9)	;STORE TYPE CODE FOR CMBLK
	MOVL	R10,4*CMTYP(R9)	;STORE CMBLK NODE TYPE INDICATOR
	MOVL	R6,4*CMLEN(R9)	;STORE LENGTH
	ADDL2	R6,R9		;POINT PAST END OF BLOCK
				;SET LOOP COUNTER
;
;      LOOP TO MOVE REMAINING WORDS TO CMBLK
;
EXP16::	MOVL	(SP)+,-(R9)	;MOVE ONE OPERAND PTR FROM STACK
	MOVL	(SP)+,R7	;POP TO OLD LEVEL INDICATOR
	SOBGTR	R8,EXP16	;LOOP TILL ALL MOVED
	.PAGE
;
;      EXPAN (CONTINUED)
;
;      COMPLETE CMBLK AND STACK POINTER TO IT ON STACK
;
	SUBL2	#4*CMVLS,R9	;POINT BACK TO START OF BLOCK
	MOVL	(SP)+,R8	;RESTORE OLD COUNTER
	MOVL	(SP),4*CMOPN(R9);STORE OPERAND PTR IN CMBLK
	MOVL	R9,(SP)		;STACK CMBLK POINTER
	MOVL	#NUM02,R6	;SET NEW STATE
	JMP	EXP01		;BACK FOR NEXT ELEMENT
;
;      HERE AT END OF A PARENTHESIZED EXPRESSION
;
EXP17::	JSB	EXPDM		;DUMP OPERATORS AT THIS LEVEL
	MOVL	(SP)+,R9	;RESTORE XR
	MOVL	(SP)+,R7	;RESTORE OUTER LEVEL
	MOVL	(SP)+,R8	;RESTORE OUTER COUNT
	MOVL	R9,(SP)		;STORE OPND OVER UNUSED CMOPN VAL
	MOVL	#NUM02,R6	;SET NEW STATE
	JMP	EXP01		;BACK FOR NEXT ELE8ENT
;
;      HERE FOR RBR (S=2)
;
;      AT OUTER LEVEL IN A DIRECT GOTO, THIS IS A TERMINATOR.
;      OTHERWISE IT MUST TERMINATE A SUBSCRIPT LIST.
;
EXP18::	MOVL	#C$ARR,R10	;SET CMTYP FOR ARRAY REFERENCE
	CMPL	R7,#NUM03	;JUMP TO BUILD CMBLK IF END ARRAYREF
	BEQLU	EXP15
	CMPL	R7,#NUM02	;JUMP IF END OF DIRECT GOTO
	BNEQU	5176$
	JMP	EXP20
5176$:
	JMP	ERROR_225	;SYNTAX ERROR. UNBALANCED RIGHT BRACKET
	.PAGE
;
;      EXPAN (CONTINUED)
;
;      HERE FOR COL,SMC (S=2)
;
;      ERROR UNLESS TERMINATING STATEMENT BODY AT OUTER LEVEL
;
EXP19::	MOVL	SP,SCNRS	;RESCAN TERMINATOR
	MOVL	R7,R10		;COPY LEVEL INDICATOR
	BSW	R10,6		;SWITCH ON LEVEL INDICATOR
	IFF	0,EXP20		;NORMAL OUTER LEVEL
	IFF	1,EXP22		;FAIL IF NORMAL GOTO
	IFF	2,EXP23		;FAIL IF DIRECT GOTO
	IFF	3,EXP24		;FAIL ARRAY BRACKETS
	IFF	4,EXP21		;FAIL IF IN GROUPING
	IFF	5,EXP21		;FAIL FUNCTION ARGS
	ESW			;END SWITCH ON LEVEL
;
;      HERE AT NORMAL END OF EXPRESSION
;
EXP20::	JSB	EXPDM		;DUMP REMAINING OPERATORS
	MOVL	(SP)+,R9	;LOAD TREE POINTER
	ADDL2	#4,SP		;POP OFF BOTTOM OF STACK MARKER
	RSB			;RETURN TO EXPAN CALLER
;
;      MISSING RIGHT PAREN
;
EXP21::	JMP	ERROR_226	;SYNTAX ERROR. MISSING RIGHT PAREN
;
;      MISSING RIGHT PAREN IN GOTO FIELD
;
EXP22::	JMP	ERROR_227	;SYNTAX ERROR. RIGHT PAREN MISSING FROM GOTO
;
;      MISSING BRACKET IN GOTO
;
EXP23::	JMP	ERROR_228	;SYNTAX ERROR. RIGHT BRACKET MISSING FROM GOTO
;
;      MISSING ARRAY BRACKET
;
EXP24::	JMP	ERROR_229	;SYNTAX ERROR. MISSING RIGHT ARRAY BRACKET
	.PAGE
;
;      EXPAN (CONTINUED)
;
;      LOOP HERE WHEN AN OPERATOR CAUSES AN OPERATOR DUMP
;
EXP25::	MOVL	R9,EXPSV
	JSB	EXPOP		;POP ONE OPERATOR
	MOVL	EXPSV,R9	;RESTORE OP DV POINTER AND MERGE
;
;      HERE FOR BOP (S=2)
;
;      REMOVE OPERATORS (CONDENSE) FROM STACK UNTIL NO MORE
;      LEFT AT THIS LEVEL OR TOP ONE HAS LOWER PRECEDENCE.
;      LOOP HERE TILL THIS CONDITION IS MET.
;
EXP26::	MOVL	4*1(SP),R10	;LOAD OPERATOR DVPTR FROM STACK
	CMPL	R10,#NUM05	;JUMP IF BOTTOM OF STACK LEVEL
	BLEQU	EXP27
	CMPL	4*DVRPR(R9),4*DVLPR(R10) ;ELSE POP IF NEW PREC IS LO
	BLSSU	EXP25
;
;      HERE FOR UOP (S=0,1)
;
;      BINARY OPERATOR MERGES AFTER PRECEDENCE CHECK
;
;      THE OPERATOR DV IS STORED ON THE STACK AND THE SCAN
;      CONTINUES AFTER SETTING THE SCAN STATE TO ONE.
;
EXP27::	MOVL	R9,-(SP)	;STACK OPERATOR DVPTR ON STACK
	;CHK			;CHECK FOR STACK OVERFLOW
	MOVL	#NUM01,R6	;SET NEW STATE
	CMPL	R9,#OPDVS	;BACK FOR NEXT ELEMENT UNLESS =
	BEQLU	5177$
	JMP	EXP01
5177$:
;
;      HERE FOR SPECIAL CASE OF BINARY =. THE SYNTAX ALLOWS A
;      NULL RIGHT ARGUMENT FOR THIS OPERATOR TO BE LEFT
;      OUT. ACCORDINGLY WE RESET TO STATE ZERO TO GET PROPER
;      ACTION ON A TERMINATOR (SUPPLY A NULL CONSTANT).
;
	CLRL	R6		;SET STATE ZERO
	JMP	EXP01		;JUMP FOR NEXT ELEMENT
	;ENP			;END PROCEDURE EXPAN
	.PAGE
;
;      EXPAP -- TEST FOR PATTERN MATCH TREE
;
;      EXPAP IS PASSED AN EXPRESSION TREE TO DETERMINE IF IT
;      IS A PATTERN MATCH. THE FOLLOWING ARE RECOGIZED AS
;      MATCHES IN THE CONTEXT OF THIS CALL.
;
;      1)   AN EXPLICIT USE OF BINARY QUESTION MARK
;      2)   A CONCATENATION
;      3)   AN ALTERNATION WHOSE LEFT OPERAND IS A CONCATENATION
;
;      (XR)                  PTR TO EXPAN TREE
;      JSR  EXPAP            CALL TO TEST FOR PATTERN MATCH
;      PPM  LOC              TRANSFER LOC IF NOT A PATTERN MATCH
;      (WA)                  DESTROYED
;      (XR)                  UNCHANGED (IF NOT MATCH)
;      (XR)                  PTR TO BINARY OPERATOR BLK IF MATCH
;
	.ENABLE	LOCAL_BLOCK
EXPAP::	;PRC			;ENTRY POINT
	MOVL	R10,-(SP)	;SAVE XL
	CMPL	(R9),#B$CMT	;NO MATCH IF NOT COMPLEX
	BNEQU	EXPP2
	MOVL	4*CMTYP(R9),R6	;ELSE LOAD TYPE CODE
	CMPL	R6,#C$CNC	;CONCATENATION IS A MATCH
	BEQLU	EXPP1
	CMPL	R6,#C$PMT	;BINARY QUESTION MARK IS A MATCH
	BEQLU	EXPP1
	CMPL	R6,#C$ALT	;ELSE NOT MATCH UNLESS ALTERNATION
	BNEQU	EXPP2
;
;      HERE FOR ALTERNATION. CHANGE (A B) / C TO A QM (B / C)
;
	MOVL	4*CMLOP(R9),R10	;LOAD LEFT OPERAND POINTER
	CMPL	(R10),#B$CMT	;NOT MATCH IF LEFT OPND NOT COMPLEX
	BNEQU	EXPP2
	CMPL	4*CMTYP(R10),#C$CNC ;NOT MATCH IF LEFT OP NOT CONC
	BNEQU	EXPP2
	MOVL	4*CMROP(R10),4*CMLOP(R9) ;XR POINTS TO (B / C)
	MOVL	R9,4*CMROP(R10)	;SET XL OPNDS TO A, (B / C)
	MOVL	R10,R9		;POINT TO THIS ALTERED NODE
;
;      EXIT HERE FOR PATTERN MATCH
;
EXPP1::	MOVL	(SP)+,R10	;RESTORE ENTRY XL
	ADDL2	#4*1,(SP)	;GIVE PATTERN MATCH RETURN
	RSB
;
;      EXIT HERE IF NOT PATTERN MATCH
;
EXPP2::	MOVL	(SP)+,R10	;RESTORE ENTRY XL
	MOVL	(SP)+,R11	;GIVE NON-MATCH RETURN
	JMP	@(R11)+
	;ENP			;END PROCEDURE EXPAP
	.PAGE
;
;      EXPDM -- DUMP OPERATORS AT CURRENT LEVEL (FOR EXPAN)
;
;      EXPDM USES EXPOP TO CONDENSE ALL OPERATORS AT THIS SYNTAX
;      LEVEL. THE STACK BOTTOM IS RECOGNIZED FROM THE LEVEL
;      VALUE WHICH IS SAVED ON THE TOP OF THE STACK.
;
;      JSR  EXPDM            CALL TO DUMP OPERATORS
;      (XS)                  POPPED AS REQUIRED
;      (XR,WA)               DESTROYED
;
	.ENABLE	LOCAL_BLOCK
EXPDM::	MOVL	(SP)+,EXPDM_SAVE;ENTRY POINT
	.SAVE_PSECT LOCAL_BLOCK
	.PSECT	PRC_SAVE,NOEXE
EXPDM_SAVE::.LONG	0
	.RESTORE_PSECT
	MOVL	R10,R$EXS	;SAVE XL VALUE
;
;      LOOP TO DUMP OPERATORS
;
EXDM1::	CMPL	4*1(SP),#NUM05	;JUMP IF STACK BOTTOM (SAVED LEVEL
	BLEQU	EXDM2
	JSB	EXPOP		;ELSE POP ONE OPERATOR
	JMP	EXDM1		;AND LOOP BACK
;
;      HERE AFTER POPPING ALL OPERATORS
;
EXDM2::	MOVL	R$EXS,R10	;RESTORE XL
	CLRL	R$EXS		;RELEASE SAVE LOCATION
	JMP	@EXPDM_SAVE	;RETURN TO EXPDM CALLER
	;ENP			;END PROCEDURE EXPDM
	.PAGE
;
;      EXPOP-- POP OPERATOR (FOR EXPAN)
;
;      EXPOP IS USED BY THE EXPAN ROUTINE TO CONDENSE ONE
;      OPERATOR FROM THE TOP OF THE SYNTAX STACK. AN APPROPRIATE
;      CMBLK IS BUILT FOR THE OPERATOR (UNARY OR BINARY) AND A
;      POINTER TO THIS CMBLK IS STACKED.
;
;      EXPOP IS ALSO USED BY SCNGF (GOTO FIELD SCAN) PROCEDURE
;
;      JSR  EXPOP            CALL TO POP OPERATOR
;      (XS)                  POPPED APPROPRIATELY
;      (XR,XL,WA)            DESTROYED
;
	.ENABLE	LOCAL_BLOCK
EXPOP::	MOVL	(SP)+,EXPOP_SAVE;ENTRY POINT
	.SAVE_PSECT LOCAL_BLOCK
	.PSECT	PRC_SAVE,NOEXE
EXPOP_SAVE::.LONG	0
	.RESTORE_PSECT
	MOVL	4*1(SP),R9	;LOAD OPERATOR DV POINTER
	CMPL	4*DVLPR(R9),#LLUNO ;JUMP IF UNARY
	BEQLU	EXPO2
;
;      HERE FOR BINARY OPERATOR
;
	MOVL	#4*CMBS$,R6	;SET SIZE OF BINARY OPERATOR CMBLK
	JSB	ALLOC		;ALLOCATE SPACE FOR CMBLK
	MOVL	(SP)+,4*CMROP(R9);POP AND STORE RIGHT OPERAND PTR
	MOVL	(SP)+,R10	;POP AND LOAD OPERATOR DV PTR
	MOVL	(SP),4*CMLOP(R9);STORE LEFT OPERAND POINTER
;
;      COMMON EXIT POINT
;
EXPO1::	MOVL	#B$CMT,(R9)	;STORE TYPE CODE FOR CMBLK
	MOVL	4*DVTYP(R10),4*CMTYP(R9) ;STORE CMBLK NODE TYPE CODE
	MOVL	R10,4*CMOPN(R9)	;STORE DVPTR (=PTR TO DAC O$XXX)
	MOVL	R6,4*CMLEN(R9)	;STORE CMBLK LENGTH
	MOVL	R9,(SP)		;STORE RESULTING NODE PTR ON STACK
	JMP	@EXPOP_SAVE	;RETURN TO EXPOP CALLER
;
;      HERE FOR UNARY OPERATOR
;
EXPO2::	MOVL	#4*CMUS$,R6	;SET SIZE OF UNARY OPERATOR CMBLK
	JSB	ALLOC		;ALLOCATE SPACE FOR CMBLK
	MOVL	(SP)+,4*CMROP(R9);POP AND STORE OPERAND POINTER
	MOVL	(SP),R10	;LOAD OPERATOR DV POINTER
	JMP	EXPO1		;MERGE BACK TO EXIT
	;ENP			;END PROCEDURE EXPOP
	.PAGE
;
;      GBCOL -- PERFORM GARBAGE COLLECTION
;
;      GBCOL PERFORMS A GARBAGE COLLECTION ON THE DYNAMIC REGION
;      ALL BLOCKS WHICH ARE NO LONGER IN USE ARE ELIMINATED
;      BY MOVING BLOCKS WHICH ARE IN USE DOWN AND RESETTING
;      DNAMP, THE POINTER TO THE NEXT AVAILABLE LOCATION.
;
;      (WB)                  MOVE OFFSET (SEE BELOW)
;      JSR  GBCOL            CALL TO COLLECT GARBAGE
;      (XR)                  DESTROYED
;
;      THE FOLLOWING CONDITIONS MUST BE MET AT THE TIME WHEN
;      GBCOL IS CALLED.
;
;      1)   ALL POINTERS TO BLOCKS IN THE DYNAMIC AREA MUST BE
;           ACCESSIBLE TO THE GARBAGE COLLECTOR. THIS MEANS
;           THAT THEY MUST OCCUR IN ONE OF THE FOLLOWING.
;
;           A)               MAIN STACK, WITH CURRENT TOP
;                            ELEMENT BEING INDICATED BY XS
;
;           B)               IN RELOCATABLE FIELDS OF VRBLKS.
;
;           C)               IN REGISTER XL AT THE TIME OF CALL
;
;           E)               IN THE SPECIAL REGION OF WORKING
;                            STORAGE WHERE NAMES BEGIN WITH R$.
;
;      2)   ALL POINTERS MUST POINT TO THE START OF BLOCKS WITH
;           THE SOLE EXCEPTION OF THE CONTENTS OF THE CODE
;           POINTER REGISTER WHICH POINTS INTO THE R$COD BLOCK.
;
;      3)   NO LOCATION WHICH APPEARS TO CONTAIN A POINTER
;           INTO THE DYNAMIC REGION MAY OCCUR UNLESS IT IS IN
;           FACT A POINTER TO THE START OF THE BLOCK. HOWEVER
;           POINTERS OUTSIDE THIS AREA MAY OCCUR AND WILL
;           NOT BE CHANGED BY THE GARBAGE COLLECTOR.
;           IT IS ESPECIALLY IMPORTANT TO MAKE SURE THAT XL
;           DOES NOT CONTAIN A GARBAGE VALUE FROM SOME PROCESS
;           CARRIED OUT BEFORE THE CALL TO THE COLLECTOR.
;
;      GBCOL HAS THE CAPABILITY OF MOVING THE FINAL COMPACTED
;      RESULT UP IN MEMORY (WITH ADDRESSES ADJUSTED ACCORDINGLY)
;      THIS IS USED TO ADD SPACE TO THE STATIC REGION. THE
;      ENTRY VALUE OF WB IS THE NUMBER OF BYTES TO MOVE UP.
;      THE CALLER MUST GUARANTEE THAT THERE IS ENOUGH ROOM.
;      FURTHERMORE THE VALUE IN WB IF IT IS NON-ZERO, MUST BE AT
;      LEAST 256 SO THAT THE MWB INSTRUCTION CONDITIONS ARE MET.
	.PAGE
;
;      GBCOL (CONTINUED)
;
;      THE ALGORITHM, WHICH IS A MODIFICATION OF THE LISP-2
;      GARBAGE COLLECTOR DEVISED BY R.DEWAR AND K.BELCHER
;      TAKES THREE PASSES AS FOLLOWS.
;
;      1)   ALL POINTERS IN MEMORY ARE SCANNED AND BLOCKS IN USE
;           DETERMINED FROM THIS SCAN. NOTE THAT THIS PROCEDURE
;           IS RECURSIVE AND USES THE MAIN STACK FOR LINKAGE.
;           THE MARKING PROCESS IS THUS SIMILAR TO THAT USED IN
;           A STANDARD LISP COLLECTOR. HOWEVER THE METHOD OF
;           ACTUALLY MARKING THE BLOCKS IS DIFFERENT.
;
;           THE FIRST FIELD OF A BLOCK NORMALLY CONTAINS A
;           CODE ENTRY POINT POINTER. SUCH AN ENTRY POINTER
;           CAN BE DISTINGUISHED FROM THE ADDRESS OF ANY POINTER
;           TO BE PROCESSED BY THE COLLECTOR. DURING GARBAGE
;           COLLECTION, THIS WORD IS USED TO BUILD A BACK CHAIN
;           OF POINTERS THROUGH FIELDS WHICH POINT TO THE BLOCK.
;           THE END OF THE CHAIN IS MARKED BY THE OCCURENCE
;           OF THE WORD WHICH USED TO BE IN THE FIRST WORD OF
;           THE BLOCK. THIS BACKCHAIN SERVES BOTH AS A MARK
;           INDICATING THAT THE BLOCK IS IN USE AND AS A LIST OF
;           REFERENCES FOR THE RELOCATION PHASE.
;
;      2)   STORAGE IS SCANNED SEQUENTIALLY TO DISCOVER WHICH
;           BLOCKS ARE CURRENTLY IN USE AS INDICATED BY THE
;           PRESENCE OF A BACKCHAIN. TWO POINTERS ARE MAINTAINED
;           ONE SCANS THROUGH LOOKING AT EACH BLOCK. THE OTHER
;           IS INCREMENTED ONLY FOR BLOCKS FOUND TO BE IN USE.
;           IN THIS WAY, THE EVENTUAL LOCATION OF EACH BLOCK CAN
;           BE DETERMINED WITHOUT ACTUALLY MOVING ANY BLOCKS.
;           AS EACH BLOCK WHICH IS IN USE IS PROCESSED, THE BACK
;           CHAIN IS USED TO RESET ALL POINTERS WHICH POINT TO
;           THIS BLOCK TO CONTAIN ITS NEW ADDRESS, I.E. THE
;           ADDRESS IT WILL OCCUPY AFTER THE BLOCKS ARE MOVED.
;           THE FIRST WORD OF THE BLOCK, TAKEN FROM THE END OF
;           THE CHAIN IS RESTORED AT THIS POINT.
;
;           DURING PASS 2, THE COLLECTOR BUILDS BLOCKS WHICH
;           DESCRIBE THE REGIONS OF STORAGE WHICH ARE TO BE
;           MOVED IN THE THIRD PASS. THERE IS ONE DESCRIPTOR FOR
;           EACH CONTIGUOUS SET OF GOOD BLOCKS. THE DESCRIPTOR
;           IS BUILT JUST BEHIND THE BLOCK TO BE MOVED AND
;           CONTAINS A POINTER TO THE NEXT BLOCK AND THE NUMBER
;           OF WORDS TO BE MOVED.
;
;      3)   IN THE THIRD AND FINAL PASS, THE MOVE DESCRIPTOR
;           BLOCKS BUILT IN PASS TWO ARE USED TO ACTUALLY MOVE
;           THE BLOCKS DOWN TO THE BOTTOM OF THE DYNAMIC REGION.
;           THE COLLECTION IS THEN COMPLETE AND THE NEXT
;           AVAILABLE LOCATION POINTER IS RESET.
	.PAGE
;
;      GBCOL (CONTINUED)
;
	.ENABLE	LOCAL_BLOCK
GBCOL::	;PRC			;ENTRY POINT
	TSTL	DMVCH		;FAIL IF IN MID-DUMP
	BEQLU	5178$
	JMP	GBC14
5178$:
	MOVL	SP,GBCFL	;NOTE GBCOL ENTERED
	MOVL	R6,GBSVA	;SAVE ENTRY WA
	MOVL	R7,GBSVB	;SAVE ENTRY WB
	MOVL	R8,GBSVC	;SAVE ENTRY WC
	MOVL	R10,-(SP)	;SAVE ENTRY XL
	MOVL	R3,R6		;GET CODE POINTER VALUE
	SUBL2	R$COD,R6	;MAKE RELATIVE
	MOVL	R6,R3		;AND RESTORE
;
;      PROCESS STACK ENTRIES
;
	MOVL	SP,R9		;POINT TO STACK FRONT
	MOVL	STBAS,R10	;POINT PAST END OF STACK
	CMPL	R10,R9		;OK IF D-STACK
	BGEQU	GBC00
	MOVL	R10,R9		;REVERSE IF ...
	MOVL	SP,R10		;... U-STACK
;
;      PROCESS THE STACK
;
GBC00::	JSB	GBCPF		;PROCESS POINTERS ON STACK
;
;      PROCESS SPECIAL WORK LOCATIONS
;
	MOVL	#R$AAA,R9	;POINT TO START OF RELOCATABLE LOCS
	MOVL	#R$YYY,R10	;POINT PAST END OF RELOCATABLE LOCS
	JSB	GBCPF		;PROCESS WORK FIELDS
;
;      PREPARE TO PROCESS VARIABLE BLOCKS
;
	MOVL	HSHTB,R6	;POINT TO FIRST HASH SLOT POINTER
;
;      LOOP THROUGH HASH SLOTS
;
GBC01::	MOVL	R6,R10		;POINT TO NEXT SLOT
	ADDL2	#4,R6		;BUMP BUCKET POINTER
	MOVL	R6,GBCNM	;SAVE BUCKET POINTER
	.PAGE
;
;      GBCOL (CONTINUED)
;
;      LOOP THROUGH VARIABLES ON ONE HASH CHAIN
;
GBC02::	MOVL	(R10),R9	;LOAD PTR TO NEXT VRBLK
	BEQLU	GBC03
	MOVL	R9,R10		;ELSE COPY VRBLK POINTER
	ADDL2	#4*VRVAL,R9	;POINT TO FIRST RELOC FLD
	ADDL2	#4*VRNXT,R10	;POINT PAST LAST (AND TO LINK PTR)
	JSB	GBCPF		;PROCESS RELOC FIELDS IN VRBLK
	JMP	GBC02		;LOOP BACK FOR NEXT BLOCK
;
;      HERE AT END OF ONE HASH CHAIN
;
GBC03::	MOVL	GBCNM,R6	;RESTORE BUCKET POINTER
	CMPL	R6,HSHTE	;LOOP BACK IF MORE BUCKETS TO GO
	BNEQU	GBC01
	.PAGE
;
;      GBCOL (CONTINUED)
;
;      NOW WE ARE READY TO START PASS TWO. REGISTERS ARE USED
;      AS FOLLOWS IN PASS TWO.
;
;      (XR)                  SCANS THROUGH ALL BLOCKS
;      (WC)                  POINTER TO EVENTUAL LOCATION
;
;      THE MOVE DESCRIPTION BLOCKS BUILT IN THIS PASS HAVE
;      THE FOLLOWING FORMAT.
;
;      WORD 1                POINTER TO NEXT MOVE BLOCK,
;                            ZERO IF END OF CHAIN OF BLOCKS
;
;      WORD 2                LENGTH OF BLOCKS TO BE MOVED IN
;                            BYTES. SET TO THE ADDRESS OF THE
;                            FIRST BYTE WHILE ACTUALLY SCANNING
;                            THE BLOCKS.
;
;      THE FIRST ENTRY ON THIS CHAIN IS A SPECIAL ENTRY
;      CONSISTING OF THE TWO WORDS GBCNM AND GBCNS. AFTER
;      BUILDING THE CHAIN OF MOVE DESCRIPTORS, GBCNM POINTS TO
;      THE FIRST REAL MOVE BLOCK, AND GBCNS IS THE LENGTH OF
;      BLOCKS IN USE AT THE START OF STORAGE WHICH NEED NOT
;      BE MOVED SINCE THEY ARE IN THE CORRECT POSITION.
;
GBC04::	MOVL	DNAMB,R9	;POINT TO FIRST BLOCK
	MOVL	R9,R8		;SET AS FIRST EVENTUAL LOCATION
	ADDL2	GBSVB,R8	;ADD OFFSET FOR EVENTUAL MOVE UP
	CLRL	GBCNM		;CLEAR INITIAL FORWARD POINTER
	MOVL	#GBCNM,GBCLM	;INITIALIZE PTR TO LAST MOVE BLOCK
	MOVL	R9,GBCNS	;INITIALIZE FIRST ADDRESS
;
;      LOOP THROUGH A SERIES OF BLOCKS IN USE
;
GBC05::	CMPL	R9,DNAMP	;JUMP IF END OF USED REGION
	BEQLU	GBC07
	MOVL	(R9),R6		;ELSE GET FIRST WORD
	CMPL	R6,#P$YYY	;SKIP IF NOT ENTRY PTR (IN USE)
	BGEQU	GBC06
	CMPL	R6,#B$AAA	;JUMP IF ENTRY POINTER (UNUSED)
	BGEQU	GBC07
;
;      HERE FOR BLOCK IN USE, LOOP TO RELOCATE REFERENCES
;
GBC06::	MOVL	R6,R10		;COPY POINTER
	MOVL	(R10),R6	;LOAD FORWARD POINTER
	MOVL	R8,(R10)	;RELOCATE REFERENCE
	CMPL	R6,#P$YYY	;LOOP BACK IF NOT END OF CHAIN
	BGEQU	GBC06
	CMPL	R6,#B$AAA	;LOOP BACK IF NOT END OF CHAIN
	BLEQU	GBC06
	.PAGE
;
;      GBCOL (CONTINUED)
;
;      AT END OF CHAIN, RESTORE FIRST WORD AND BUMP PAST
;
	MOVL	R6,(R9)		;RESTORE FIRST WORD
	JSB	BLKLN		;GET LENGTH OF THIS BLOCK
	ADDL2	R6,R9		;BUMP ACTUAL POINTER
	ADDL2	R6,R8		;BUMP EVENTUAL POINTER
	JMP	GBC05		;LOOP BACK FOR NEXT BLOCK
;
;      HERE AT END OF A SERIES OF BLOCKS IN USE
;
GBC07::	MOVL	R9,R6		;COPY POINTER PAST LAST BLOCK
	MOVL	GBCLM,R10	;POINT TO PREVIOUS MOVE BLOCK
	SUBL2	4*1(R10),R6	;SUBTRACT STARTING ADDRESS
	MOVL	R6,4*1(R10)	;STORE LENGTH OF BLOCK TO BE MOVED
;
;      LOOP THROUGH A SERIES OF BLOCKS NOT IN USE
;
GBC08::	CMPL	R9,DNAMP	;JUMP IF END OF USED REGION
	BEQLU	GBC10
	MOVL	(R9),R6		;ELSE LOAD FIRST WORD OF NEXT BLOCK
	CMPL	R6,#P$YYY	;JUMP IF IN USE
	BGEQU	GBC09
	CMPL	R6,#B$AAA	;JUMP IF IN USE
	BLEQU	GBC09
	JSB	BLKLN		;ELSE GET LENGTH OF NEXT BLOCK
	ADDL2	R6,R9		;PUSH POINTER
	JMP	GBC08		;AND LOOP BACK
;
;      HERE FOR A BLOCK IN USE AFTER PROCESSING A SERIES OF
;      BLOCKS WHICH WERE NOT IN USE, BUILD NEW MOVE BLOCK.
;
GBC09::	SUBL2	#4*NUM02,R9	;POINT 2 WORDS BEHIND FOR MOVE BLOCK
	MOVL	GBCLM,R10	;POINT TO PREVIOUS MOVE BLOCK
	MOVL	R9,(R10)	;SET FORWARD PTR IN PREVIOUS BLOCK
	CLRL	(R9)		;ZERO FORWARD PTR OF NEW BLOCK
	MOVL	R9,GBCLM	;REMEMBER ADDRESS OF THIS BLOCK
	MOVL	R9,R10		;COPY PTR TO MOVE BLOCK
	ADDL2	#4*NUM02,R9	;POINT BACK TO BLOCK IN USE
	MOVL	R9,4*1(R10)	;STORE STARTING ADDRESS
	JMP	GBC06		;JUMP TO PROCESS BLOCK IN USE
	.PAGE
;
;      GBCOL (CONTINUED)
;
;      HERE FOR PASS THREE -- ACTUALLY MOVE THE BLOCKS DOWN
;
;      (XL)                  POINTER TO OLD LOCATION
;      (XR)                  POINTER TO NEW LOCATION
;
GBC10::	MOVL	DNAMB,R9	;POINT TO START OF STORAGE
	ADDL2	GBCNS,R9	;BUMP PAST UNMOVED BLOCKS AT START
;
;      LOOP THROUGH MOVE DESCRIPTORS
;
GBC11::	MOVL	GBCNM,R10	;POINT TO NEXT MOVE BLOCK
	BEQLU	GBC12
	MOVL	(R10)+,GBCNM	;MOVE POINTER DOWN CHAIN
	MOVL	(R10)+,R6	;GET LENGTH TO MOVE
	MVW			;PERFORM MOVE
	JMP	GBC11		;LOOP BACK
;
;      NOW TEST FOR MOVE UP
;
GBC12::	MOVL	R9,DNAMP	;SET NEXT AVAILABLE LOC PTR
	MOVL	GBSVB,R7	;RELOAD MOVE OFFSET
	BEQLU	GBC13
	MOVL	R9,R10		;ELSE COPY OLD TOP OF CORE
	ADDL2	R7,R9		;POINT TO NEW TOP OF CORE
	MOVL	R9,DNAMP	;SAVE NEW TOP OF CORE POINTER
	MOVL	R10,R6		;COPY OLD TOP
	SUBL2	DNAMB,R6	;MINUS OLD BOTTOM = LENGTH
	ADDL2	R7,DNAMB	;BUMP BOTTOM TO GET NEW VALUE
	MWB			;PERFORM MOVE (BACKWARDS)
;
;      MERGE HERE TO EXIT
;
GBC13::	MOVL	GBSVA,R6	;RESTORE WA
	MOVL	R3,R8		;GET CODE POINTER
	ADDL2	R$COD,R8	;MAKE ABSOLUTE AGAIN
	MOVL	R8,R3		;AND REPLACE ABSOLUTE VALUE
	MOVL	GBSVC,R8	;RESTORE WC
	MOVL	(SP)+,R10	;RESTORE ENTRY XL
	INCL	GBCNT		;INCREMENT COUNT OF COLLECTIONS
	CLRL	R9		;CLEAR GARBAGE VALUE IN XR
	CLRL	GBCFL		;NOTE EXIT FROM GBCOL
	RSB			;EXIT TO GBCOL CALLER
;
;      GARBAGE COLLECTION NOT ALLOWED WHILST DUMPING
;
GBC14::	INCL	ERRFT		;FATAL ERROR
	JMP	ERROR_250	;INSUFFICIENT MEMORY TO COMPLETE DUMP
	;ENP			;END PROCEDURE GBCOL
	.PAGE
;
;      GBCPF -- PROCESS FIELDS FOR GARBAGE COLLECTOR
;
;      THIS PROCEDURE IS USED BY THE GARBAGE COLLECTOR TO
;      PROCESS FIELDS IN PASS ONE. SEE GBCOL FOR FULL DETAILS.
;
;      (XR)                  PTR TO FIRST LOCATION TO PROCESS
;      (XL)                  PTR PAST LAST LOCATION TO PROCESS
;      JSR  GBCPF            CALL TO PROCESS FIELDS
;      (XR,WA,WB,WC,IA)      DESTROYED
;
;      NOTE THAT ALTHOUGH THIS PROCEDURE USES A RECURSIVE
;      APPROACH, IT CONTROLS ITS OWN STACK AND IS NOT RECURSIVE.
;
	.ENABLE	LOCAL_BLOCK
GBCPF::	;PRC			;ENTRY POINT
	CLRL	-(SP)		;SET ZERO TO MARK BOTTOM OF STACK
	MOVL	R10,-(SP)	;SAVE END POINTER
;
;      MERGE HERE TO GO DOWN A LEVEL AND START A NEW LOOP
;
;      1(XS)                 NEXT LVL FIELD PTR (0 AT OUTER LVL)
;      0(XS)                 PTR PAST LAST FIELD TO PROCESS
;      (XR)                  PTR TO FIRST FIELD TO PROCESS
;
;      LOOP TO PROCESS SUCCESSIVE FIELDS
;
GPF01::	MOVL	(R9),R10	;LOAD FIELD CONTENTS
	MOVL	R9,R8		;SAVE FIELD POINTER
	CMPL	R10,DNAMB	;JUMP IF NOT PTR INTO DYNAMIC AREA
	BLSSU	GPF02
	CMPL	R10,DNAMP	;JUMP IF NOT PTR INTO DYNAMIC AREA
	BGEQU	GPF02
;
;      HERE WE HAVE A PTR TO A BLOCK IN THE DYNAMIC AREA.
;      LINK THIS FIELD ONTO THE REFERENCE BACKCHAIN.
;
	MOVL	(R10),R6	;LOAD PTR TO CHAIN (OR ENTRY PTR)
	MOVL	R9,(R10)	;SET THIS FIELD AS NEW HEAD OF CHAIN
	MOVL	R6,(R9)		;SET FORWARD POINTER
;
;      NOW SEE IF THIS BLOCK HAS BEEN PROCESSED BEFORE
;
	CMPL	R6,#P$YYY	;JUMP IF ALREADY PROCESSED
	BGEQU	GPF02
	CMPL	R6,#B$AAA	;JUMP IF NOT ALREADY PROCESSED
	BGEQU	GPF03
;
;      HERE TO MOVE TO NEXT FIELD
;
GPF02::	MOVL	R8,R9		;RESTORE FIELD POINTER
	ADDL2	#4,R9		;BUMP TO NEXT FIELD
	CMPL	R9,(SP)		;LOOP BACK IF MORE TO GO
	BNEQU	GPF01
	.PAGE
;
;      GBCPF (CONTINUED)
;
;      HERE WE POP UP A LEVEL AFTER FINISHING A BLOCK
;
	MOVL	(SP)+,R10	;RESTORE POINTER PAST END
	MOVL	(SP)+,R8	;RESTORE BLOCK POINTER
	TSTL	R8		;CONTINUE LOOP UNLESS OUTER LEVL
	BNEQU	GPF02
	RSB			;RETURN TO CALLER IF OUTER LEVEL
;
;      HERE TO PROCESS AN ACTIVE BLOCK WHICH HAS NOT BEEN DONE
;
GPF03::	MOVL	R10,R9		;COPY BLOCK POINTER
	MOVL	R6,R10		;COPY FIRST WORD OF BLOCK
	MOVZWL	-2(R10),R10	;LOAD ENTRY POINT ID (BL$XX)
;
;      BLOCK TYPE SWITCH. NOTE THAT BLOCKS WITH NO RELOCATABLE
;      FIELDS JUST RETURN TO GPF02 HERE TO CONTINE TO NEXT FLD.
;
	BSW	R10,BL$$$	;SWITCH ON BLOCK TYPE
	IFF	BL$AR,GPF06	;ARBLK
	IFF	BL$CC,GPF07	;CCBLK
	IFF	BL$CD,GPF08	;CDBLK
	IFF	BL$CM,GPF04	;CMBLK
	IFF	BL$DF,GPF02	;DFBLK
	IFF	BL$EV,GPF10	;EVBLK
	IFF	BL$EX,GPF17	;EXBLK
	IFF	BL$FF,GPF11	;FFBLK
	IFF	BL$NM,GPF10	;NMBLK
	IFF	BL$P0,GPF10	;P0BLK
	IFF	BL$P1,GPF12	;P1BLK
	IFF	BL$P2,GPF12	;P2BLK
	IFF	BL$PD,GPF13	;PDBLK
	IFF	BL$PF,GPF14	;PFBLK
	IFF	BL$TB,GPF08	;TBBLK
	IFF	BL$TE,GPF15	;TEBLK
	IFF	BL$TR,GPF16	;TRBLK
	IFF	BL$VC,GPF08	;VCBLK
	IFF	BL$XR,GPF09	;XRBLK
	IFF	BL$CT,GPF02	;CTBLK
	IFF	BL$EF,GPF02	;EFBLK
	IFF	BL$IC,GPF02	;ICBLK
	IFF	BL$KV,GPF02	;KVBLK
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	IFF	BL$RC,GPF02	;RCBLK
	.ENDC
	IFF	BL$SC,GPF02	;SCBLK
	IFF	BL$SE,GPF02	;SEBLK
	IFF	BL$XN,GPF02	;XNBLK
	ESW			;END OF JUMP TABLE
	.PAGE
;
;      GBCPF (CONTINUED)
;
;      CMBLK
;
GPF04::	MOVL	4*CMLEN(R9),R6	;LOAD LENGTH
	MOVL	#4*CMTYP,R7	;SET OFFSET
;
;      HERE TO PUSH DOWN TO NEW LEVEL
;
;      (WC)                  FIELD PTR AT PREVIOUS LEVEL
;      (XR)                  PTR TO NEW BLOCK
;      (WA)                  LENGTH (RELOC FLDS + FLDS AT START)
;      (WB)                  OFFSET TO FIRST RELOC FIELD
;
GPF05::	ADDL2	R9,R6		;POINT PAST LAST RELOC FIELD
	ADDL2	R7,R9		;POINT TO FIRST RELOC FIELD
	MOVL	R8,-(SP)	;STACK OLD FIELD POINTER
	MOVL	R6,-(SP)	;STACK NEW LIMIT POINTER
	;CHK			;CHECK FOR STACK OVERFLOW
	JMP	GPF01		;IF OK, BACK TO PROCESS
;
;      ARBLK
;
GPF06::	MOVL	4*ARLEN(R9),R6	;LOAD LENGTH
	MOVL	4*AROFS(R9),R7	;SET OFFSET TO 1ST RELOC FLD (ARPRO)
	JMP	GPF05		;ALL SET
;
;      CCBLK
;
GPF07::	MOVL	4*CCUSE(R9),R6	;SET LENGTH IN USE
	MOVL	#4*CCUSE,R7	;1ST WORD (MAKE SURE AT LEAST ONE)
	JMP	GPF05		;ALL SET
	.PAGE
;
;      GBCPF (CONTINUED)
;
;      CDBLK, TBBLK, VCBLK
;
GPF08::	MOVL	4*OFFS2(R9),R6	;LOAD LENGTH
	MOVL	#4*OFFS3,R7	;SET OFFSET
	JMP	GPF05		;JUMP BACK
;
;      XRBLK
;
GPF09::	MOVL	4*XRLEN(R9),R6	;LOAD LENGTH
	MOVL	#4*XRPTR,R7	;SET OFFSET
	JMP	GPF05		;JUMP BACK
;
;      EVBLK, NMBLK, P0BLK
;
GPF10::	MOVL	#4*OFFS2,R6	;POINT PAST SECOND FIELD
	MOVL	#4*OFFS1,R7	;OFFSET IS ONE (ONLY RELOC FLD IS 2)
	JMP	GPF05		;ALL SET
;
;      FFBLK
;
GPF11::	MOVL	#4*FFOFS,R6	;SET LENGTH
	MOVL	#4*FFNXT,R7	;SET OFFSET
	JMP	GPF05		;ALL SET
;
;      P1BLK, P2BLK
;
GPF12::	MOVL	#4*PARM2,R6	;LENGTH (PARM2 IS NON-RELOCATABLE)
	MOVL	#4*PTHEN,R7	;SET OFFSET
	JMP	GPF05		;ALL SET
	.PAGE
;
;      GBCPF (CONTINUED)
;
;      PDBLK
;
GPF13::	MOVL	4*PDDFP(R9),R10	;LOAD PTR TO DFBLK
	MOVL	4*DFPDL(R10),R6	;GET PDBLK LENGTH
	MOVL	#4*PDFLD,R7	;SET OFFSET
	JMP	GPF05		;ALL SET
;
;      PFBLK
;
GPF14::	MOVL	#4*PFARG,R6	;LENGTH PAST LAST RELOC
	MOVL	#4*PFCOD,R7	;OFFSET TO FIRST RELOC
	JMP	GPF05		;ALL SET
;
;      TEBLK
;
GPF15::	MOVL	#4*TESI$,R6	;SET LENGTH
	MOVL	#4*TESUB,R7	;AND OFFSET
	JMP	GPF05		;ALL SET
;
;      TRBLK
;
GPF16::	MOVL	#4*TRSI$,R6	;SET LENGTH
	MOVL	#4*TRVAL,R7	;AND OFFSET
	JMP	GPF05		;ALL SET
;
;      EXBLK
;
GPF17::	MOVL	4*EXLEN(R9),R6	;LOAD LENGTH
	MOVL	#4*EXFLC,R7	;SET OFFSET
	JMP	GPF05		;JUMP BACK
	;ENP			;END PROCEDURE GBCPF
	.PAGE
;
;      GTARR -- GET ARRAY
;
;      GTARR IS PASSED AN OBJECT AND RETURNS AN ARRAY IF POSSIBL
;
;      (XR)                  VALUE TO BE CONVERTED
;      JSR  GTARR            CALL TO GET ARRAY
;      PPM  LOC              TRANSFER LOC FOR CONVERT IMPOSSIBLE
;      (XR)                  RESULTING ARRAY
;      (XL,WA,WB,WC)         DESTROYED
;
	.ENABLE	LOCAL_BLOCK
GTARR::	;PRC			;ENTRY POINT
	MOVL	(R9),R6		;LOAD TYPE WORD
	CMPL	R6,#B$ART	;EXIT IF ALREADY AN ARRAY
	BNEQU	5179$
	JMP	GTAR8
5179$:
	CMPL	R6,#B$VCT	;EXIT IF ALREADY AN ARRAY
	BNEQU	5180$
	JMP	GTAR8
5180$:
	CMPL	R6,#B$TBT	;ELSE FAIL IF NOT A TABLE [SGD02]
	BEQLU	5181$
	JMP	GTA9A
5181$:
;
;      HERE WE CONVERT A TABLE TO AN ARRAY
;
	MOVL	R9,-(SP)	;REPLACE TBBLK POINTER ON STACK
	CLRL	R9		;SIGNAL FIRST PASS
	CLRL	R7		;ZERO NON-NULL ELEMENT COUNT
;
;      THE FOLLOWING CODE IS EXECUTED TWICE. ON THE FIRST PASS,
;      SIGNALLED BY XR=0, THE NUMBER OF NON-NULL ELEMENTS IN
;      THE TABLE IS COUNTED IN WB. IN THE SECOND PASS, WHERE
;      XR IS A POINTER INTO THE ARBLK, THE NAME AND VALUE ARE
;      ENTERED INTO THE CURRENT ARBLK LOCATION.
;
GTAR1::	MOVL	(SP),R10	;POINT TO TABLE
	ADDL2	4*TBLEN(R10),R10;POINT PAST LAST BUCKET
	SUBL2	#4*TBBUK,R10	;SET FIRST BUCKET OFFSET
	MOVL	R10,R6		;COPY ADJUSTED POINTER
;
;      LOOP THROUGH BUCKETS IN TABLE BLOCK
;      NEXT THREE LINES OF CODE RELY ON TENXT HAVING A VALUE
;      1 LESS THAN TBBUK.
;
GTAR2::	MOVL	R6,R10		;COPY BUCKET POINTER
	SUBL2	#4,R6		;DECREMENT BUCKET POINTER
;
;      LOOP THROUGH TEBLKS ON ONE BUCKET CHAIN
;
GTAR3::	MOVL	4*TENXT(R10),R10;POINT TO NEXT TEBLK
	CMPL	R10,(SP)	;JUMP IF CHAIN END (TBBLK PTR)
	BEQLU	GTAR6
	MOVL	R10,CNVTP	;ELSE SAVE TEBLK POINTER
;
;      LOOP TO FIND VALUE DOWN TRBLK CHAIN
;
GTAR4::	MOVL	4*TEVAL(R10),R10;LOAD VALUE
	CMPL	(R10),#B$TRT	;LOOP TILL VALUE FOUND
	BEQLU	GTAR4
	MOVL	R10,R8		;COPY VALUE
	MOVL	CNVTP,R10	;RESTORE TEBLK POINTER
	.PAGE
;
;      GTARR (CONTINUED)
;
;      NOW CHECK FOR NULL AND TEST CASES
;
	CMPL	R8,#NULLS	;LOOP BACK TO IGNORE NULL VALUE
	BEQLU	GTAR3
	TSTL	R9		;JUMP IF SECOND PASS
	BNEQU	GTAR5
	INCL	R7		;FOR THE FIRST PASS, BUMP COUNT
	JMP	GTAR3		;AND LOOP BACK FOR NEXT TEBLK
;
;      HERE IN SECOND PASS
;
GTAR5::	MOVL	4*TESUB(R10),(R9)+ ;STORE SUBSCRIPT NAME
	MOVL	R8,(R9)+	;STORE VALUE IN ARBLK
	JMP	GTAR3		;LOOP BACK FOR NEXT TEBLK
;
;      HERE AFTER SCANNING TEBLKS ON ONE CHAIN
;
GTAR6::	CMPL	R6,(SP)		;LOOP BACK IF MORE BUCKETS TO GO
	BNEQU	GTAR2
	TSTL	R9		;ELSE JUMP IF SECOND PASS
	BNEQU	GTAR7
;
;      HERE AFTER COUNTING NON-NULL ELEMENTS
;
	TSTL	R7		;FAIL IF NO NON-NULL ELEMENTS
	BNEQU	5182$
	JMP	GTAR9
5182$:
	MOVL	R7,R6		;ELSE COPY COUNT
	ADDL2	R7,R6		;DOUBLE (TWO WORDS/ELEMENT)
	ADDL2	#ARVL2,R6	;ADD SPACE FOR STANDARD FIELDS
	MOVAL	0[R6],R6	;CONVERT LENGTH TO BYTES
	CMPL	R6,MXLEN	;FAIL IF TOO LONG FOR ARRAY
	BLSSU	5183$
	JMP	GTAR9
5183$:
	JSB	ALLOC		;ELSE ALLOCATE SPACE FOR ARBLK
	MOVL	#B$ART,(R9)	;STORE TYPE WORD
	CLRL	4*IDVAL(R9)	;ZERO ID FOR THE MOMENT
	MOVL	R6,4*ARLEN(R9)	;STORE LENGTH
	MOVL	#NUM02,4*ARNDM(R9) ;SET DIMENSIONS = 2
	MOVL	INTV1,R5	;GET INTEGER ONE
	MOVL	R5,4*ARLBD(R9)	;STORE AS LBD 1
	MOVL	R5,4*ARLB2(R9)	;STORE AS LBD 2
	MOVL	INTV2,R5	;LOAD INTEGER TWO
	MOVL	R5,4*ARDM2(R9)	;STORE AS DIM 2
	MOVL	R7,R5		;GET ELEMENT COUNT AS INTEGER
	MOVL	R5,4*ARDIM(R9)	;STORE AS DIM 1
	CLRL	4*ARPR2(R9)	;ZERO PROTOTYPE FIELD FOR NOW
	MOVL	#4*ARPR2,4*AROFS(R9) ;SET OFFSET FIELD (SIGNAL PASS 2)
	MOVL	R9,R7		;SAVE ARBLK POINTER
	ADDL2	#4*ARVL2,R9	;POINT TO FIRST ELEMENT LOCATION
	JMP	GTAR1		;JUMP BACK TO FILL IN ELEMENTS
	.PAGE
;
;      GTARR (CONTINUED)
;
;      HERE AFTER FILLING IN ELEMENT VALUES
;
GTAR7::	MOVL	R7,R9		;RESTORE ARBLK POINTER
	MOVL	R7,(SP)		;STORE AS RESULT
;
;      NOW WE NEED THE ARRAY PROTOTYPE WHICH IS OF THE FORM NN,2
;      THIS IS OBTAINED BY BUILDING THE STRING FOR NN02 AND
;      CHANGING THE ZERO TO A COMMA BEFORE STORING IT.
;
	MOVL	4*ARDIM(R9),R5	;GET NUMBER OF ELEMENTS (NN)
	MULL2	INTVH,R5	;MULTIPLY BY 100
	ADDL2	INTV2,R5	;ADD 2 (NN02)
	JSB	ICBLD		;BUILD INTEGER
	MOVL	R9,-(SP)	;STORE PTR FOR GTSTG
	JSB	GTSTG		;CONVERT TO STRING
	.ADDRESS INVALID$	;CONVERT FAIL IS IMPOSSIBLE
	MOVL	R9,R10		;COPY STRING POINTER
	MOVL	(SP)+,R9	;RELOAD ARBLK POINTER
	MOVL	R10,4*ARPR2(R9)	;STORE PROTOTYPE PTR (NN02)
	SUBL2	#NUM02,R6	;ADJUST LENGTH TO POINT TO ZERO
	MOVAB	CFP$F(R10)[R6],R10 ;POINT TO ZERO
	MOVL	#CH$CM,R7	;LOAD A COMMA
	MOVB	R7,(R10)	;STORE A COMMA OVER THE ZERO
	;CSC	R10		;COMPLETE STORE CHARACTERS
;
;      NORMAL RETURN
;
GTAR8::	ADDL2	#4*1,(SP)	;RETURN TO CALLER
	RSB
;
;      NON-CONVERSION RETURN
;
GTAR9::	MOVL	(SP)+,R9	;RESTORE STACK FOR CONV ERR EXIT [SGD02]
;
;      MERGE TO TAKE CONVERT ERROR WHEN STACK ADJUSTED OK
;
GTA9A::	MOVL	(SP)+,R11	;RETURN
	JMP	@(R11)+
	;ENP			;PROCEDURE GTARR
	.PAGE
;
;      GTCOD -- CONVERT TO CODE
;
;      (XR)                  OBJECT TO BE CONVERTED
;      JSR  GTCOD            CALL TO CONVERT TO CODE
;      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
;      (XR)                  POINTER TO RESULTING CDBLK
;      (XL,WA,WB,WC,RA)      DESTROYED
;
;      IF A SPITBOL ERROR OCCURS DURING COMPILATION OR PRE-
;      EVALUATION, CONTROL IS PASSED VIA ERROR SECTION TO EXFAL
;      WITHOUT RETURNING TO THIS ROUTINE.
;
	.ENABLE	LOCAL_BLOCK
GTCOD::	;PRC			;ENTRY POINT
	CMPL	(R9),#B$CDS	;JUMP IF ALREADY CODE
	BEQLU	GTCD1
	CMPL	(R9),#B$CDC	;JUMP IF ALREADY CODE
	BEQLU	GTCD1
;
;      HERE WE MUST GENERATE A CDBLK BY COMPILATION
;
	MOVL	R9,-(SP)	;STACK ARGUMENT FOR GTSTG
	JSB	GTSTG		;CONVERT ARGUMENT TO STRING
	.ADDRESS GTCD2		;JUMP IF NON-CONVERTIBLE
	MOVL	FLPTR,GTCEF	;SAVE FAIL PTR IN CASE OF ERROR
	MOVL	R$COD,R$GTC	;ALSO SAVE CODE PTR
	MOVL	R9,R$CIM	;ELSE SET IMAGE POINTER
	MOVL	R6,SCNIL	;SET IMAGE LENGTH
	CLRL	SCNPT		;SET SCAN POINTER
	MOVL	#STGXC,STAGE	;SET STAGE FOR EXECUTE COMPILE
	MOVL	CMPSN,LSTSN	;IN CASE LISTR CALLED
	JSB	CMPIL		;COMPILE STRING
	MOVL	#STGXT,STAGE	;RESET STAGE FOR EXECUTE TIME
	CLRL	R$CIM		;CLEAR IMAGE
;
;      MERGE HERE IF NO CONVERT REQUIRED
;
GTCD1::	ADDL2	#4*1,(SP)	;GIVE NORMAL GTCOD RETURN
	RSB
;
;      HERE IF UNCONVERTIBLE
;
GTCD2::	MOVL	(SP)+,R11	;GIVE ERROR RETURN
	JMP	@(R11)+
	;ENP			;END PROCEDURE GTCOD
	.PAGE
;
;      GTEXP -- CONVERT TO EXPRESSION
;
;      (XR)                  INPUT VALUE TO BE CONVERTED
;      JSR  GTEXP            CALL TO CONVERT TO EXPRESSION
;      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
;      (XR)                  POINTER TO RESULT EXBLK OR SEBLK
;      (XL,WA,WB,WC,RA)      DESTROYED
;
;      IF A SPITBOL ERROR OCCURS DURING COMPILATION OR PRE-
;      EVALUATION, CONTROL IS PASSED VIA ERROR SECTION TO EXFAL
;      WITHOUT RETURNING TO THIS ROUTINE.
;
	.ENABLE	LOCAL_BLOCK
GTEXP::	;PRC			;ENTRY POINT
	CMPL	(R9),#B$E$$	;JUMP IF ALREADY AN EXPRESSION
	BLEQU	GTEX1
	MOVL	R9,-(SP)	;STORE ARGUMENT FOR GTSTG
	JSB	GTSTG		;CONVERT ARGUMENT TO STRING
	.ADDRESS GTEX2		;JUMP IF UNCONVERTIBLE
;
;      HERE WE CONVERT A STRING BY COMPILATION
;
	MOVL	R9,R$CIM	;SET INPUT IMAGE POINTER
	CLRL	SCNPT		;SET SCAN POINTER
	MOVL	R6,SCNIL	;SET INPUT IMAGE LENGTH
	CLRL	R7		;SET CODE FOR NORMAL SCAN
	MOVL	FLPTR,GTCEF	;SAVE FAIL PTR IN CASE OF ERROR
	MOVL	R$COD,R$GTC	;ALSO SAVE CODE PTR
	MOVL	#STGEV,STAGE	;ADJUST STAGE FOR COMPILE
	MOVL	#T$UOK,SCNTP	;INDICATE UNARY OPERATOR ACCEPTABLE
	JSB	EXPAN		;BUILD TREE FOR EXPRESSION
	CLRL	SCNRS		;RESET RESCAN FLAG
	CMPL	SCNPT,SCNIL	;ERROR IF NOT END OF IMAGE
	BNEQU	GTEX2
	CLRL	R7		;SET OK VALUE FOR CDGEX CALL
	MOVL	R9,R10		;COPY TREE POINTER
	JSB	CDGEX		;BUILD EXPRESSION BLOCK
	CLRL	R$CIM		;CLEAR POINTER
	MOVL	#STGXT,STAGE	;RESTORE STAGE FOR EXECUTE TIME
;
;      MERGE HERE IF NO CONVERSION REQUIRED
;
GTEX1::	ADDL2	#4*1,(SP)	;RETURN TO GTEXP CALLER
	RSB
;
;      HERE IF UNCONVERTIBLE
;
GTEX2::	MOVL	(SP)+,R11	;TAKE ERROR EXIT
	JMP	@(R11)+
	;ENP			;END PROCEDURE GTEXP
	.PAGE
;
;      GTINT -- GET INTEGER VALUE
;
;      GTINT IS PASSED AN OBJECT AND RETURNS AN INTEGER AFTER
;      PERFORMING ANY NECESSARY CONVERSIONS.
;
;      (XR)                  VALUE TO BE CONVERTED
;      JSR  GTINT            CALL TO CONVERT TO INTEGER
;      PPM  LOC              TRANSFER LOC FOR CONVERT IMPOSSIBLE
;      (XR)                  RESULTING INTEGER
;      (WC,RA)               DESTROYED
;      (WA,WB)               DESTROYED (ONLY ON CONVERSION ERR)
;      (XR)                  UNCHANGED (ON CONVERT ERROR)
;
	.ENABLE	LOCAL_BLOCK
GTINT::	;PRC			;ENTRY POINT
	CMPL	(R9),#B$ICL	;JUMP IF ALREADY AN INTEGER
	BEQLU	GTIN2
	MOVL	R6,GTINA	;ELSE SAVE WA
	MOVL	R7,GTINB	;SAVE WB
	JSB	GTNUM		;CONVERT TO NUMERIC
	.ADDRESS GTIN3		;JUMP IF UNCONVERTIBLE
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	CMPL	R6,#B$ICL	;JUMP IF INTEGER
	BEQLU	GTIN1
;
;      HERE WE CONVERT A REAL TO INTEGER
;
	MOVF	4*RCVAL(R9),R2	;LOAD REAL VALUE
	CVTFL	R2,R5		;CONVERT TO INTEGER (ERR IF OVFLOW)
	BVS	GTIN3
	JSB	ICBLD		;IF OK BUILD ICBLK
	.ENDC
;
;      HERE AFTER SUCCESSFUL CONVERSION TO INTEGER
;
GTIN1::	MOVL	GTINA,R6	;RESTORE WA
	MOVL	GTINB,R7	;RESTORE WB
;
;      COMMON EXIT POINT
;
GTIN2::	ADDL2	#4*1,(SP)	;RETURN TO GTINT CALLER
	RSB
;
;      HERE ON CONVERSION ERROR
;
GTIN3::	MOVL	(SP)+,R11	;TAKE CONVERT ERROR EXIT
	JMP	@(R11)+
	;ENP			;END PROCEDURE GTINT
	.PAGE
;
;      GTNUM -- GET NUMERIC VALUE
;
;      GTNUM IS GIVEN AN OBJECT AND RETURNS EITHER AN INTEGER
;      OR A REAL, PERFORMING ANY NECESSARY CONVERSIONS.
;
;      (XR)                  OBJECT TO BE CONVERTED
;      JSR  GTNUM            CALL TO CONVERT TO NUMERIC
;      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
;      (XR)                  POINTER TO RESULT (INT OR REAL)
;      (WA)                  FIRST WORD OF RESULT BLOCK
;      (WB,WC,RA)            DESTROYED
;      (XR)                  UNCHANGED (ON CONVERT ERROR)
;
	.ENABLE	LOCAL_BLOCK
GTNUM::	;PRC			;ENTRY POINT
	MOVL	(R9),R6		;LOAD FIRST WORD OF BLOCK
	CMPL	R6,#B$ICL	;JUMP IF INTEGER (NO CONVERSION)
	BNEQU	5184$
	JMP	GTN34
5184$:
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	CMPL	R6,#B$RCL	;JUMP IF REAL (NO CONVERSION)
	BNEQU	5185$
	JMP	GTN34
5185$:
	.ENDC
;
;      AT THIS POINT THE ONLY POSSIBILITY IS TO CONVERT A STRING
;      TO AN INTEGER OR REAL AS APPROPRIATE.
;
	MOVL	R9,-(SP)	;STACK ARGUMENT IN CASE CONVERT ERR
	MOVL	R9,-(SP)	;STACK ARGUMENT FOR GTSTG
	JSB	GTSTG		;CONVERT ARGUMENT TO STRING
	.ADDRESS GTN36		;JUMP IF UNCONVERTIBLE
;
;      INITIALIZE NUMERIC CONVERSION
;
	MOVL	INTV0,R5	;INITIALIZE INTEGER RESULT TO ZERO
	TSTL	R6		;JUMP TO EXIT WITH ZERO IF NULL
	BNEQU	5186$
	JMP	GTN32
5186$:
				;SET BCT COUNTER FOR FOLLOWING LOOPS
	CLRL	GTNNF		;TENTATIVELY INDICATE RESULT +
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	MOVL	R5,GTNEX	;INITIALISE EXPONENT TO ZERO
	CLRL	GTNSC		;ZERO SCALE IN CASE REAL
	CLRL	GTNDF		;RESET FLAG FOR DEC POINT FOUND
	CLRL	GTNRD		;RESET FLAG FOR DIGITS FOUND
	MOVF	REAV0,R2	;ZERO REAL ACCUM IN CASE REAL
	.ENDC
	MOVAB	CFP$F(R9),R9	;POINT TO ARGUMENT CHARACTERS
;
;      MERGE BACK HERE AFTER IGNORING LEADING BLANK
;
GTN01::	MOVZBL	(R9)+,R7	;LOAD FIRST CHARACTER
	CMPL	R7,#CH$D0	;JUMP IF NOT DIGIT
	BLSSU	GTN02
	CMPL	R7,#CH$D9	;JUMP IF FIRST CHAR IS A DIGIT
	BLEQU	GTN06
	.PAGE
;
;      GTNUM (CONTINUED)
;
;      HERE IF FIRST DIGIT IS NON-DIGIT
;
GTN02::	CMPL	R7,#CH$BL	;JUMP IF NON-BLANK
	BNEQU	GTN03
GTNA2::	SOBGTR	R6,GTN01	;ELSE DECR COUNT AND LOOP BACK
	JMP	GTN07		;JUMP TO RETURN ZERO IF ALL BLANKS
;
;      HERE FOR FIRST CHARACTER NON-BLANK, NON-DIGIT
;
GTN03::	CMPL	R7,#CH$PL	;JUMP IF PLUS SIGN
	BEQLU	GTN04
	.IF NOT_EQUAL CAHT
	CMPL	R7,#CH$HT	;HORIZONTAL TAB EQUIV TO BLANK
	BEQLU	GTNA2
	.ENDC
	.IF NOT_EQUAL CAVT
	CMPL	R7,#CH$VT	;VERTICAL TAB EQUIV TO BLANK
	BEQLU	GTNA2
	.ENDC
	.IF NOT_EQUAL CNRA
	CMPL	R7,#CH$MN	;ELSE FAIL
	BEQLU	5187$
	JMP	GTN36
5187$:
	.IF_FALSE
	CMPL	R7,#CH$MN	;JUMP IF NOT MINUS (MAY BE REAL)
	BEQLU	5188$
	JMP	GTN12
5188$:
	.ENDC
	MOVL	SP,GTNNF	;IF MINUS SIGN, SET NEGATIVE FLAG
;
;      MERGE HERE AFTER PROCESSING SIGN
;
GTN04::	SOBGTR	R6,GTN05	;JUMP IF CHARS LEFT
	JMP	GTN36		;ELSE ERROR
;
;      LOOP TO FETCH CHARACTERS OF AN INTEGER
;
GTN05::	MOVZBL	(R9)+,R7	;LOAD NEXT CHARACTER
	CMPL	R7,#CH$D0	;JUMP IF NOT A DIGIT
	BLSSU	GTN08
	CMPL	R7,#CH$D9	;JUMP IF NOT A DIGIT
	BGTRU	GTN08
;
;      MERGE HERE FOR FIRST DIGIT
;
GTN06::	MOVL	R5,GTNSI	;SAVE CURRENT VALUE
	.IF NOT_EQUAL CNRA
	CVM	GTN36		;CURRENT*10-(NEW DIG) JUMP IF OVFLOW
	.IF_FALSE
	CVM	GTN35		;CURRENT*10-(NEW DIG) JUMP IF OVFLOW
	MOVL	SP,GTNRD	;SET DIGIT READ FLAG
	.ENDC
	SOBGTR	R6,GTN05	;ELSE LOOP BACK IF MORE CHARS
;
;      HERE TO EXIT WITH CONVERTED INTEGER VALUE
;
GTN07::	TSTL	GTNNF		;JUMP IF NEGATIVE (ALL SET)
	BEQLU	5189$
	JMP	GTN32
5189$:
	MNEGL	R5,R5		;ELSE NEGATE
	BVS	5190$
	JMP	GTN32
5190$:
	JMP	GTN36		;ELSE SIGNAL ERROR
	.PAGE
;
;      GTNUM (CONTINUED)
;
;      HERE FOR A NON-DIGIT CHARACTER WHILE ATTEMPTING TO
;      CONVERT AN INTEGER, CHECK FOR TRAILING BLANKS OR REAL.
;
GTN08::	CMPL	R7,#CH$BL	;JUMP IF A BLANK
	BEQLU	GTNA9
	.IF NOT_EQUAL CAHT
	CMPL	R7,#CH$HT	;JUMP IF HORIZONTAL TAB
	BEQLU	GTNA9
	.ENDC
	.IF NOT_EQUAL CAVT
	CMPL	R7,#CH$VT	;JUMP IF VERTICAL TAB
	BEQLU	GTNA9
	.ENDC
	.IF NOT_EQUAL CNRA
	JMP	GTN36		;ERROR
	.IF_FALSE
	CVTLF	R5,R2		;ELSE CONVERT INTEGER TO REAL
	MNEGF	R2,R2		;NEGATE TO GET POSITIVE VALUE
	JMP	GTN12		;JUMP TO TRY FOR REAL
	.ENDC
;
;      HERE WE SCAN OUT BLANKS TO END OF STRING
;
GTN09::	MOVZBL	(R9)+,R7	;GET NEXT CHAR
	.IF NOT_EQUAL CAHT
	CMPL	R7,#CH$HT	;JUMP IF HORIZONTAL TAB
	BEQLU	GTNA9
	.ENDC
	.IF NOT_EQUAL CAVT
	CMPL	R7,#CH$VT	;JUMP IF VERTICAL TAB
	BEQLU	GTNA9
	.ENDC
	CMPL	R7,#CH$BL	;ERROR IF NON-BLANK
	BEQLU	5191$
	JMP	GTN36
5191$:
GTNA9::	SOBGTR	R6,GTN09	;LOOP BACK IF MORE CHARS TO CHECK
	JMP	GTN07		;RETURN INTEGER IF ALL BLANKS
	.IF NOT_EQUAL CNRA
	.IF_FALSE
;
;      LOOP TO COLLECT MANTISSA OF REAL
;
GTN10::	MOVZBL	(R9)+,R7	;LOAD NEXT CHARACTER
	CMPL	R7,#CH$D0	;JUMP IF NON-NUMERIC
	BGEQU	5192$
	JMP	GTN12
5192$:
	CMPL	R7,#CH$D9	;JUMP IF NON-NUMERIC
	BLEQU	5193$
	JMP	GTN12
5193$:
;
;      MERGE HERE TO COLLECT FIRST REAL DIGIT
;
GTN11::	SUBL2	#CH$D0,R7	;CONVERT DIGIT TO NUMBER
	MULF2	REAVT,R2	;MULTIPLY REAL BY 10.0
	BVC	5194$
	JMP	GTN36
5194$:
	MOVF	R2,GTNSR	;SAVE RESULT
	MOVL	R7,R5		;GET NEW DIGIT AS INTEGER
	CVTLF	R5,R2		;CONVERT NEW DIGIT TO REAL
	ADDF2	GTNSR,R2	;ADD TO GET NEW TOTAL
	ADDL2	GTNDF,GTNSC	;INCREMENT SCALE IF AFTER DEC POINT
	MOVL	SP,GTNRD	;SET DIGIT FOUND FLAG
	SOBGTR	R6,GTN10	;LOOP BACK IF MORE CHARS
	JMP	GTN22		;ELSE JUMP TO SCALE
	.PAGE
;
;      GTNUM (CONTINUED)
;
;      HERE IF NON-DIGIT FOUND WHILE COLLECTING A REAL
;
GTN12::	CMPL	R7,#CH$DT	;JUMP IF NOT DEC POINT
	BNEQU	GTN13
	TSTL	GTNDF		;IF DEC POINT, ERROR IF ONE ALREADY
	BEQLU	5195$
	JMP	GTN36
5195$:
	MOVL	#NUM01,GTNDF	;ELSE SET FLAG FOR DEC POINT
	SOBGTR	R6,GTN10	;LOOP BACK IF MORE CHARS
	JMP	GTN22		;ELSE JUMP TO SCALE
;
;      HERE IF NOT DECIMAL POINT
;
GTN13::	CMPL	R7,#CH$LE	;JUMP IF E FOR EXPONENT
	BEQLU	GTN15
	CMPL	R7,#CH$LD	;JUMP IF D FOR EXPONENT
	BEQLU	GTN15
;
;      HERE CHECK FOR TRAILING BLANKS
;
GTN14::	CMPL	R7,#CH$BL	;JUMP IF BLANK
	BEQLU	GTNB4
	.IF NOT_EQUAL CAHT
	CMPL	R7,#CH$HT	;JUMP IF HORIZONTAL TAB
	BEQLU	GTNB4
	.ENDC
	.IF NOT_EQUAL CAVT
	CMPL	R7,#CH$VT	;JUMP IF VERTICAL TAB
	BEQLU	GTNB4
	.ENDC
	JMP	GTN36		;ERROR IF NON-BLANK
;
GTNB4::	MOVZBL	(R9)+,R7	;GET NEXT CHARACTER
	SOBGTR	R6,GTN14	;LOOP BACK TO CHECK IF MORE
	JMP	GTN22		;ELSE JUMP TO SCALE
;
;      HERE TO READ AND PROCESS AN EXPONENT
;
GTN15::	CLRL	GTNES		;SET EXPONENT SIGN POSITIVE
	MOVL	INTV0,R5	;INITIALIZE EXPONENT TO ZERO
	MOVL	SP,GTNDF	;RESET NO DEC POINT INDICATION
	SOBGTR	R6,GTN16	;JUMP SKIPPING PAST E OR D
	JMP	GTN36		;ERROR IF NULL EXPONENT
;
;      CHECK FOR EXPONENT SIGN
;
GTN16::	MOVZBL	(R9)+,R7	;LOAD FIRST EXPONENT CHARACTER
	CMPL	R7,#CH$PL	;JUMP IF PLUS SIGN
	BEQLU	GTN17
	CMPL	R7,#CH$MN	;ELSE JUMP IF NOT MINUS SIGN
	BNEQU	GTN19
	MOVL	SP,GTNES	;SET SIGN NEGATIVE IF MINUS SIGN
;
;      MERGE HERE AFTER PROCESSING EXPONENT SIGN
;
GTN17::	SOBGTR	R6,GTN18	;JUMP IF CHARS LEFT
	JMP	GTN36		;ELSE ERROR
;
;      LOOP TO CONVERT EXPONENT DIGITS
;
GTN18::	MOVZBL	(R9)+,R7	;LOAD NEXT CHARACTER
	.PAGE
;
;      GTNUM (CONTINUED)
;
;      MERGE HERE FOR FIRST EXPONENT DIGIT
;
GTN19::	CMPL	R7,#CH$D0	;JUMP IF NOT DIGIT
	BLSSU	GTN20
	CMPL	R7,#CH$D9	;JUMP IF NOT DIGIT
	BGTRU	GTN20
	CVM	GTN36		;ELSE CURRENT*10, SUBTRACT NEW DIGIT
	SOBGTR	R6,GTN18	;LOOP BACK IF MORE CHARS
	JMP	GTN21		;JUMP IF EXPONENT FIELD IS EXHAUSTED
;
;      HERE TO CHECK FOR TRAILING BLANKS AFTER EXPONENT
;
GTN20::	CMPL	R7,#CH$BL	;JUMP IF BLANK
	BEQLU	GTNC0
	.IF NOT_EQUAL CAHT
	CMPL	R7,#CH$HT	;JUMP IF HORIZONTAL TAB
	BEQLU	GTNC0
	.ENDC
	.IF NOT_EQUAL CAVT
	CMPL	R8,#CH$VT	;JUMP IF VERTICAL TAB
	BEQLU	GTNC0
	.ENDC
	JMP	GTN36		;ERROR IF NON-BLANK
;
GTNC0::	MOVZBL	(R9)+,R7	;GET NEXT CHARACTER
	SOBGTR	R6,GTN20	;LOOP BACK TILL ALL BLANKS SCANNED
;
;      MERGE HERE AFTER COLLECTING EXPONENT
;
GTN21::	MOVL	R5,GTNEX	;SAVE COLLECTED EXPONENT
	TSTL	GTNES		;JUMP IF IT WAS NEGATIVE
	BNEQU	GTN22
	MNEGL	R5,R5		;ELSE COMPLEMENT
	BVC	5196$
	JMP	GTN36
5196$:
	MOVL	R5,GTNEX	;AND STORE POSITIVE EXPONENT
;
;      MERGE HERE WITH EXPONENT (0 IF NONE GIVEN)
;
GTN22::	TSTL	GTNRD		;ERROR IF NOT DIGITS COLLECTED
	BNEQU	5197$
	JMP	GTN36
5197$:
	TSTL	GTNDF		;ERROR IF NO EXPONENT OR DEC POINT
	BNEQU	5198$
	JMP	GTN36
5198$:
	MOVL	GTNSC,R5	;ELSE LOAD SCALE AS INTEGER
	SUBL2	GTNEX,R5	;SUBTRACT EXPONENT
	BVC	5199$
	JMP	GTN36
5199$:
	TSTL	R5		;JUMP IF WE MUST SCALE UP
	BLSS	GTN26
;
;      HERE WE HAVE A NEGATIVE EXPONENT, SO SCALE DOWN
;
	MFI	R6,GTN36	;LOAD SCALE FACTOR, ERR IF OVFLOW
;
;      LOOP TO SCALE DOWN IN STEPS OF 10**10
;
GTN23::	CMPL	R6,#NUM10	;JUMP IF 10 OR LESS TO GO
	BLEQU	GTN24
	DIVF2	REATT,R2	;ELSE DIVIDE BY 10**10
	SUBL2	#NUM10,R6	;DECREMENT SCALE
	JMP	GTN23		;AND LOOP BACK
	.PAGE
;
;      GTNUM (CONTINUED)
;
;      HERE SCALE REST OF WAY FROM POWERS OF TEN TABLE
;
GTN24::	TSTL	R6		;JUMP IF SCALED
	BEQLU	GTN30
	MOVL	#CFP$R,R7	;ELSE GET INDEXING FACTOR
	MOVL	#REAV1,R9	;POINT TO POWERS OF TEN TABLE
	MOVAL	0[R6],R6	;CONVERT REMAINING SCALE TO BYTE OFS
;
;      LOOP TO POINT TO POWERS OF TEN TABLE ENTRY
;
GTN25::	ADDL2	R6,R9		;BUMP POINTER
	SOBGTR	R7,GTN25	;ONCE FOR EACH VALUE WORD
	DIVF2	(R9),R2		;SCALE DOWN AS REQUIRED
	JMP	GTN30		;AND JUMP
;
;      COME HERE TO SCALE RESULT UP (POSITIVE EXPONENT)
;
GTN26::	MNEGL	R5,R5		;GET ABSOLUTE VALUE OF EXPONENT
	BVC	5200$
	JMP	GTN36
5200$:
	MFI	R6,GTN36	;ACQUIRE SCALE, ERROR IF OVFLOW
;
;      LOOP TO SCALE UP IN STEPS OF 10**10
;
GTN27::	CMPL	R6,#NUM10	;JUMP IF 10 OR LESS TO GO
	BLEQU	GTN28
	MULF2	REATT,R2	;ELSE MULTIPLY BY 10**10
	BVC	5201$
	JMP	GTN36
5201$:
	SUBL2	#NUM10,R6	;ELSE DECREMENT SCALE
	JMP	GTN27		;AND LOOP BACK
;
;      HERE TO SCALE UP REST OF WAY WITH TABLE
;
GTN28::	TSTL	R6		;JUMP IF SCALED
	BEQLU	GTN30
	MOVL	#CFP$R,R7	;ELSE GET INDEXING FACTOR
	MOVL	#REAV1,R9	;POINT TO POWERS OF TEN TABLE
	MOVAL	0[R6],R6	;CONVERT REMAINING SCALE TO BYTE OFS
;
;      LOOP TO POINT TO PROPER ENTRY IN POWERS OF TEN TABLE
;
GTN29::	ADDL2	R6,R9		;BUMP POINTER
	SOBGTR	R7,GTN29	;ONCE FOR EACH WORD IN VALUE
	MULF2	(R9),R2		;SCALE UP
	BVC	5202$
	JMP	GTN36
5202$:
	.PAGE
;
;      GTNUM (CONTINUED)
;
;      HERE WITH REAL VALUE SCALED AND READY EXCEPT FOR SIGN
;
GTN30::	TSTL	GTNNF		;JUMP IF POSITIVE
	BEQLU	GTN31
	MNEGF	R2,R2		;ELSE NEGATE
;
;      HERE WITH PROPERLY SIGNED REAL VALUE IN (RA)
;
GTN31::	JSB	RCBLD		;BUILD REAL BLOCK
	JMP	GTN33		;MERGE TO EXIT
	.ENDC
;
;      HERE WITH PROPERLY SIGNED INTEGER VALUE IN (IA)
;
GTN32::	JSB	ICBLD		;BUILD ICBLK
;
;      REAL MERGES HERE
;
GTN33::	MOVL	(R9),R6		;LOAD FIRST WORD OF RESULT BLOCK
	ADDL2	#4,SP		;POP ARGUMENT OFF STACK
;
;      COMMON EXIT POINT
;
GTN34::	ADDL2	#4*1,(SP)	;RETURN TO GTNUM CALLER
	RSB
	.IF NOT_EQUAL CNRA
	.IF_FALSE
;
;      COME HERE IF OVERFLOW OCCURS DURING COLLECTION OF INTEGER
;
GTN35::	MOVL	GTNSI,R5	;RELOAD INTEGER SO FAR
	CVTLF	R5,R2		;CONVERT TO REAL
	MNEGF	R2,R2		;MAKE VALUE POSITIVE
	JMP	GTN11		;MERGE WITH REAL CIRCUIT
	.ENDC
;
;      HERE FOR UNCONVERTIBLE TO STRING OR CONVERSION ERROR
;
GTN36::	MOVL	(SP)+,R9	;RELOAD ORIGINAL ARGUMENT
	MOVL	(SP)+,R11	;TAKE CONVERT-ERROR EXIT
	JMP	@(R11)+
	;ENP			;END PROCEDURE GTNUM
	.PAGE
;
;      GTNVR -- CONVERT TO NATURAL VARIABLE
;
;      GTNVR LOCATES A VARIABLE BLOCK (VRBLK) GIVEN EITHER AN
;      APPROPRIATE NAME (NMBLK) OR A NON-NULL STRING (SCBLK).
;
;      (XR)                  ARGUMENT
;      JSR  GTNVR            CALL TO CONVERT TO NATURAL VARIABLE
;      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
;      (XR)                  POINTER TO VRBLK
;      (WA,WB)               DESTROYED (CONVERSION ERROR ONLY)
;      (WC)                  DESTROYED
;
	.ENABLE	LOCAL_BLOCK
GTNVR::	;PRC			;ENTRY POINT
	CMPL	(R9),#B$NML	;JUMP IF NOT NAME
	BNEQU	GNV02
	MOVL	4*NMBAS(R9),R9	;ELSE LOAD NAME BASE IF NAME
	CMPL	R9,STATE	;SKIP IF VRBLK (IN STATIC REGION)
	BGTRU	5203$
	JMP	GNV07
5203$:
;
;      COMMON ERROR EXIT
;
GNV01::	MOVL	(SP)+,R11	;TAKE CONVERT-ERROR EXIT
	JMP	@(R11)+
;
;      HERE IF NOT NAME
;
GNV02::	MOVL	R6,GNVSA	;SAVE WA
	MOVL	R7,GNVSB	;SAVE WB
	MOVL	R9,-(SP)	;STACK ARGUMENT FOR GTSTG
	JSB	GTSTG		;CONVERT ARGUMENT TO STRING
	.ADDRESS GNV01		;JUMP IF CONVERSION ERROR
	TSTL	R6		;NULL STRING IS AN ERROR
	BEQLU	GNV01
	MOVL	R10,-(SP)	;SAVE XL
	MOVL	R9,-(SP)	;STACK STRING PTR FOR LATER
	MOVL	R9,R7		;COPY STRING POINTER
	ADDL2	#4*SCHAR,R7	;POINT TO CHARACTERS OF STRING
	MOVL	R7,GNVST	;SAVE POINTER TO CHARACTERS
	MOVL	R6,R7		;COPY LENGTH
	MOVAB	3+<4*0>(R7),R7	;GET NUMBER OF WORDS IN NAME
	ASHL	#-2,R7,R7
	MOVL	R7,GNVNW	;SAVE FOR LATER
	JSB	HASHS		;COMPUTE HASH INDEX FOR STRING
	RMI	HSHNB		;COMPUTE HASH OFFSET BY TAKING MOD
	MFI	R8		;GET AS OFFSET
	MOVAL	0[R8],R8	;CONVERT OFFSET TO BYTES
	ADDL2	HSHTB,R8	;POINT TO PROPER HASH CHAIN
	SUBL2	#4*VRNXT,R8	;SUBTRACT OFFSET TO MERGE INTO LOOP
	.PAGE
;
;      GTNVR (CONTINUED)
;
;      LOOP TO SEARCH HASH CHAIN
;
GNV03::	MOVL	R8,R10		;COPY HASH CHAIN POINTER
	MOVL	4*VRNXT(R10),R10;POINT TO NEXT VRBLK ON CHAIN
	TSTL	R10		;JUMP IF END OF CHAIN
	BEQLU	GNV08
	MOVL	R10,R8		;SAVE POINTER TO THIS VRBLK
	TSTL	4*VRLEN(R10)	;JUMP IF NOT SYSTEM VARIABLE
	BNEQU	GNV04
	MOVL	4*VRSVP(R10),R10;ELSE POINT TO SVBLK
	SUBL2	#4*VRSOF,R10	;ADJUST OFFSET FOR MERGE
;
;      MERGE HERE WITH STRING PTR (LIKE VRBLK) IN XL
;
GNV04::	CMPL	R6,4*VRLEN(R10)	;BACK FOR NEXT VRBLK IF LENGTHS NE
	BNEQU	GNV03
	ADDL2	#4*VRCHS,R10	;ELSE POINT TO CHARS OF CHAIN ENTRY
	MOVL	GNVNW,R7	;GET WORD COUNTER TO CONTROL LOOP
	MOVL	GNVST,R9	;POINT TO CHARS OF NEW NAME
;
;      LOOP TO COMPARE CHARACTERS OF THE TWO NAMES
;
GNV05::	CMPL	(R9),(R10)	;JUMP IF NO MATCH FOR NEXT VRBLK
	BNEQU	GNV03
	ADDL2	#4,R9		;BUMP NEW NAME POINTER
	ADDL2	#4,R10		;BUMP VRBLK IN CHAIN NAME POINTER
	SOBGTR	R7,GNV05	;ELSE LOOP TILL ALL COMPARED
	MOVL	R8,R9		;WE HAVE FOUND A MATCH, GET VRBLK
;
;      EXIT POINT AFTER FINDING VRBLK OR BUILDING NEW ONE
;
GNV06::	MOVL	GNVSA,R6	;RESTORE WA
	MOVL	GNVSB,R7	;RESTORE WB
	ADDL2	#4,SP		;POP STRING POINTER
	MOVL	(SP)+,R10	;RESTORE XL
;
;      COMMON EXIT POINT
;
GNV07::	ADDL2	#4*1,(SP)	;RETURN TO GTNVR CALLER
	RSB
;
;      NOT FOUND, PREPARE TO SEARCH SYSTEM VARIABLE TABLE
;
GNV08::	CLRL	R9		;CLEAR GARBAGE XR POINTER
	MOVL	R8,GNVHE	;SAVE PTR TO END OF HASH CHAIN
	CMPL	R6,#NUM09	;CANNOT BE SYSTEM VAR IF LENGTH GT 9
	BGTRU	GNV14
	MOVL	R6,R10		;ELSE COPY LENGTH
	MOVAL	0[R10],R10	;CONVERT TO BYTE OFFSET
	MOVL	L^VSRCH(R10),R10;POINT TO FIRST SVBLK OF THIS LENGTH
	.PAGE
;
;      GTNVR (CONTINUED)
;
;      LOOP TO SEARCH ENTRIES IN STANDARD VARIABLE TABLE
;
GNV09::	MOVL	R10,GNVSP	;SAVE TABLE POINTER
	MOVL	(R10)+,R8	;LOAD SVBIT BIT STRING
	MOVL	(R10)+,R7	;LOAD LENGTH FROM TABLE ENTRY
	CMPL	R6,R7		;JUMP IF END OF RIGHT LENGTH ENTIRES
	BNEQU	GNV14
	MOVL	GNVNW,R7	;GET WORD COUNTER TO CONTROL LOOP
	MOVL	GNVST,R9	;POINT TO CHARS OF NEW NAME
;
;      LOOP TO CHECK FOR MATCHING NAMES
;
GNV10::	CMPL	(R9),(R10)	;JUMP IF NAME MISMATCH
	BNEQU	GNV11
	ADDL2	#4,R9		;ELSE BUMP NEW NAME POINTER
	ADDL2	#4,R10		;BUMP SVBLK POINTER
	SOBGTR	R7,GNV10	;ELSE LOOP UNTIL ALL CHECKED
;
;      HERE WE HAVE A MATCH IN THE STANDARD VARIABLE TABLE
;
	CLRL	R8		;SET VRLEN VALUE ZERO
	MOVL	#4*VRSI$,R6	;SET STANDARD SIZE
	JMP	GNV15		;JUMP TO BUILD VRBLK
;
;      HERE IF NO MATCH WITH TABLE ENTRY IN SVBLKS TABLE
;
GNV11::	ADDL2	#4,R10		;BUMP PAST WORD OF CHARS
	SOBGTR	R7,GNV11	;LOOP BACK IF MORE TO GO
	ASHL	#-SVNBT,R8,R8	;REMOVE UNINTERESTING BITS
;
;      LOOP TO BUMP TABLE PTR FOR EACH FLAGGED WORD
;
GNV12::	MOVL	BITS1,R7	;LOAD BIT TO TEST
	MCOML	R8,R11		;TEST FOR WORD PRESENT
	BICL2	R11,R7
	BEQLU	GNV13
	ADDL2	#4,R10		;ELSE BUMP TABLE POINTER
;
;      HERE AFTER DEALING WITH ONE WORD (ONE BIT)
;
GNV13::	ASHL	#-1,R8,R8	;REMOVE BIT ALREADY PROCESSED
	TSTL	R8		;LOOP BACK IF MORE BITS TO TEST
	BNEQU	GNV12
	JMP	GNV09		;ELSE LOOP BACK FOR NEXT SVBLK
;
;      HERE IF NOT SYSTEM VARIABLE
;
GNV14::	MOVL	R6,R8		;COPY VRLEN VALUE
	MOVL	#VRCHS,R6	;LOAD STANDARD SIZE -CHARS
	ADDL2	GNVNW,R6	;ADJUST FOR CHARS OF NAME
	MOVAL	0[R6],R6	;CONVERT LENGTH TO BYTES
	.PAGE
;
;      GTNVR (CONTINUED)
;
;      MERGE HERE TO BUILD VRBLK
;
GNV15::	JSB	ALOST		;ALLOCATE SPACE FOR VRBLK (STATIC)
	MOVL	R9,R7		;SAVE VRBLK POINTER
	MOVL	#STNVR,R10	;POINT TO MODEL VARIABLE BLOCK
	MOVL	#4*VRLEN,R6	;SET LENGTH OF STANDARD FIELDS
	MVW			;SET INITIAL FIELDS OF NEW BLOCK
	MOVL	GNVHE,R10	;LOAD POINTER TO END OF HASH CHAIN
	MOVL	R7,4*VRNXT(R10)	;ADD NEW BLOCK TO END OF CHAIN
	MOVL	R8,(R9)+	;SET VRLEN FIELD, BUMP PTR
	MOVL	GNVNW,R6	;GET LENGTH IN WORDS
	MOVAL	0[R6],R6	;CONVERT TO LENGTH IN BYTES
	TSTL	R8		;JUMP IF SYSTEM VARIABLE
	BEQLU	GNV16
;
;      HERE FOR NON-SYSTEM VARIABLE -- SET CHARS OF NAME
;
	MOVL	(SP),R10	;POINT BACK TO STRING NAME
	ADDL2	#4*SCHAR,R10	;POINT TO CHARS OF NAME
	MVW			;MOVE CHARACTERS INTO PLACE
	MOVL	R7,R9		;RESTORE VRBLK POINTER
	JMP	GNV06		;JUMP BACK TO EXIT
;
;      HERE FOR SYSTEM VARIABLE CASE TO FILL IN FIELDS WHERE
;      NECESSARY FROM THE FIELDS PRESENT IN THE SVBLK.
;
GNV16::	MOVL	GNVSP,R10	;LOAD POINTER TO SVBLK
	MOVL	R10,(R9)	;SET SVBLK PTR IN VRBLK
	MOVL	R7,R9		;RESTORE VRBLK POINTER
	MOVL	4*SVBIT(R10),R7	;LOAD BIT INDICATORS
	ADDL2	#4*SVCHS,R10	;POINT TO CHARACTERS OF NAME
	ADDL2	R6,R10		;POINT PAST CHARACTERS
;
;      SKIP PAST KEYWORD NUMBER (SVKNM) IF PRESENT
;
	MOVL	BTKNM,R8	;LOAD TEST BIT
	MCOML	R7,R11		;AND TO TEST
	BICL2	R11,R8
	BEQLU	GNV17
	ADDL2	#4,R10		;ELSE BUMP POINTER
	.PAGE
;
;      GTNVR (CONTINUED)
;
;      HERE TEST FOR FUNCTION (SVFNC AND SVNAR)
;
GNV17::	MOVL	BTFNC,R8	;GET TEST BIT
	MCOML	R7,R11		;AND TO TEST
	BICL2	R11,R8
	BEQLU	GNV18
	MOVL	R10,4*VRFNC(R9)	;ELSE POINT VRFNC TO SVFNC FIELD
	ADDL2	#4*NUM02,R10	;AND BUMP PAST SVFNC, SVNAR FIELDS
;
;      NOW TEST FOR LABEL (SVLBL)
;
GNV18::	MOVL	BTLBL,R8	;GET TEST BIT
	MCOML	R7,R11		;AND TO TEST
	BICL2	R11,R8
	BEQLU	GNV19
	MOVL	R10,4*VRLBL(R9)	;ELSE POINT VRLBL TO SVLBL FIELD
	ADDL2	#4,R10		;BUMP PAST SVLBL FIELD
;
;      NOW TEST FOR VALUE (SVVAL)
;
GNV19::	MOVL	BTVAL,R8	;LOAD TEST BIT
	MCOML	R7,R11		;AND TO TEST
	BICL2	R11,R8
	BNEQU	5204$
	JMP	GNV06
5204$:
	MOVL	(R10),4*VRVAL(R9);ELSE SET INITIAL VALUE
	MOVL	#B$VRE,4*VRSTO(R9) ;SET ERROR STORE ACCESS
	JMP	GNV06		;MERGE BACK TO EXIT TO CALLER
	;ENP			;END PROCEDURE GTNVR
	.PAGE
;
;      GTPAT -- GET PATTERN
;
;      GTPAT IS PASSED AN OBJECT IN (XR) AND RETURNS A
;      PATTERN AFTER PERFORMING ANY NECESSARY CONVERSIONS
;
;      (XR)                  INPUT ARGUMENT
;      JSR  GTPAT            CALL TO CONVERT TO PATTERN
;      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
;      (XR)                  RESULTING PATTERN
;      (WA)                  DESTROYED
;      (WB)                  DESTROYED (ONLY ON CONVERT ERROR)
;      (XR)                  UNCHANGED (ONLY ON CONVERT ERROR)
;
	.ENABLE	LOCAL_BLOCK
GTPAT::	;PRC			;ENTRY POINT
	CMPL	(R9),#P$AAA	;JUMP IF PATTERN ALREADY
	BGEQU	GTPT5
;
;      HERE IF NOT PATTERN, TRY FOR STRING
;
	MOVL	R7,GTPSB	;SAVE WB
	MOVL	R9,-(SP)	;STACK ARGUMENT FOR GTSTG
	JSB	GTSTG		;CONVERT ARGUMENT TO STRING
	.ADDRESS GTPT2		;JUMP IF IMPOSSIBLE
;
;      HERE WE HAVE A STRING
;
	TSTL	R6		;JUMP IF NON-NULL
	BNEQU	GTPT1
;
;      HERE FOR NULL STRING. GENERATE POINTER TO NULL PATTERN.
;
	MOVL	#NDNTH,R9	;POINT TO NOTHEN NODE
	JMP	GTPT4		;JUMP TO EXIT
	.PAGE
;
;      GTPAT (CONTINUED)
;
;      HERE FOR NON-NULL STRING
;
GTPT1::	MOVL	#P$STR,R7	;LOAD PCODE FOR MULTI-CHAR STRING
	CMPL	R6,#NUM01	;JUMP IF MULTI-CHAR STRING
	BNEQU	GTPT3
;
;      HERE FOR ONE CHARACTER STRING, SHARE ONE CHARACTER ANY
;
	MOVAB	CFP$F(R9),R9	;POINT TO CHARACTER
	MOVZBL	(R9),R6		;LOAD CHARACTER
	MOVL	R6,R9		;SET AS PARM1
	MOVL	#P$ANS,R7	;POINT TO PCODE FOR 1-CHAR ANY
	JMP	GTPT3		;JUMP TO BUILD NODE
;
;      HERE IF ARGUMENT IS NOT CONVERTIBLE TO STRING
;
GTPT2::	MOVL	#P$EXA,R7	;SET PCODE FOR EXPRESSION IN CASE
	CMPL	(R9),#B$E$$	;JUMP TO BUILD NODE IF EXPRESSION
	BLEQU	GTPT3
;
;      HERE WE HAVE AN ERROR (CONVERSION IMPOSSIBLE)
;
	MOVL	(SP)+,R11	;TAKE CONVERT ERROR EXIT
	JMP	@(R11)+
;
;      MERGE HERE TO BUILD NODE FOR STRING OR EXPRESSION
;
GTPT3::	JSB	PBILD		;CALL ROUTINE TO BUILD PATTERN NODE
;
;      COMMON EXIT AFTER SUCCESSFUL CONVERSION
;
GTPT4::	MOVL	GTPSB,R7	;RESTORE WB
;
;      MERGE HERE TO EXIT OF NO CONVERSION REQUIRED
;
GTPT5::	ADDL2	#4*1,(SP)	;RETURN TO GTPAT CALLER
	RSB
	;ENP			;END PROCEDURE GTPAT
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	.PAGE
;
;      GTREA -- GET REAL VALUE
;
;      GTREA IS PASSED AN OBJECT AND RETURNS A REAL VALUE
;      PERFORMING ANY NECESSARY CONVERSIONS.
;
;      (XR)                  OBJECT TO BE CONVERTED
;      JSR  GTREA            CALL TO CONVERT OBJECT TO REAL
;      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
;      (XR)                  POINTER TO RESULTING REAL
;      (WA,WB,WC,RA)         DESTROYED
;      (XR)                  UNCHANGED (CONVERT ERROR ONLY)
;
	.ENABLE	LOCAL_BLOCK
GTREA::	;PRC			;ENTRY POINT
	MOVL	(R9),R6		;GET FIRST WORD OF BLOCK
	CMPL	R6,#B$RCL	;JUMP IF REAL
	BEQLU	GTRE2
	JSB	GTNUM		;ELSE CONVERT ARGUMENT TO NUMERIC
	.ADDRESS GTRE3		;JUMP IF UNCONVERTIBLE
	CMPL	R6,#B$RCL	;JUMP IF REAL WAS RETURNED
	BEQLU	GTRE2
;
;      HERE FOR CASE OF AN INTEGER TO CONVERT TO REAL
;
GTRE1::	MOVL	4*ICVAL(R9),R5	;LOAD INTEGER
	CVTLF	R5,R2		;CONVERT TO REAL
	JSB	RCBLD		;BUILD RCBLK
;
;      EXIT WITH REAL
;
GTRE2::	ADDL2	#4*1,(SP)	;RETURN TO GTREA CALLER
	RSB
;
;      HERE ON CONVERSION ERROR
;
GTRE3::	MOVL	(SP)+,R11	;TAKE CONVERT ERROR EXIT
	JMP	@(R11)+
	;ENP			;END PROCEDURE GTREA
	.ENDC
	.PAGE
;
;      GTSMI -- GET SMALL INTEGER
;
;      GTSMI IS PASSED A SNOBOL OBJECT AND RETURNS AN ADDRESS
;      INTEGER IN THE RANGE (0 LE N LE DNAMB). SUCH A VALUE CAN
;      ONLY BE DERIVED FROM AN INTEGER IN THE APPROPRIATE RANGE.
;      SMALL INTEGERS NEVER APPEAR AS SNOBOL VALUES. HOWEVER,
;      THEY ARE USED INTERNALLY FOR A VARIETY OF PURPOSES.
;
;      -(XS)                 ARGUMENT TO CONVERT (ON STACK)
;      JSR  GTSMI            CALL TO CONVERT TO SMALL INTEGER
;      PPM  LOC              TRANSFER LOC FOR NOT INTEGER
;      PPM  LOC              TRANSFER LOC FOR LT 0, GT DNAMB
;      (XR,WC)               RESULTING SMALL INT (TWO COPIES)
;      (XS)                  POPPED
;      (RA)                  DESTROYED
;      (WA,WB)               DESTROYED (ON CONVERT ERROR ONLY)
;      (XR)                  INPUT ARG (CONVERT ERROR ONLY)
;
	.ENABLE	LOCAL_BLOCK
GTSMI::	MOVL	(SP)+,GTSMI_SAVE;ENTRY POINT
	.SAVE_PSECT LOCAL_BLOCK
	.PSECT	PRC_SAVE,NOEXE
GTSMI_SAVE::.LONG	0
	.RESTORE_PSECT
	MOVL	(SP)+,R9	;LOAD ARGUMENT
	CMPL	(R9),#B$ICL	;SKIP IF ALREADY AN INTEGER
	BEQLU	GTSM1
;
;      HERE IF NOT AN INTEGER
;
	JSB	GTINT		;CONVERT ARGUMENT TO INTEGER
	.ADDRESS GTSM2		;JUMP IF CONVERT IS IMPOSSIBLE
;
;      MERGE HERE WITH INTEGER
;
GTSM1::	MOVL	4*ICVAL(R9),R5	;LOAD INTEGER VALUE
	MFI	R8,GTSM3	;MOVE AS ONE WORD, JUMP IF OVFLOW
	CMPL	R8,MXLEN	;OR IF TOO SMALL
	BGTRU	GTSM3
	MOVL	R8,R9		;COPY RESULT TO XR
	ADDL3	#4*2,GTSMI_SAVE,R11 ;RETURN TO GTSMI CALLER
	JMP	(R11)
;
;      HERE IF UNCONVERTIBLE TO INTEGER
;
GTSM2::	MOVL	GTSMI_SAVE,R11	;TAKE NON-INTEGER ERROR EXIT
	JMP	@(R11)+
;
;      HERE IF OUT OF RANGE
;
GTSM3::	ADDL3	#4*1,GTSMI_SAVE,R11 ;TAKE OUT-OF-RANGE ERROR EXIT
	JMP	@(R11)+
	;ENP			;END PROCEDURE GTSMI
	.PAGE
;
;      GTSTG -- GET STRING
;
;      GTSTG IS PASSED AN OBJECT AND RETURNS A STRING WITH
;      ANY NECESSARY CONVERSIONS PERFORMED.
;
;      -(XS)                 INPUT ARGUMENT (ON STACK)
;      JSR  GTSTG            CALL TO CONVERT TO STRING
;      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
;      (XR)                  POINTER TO RESULTING STRING
;      (WA)                  LENGTH OF STRING IN CHARACTERS
;      (XS)                  POPPED
;      (RA)                  DESTROYED
;      (XR)                  INPUT ARG (CONVERT ERROR ONLY)
;
	.ENABLE	LOCAL_BLOCK
GTSTG::	MOVL	(SP)+,GTSTG_SAVE;ENTRY POINT
	.SAVE_PSECT LOCAL_BLOCK
	.PSECT	PRC_SAVE,NOEXE
GTSTG_SAVE::.LONG	0
	.RESTORE_PSECT
	MOVL	(SP)+,R9	;LOAD ARGUMENT, POP STACK
	CMPL	(R9),#B$SCL	;JUMP IF ALREADY A STRING
	BNEQU	5205$
	JMP	GTS30
5205$:
;
;      HERE IF NOT A STRING ALREADY
;
GTS01::	MOVL	R9,-(SP)	;RESTACK ARGUMENT IN CASE ERROR
	MOVL	R10,-(SP)	;SAVE XL
	MOVL	R7,GTSVB	;SAVE WB
	MOVL	R8,GTSVC	;SAVE WC
	MOVL	(R9),R6		;LOAD FIRST WORD OF BLOCK
	CMPL	R6,#B$ICL	;JUMP TO CONVERT INTEGER
	BEQLU	GTS05
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	CMPL	R6,#B$RCL	;JUMP TO CONVERT REAL
	BNEQU	5206$
	JMP	GTS10
5206$:
	.ENDC
	CMPL	R6,#B$NML	;JUMP TO CONVERT NAME
	BEQLU	GTS03
;
;      HERE ON CONVERSION ERROR
;
GTS02::	MOVL	(SP)+,R10	;RESTORE XL
	MOVL	(SP)+,R9	;RELOAD INPUT ARGUMENT
	MOVL	GTSTG_SAVE,R11	;TAKE CONVERT ERROR EXIT
	JMP	@(R11)+
	.PAGE
;
;      GTSTG (CONTINUED)
;
;      HERE TO CONVERT A NAME (ONLY POSSIBLE IF NATURAL VAR)
;
GTS03::	MOVL	4*NMBAS(R9),R10	;LOAD NAME BASE
	CMPL	R10,STATE	;ERROR IF NOT NATURAL VAR (STATIC)
	BGEQU	GTS02
	ADDL2	#4*VRSOF,R10	;ELSE POINT TO POSSIBLE STRING NAME
	MOVL	4*SCLEN(R10),R6	;LOAD LENGTH
	TSTL	R6		;JUMP IF NOT SYSTEM VARIABLE
	BNEQU	GTS04
	MOVL	4*VRSVO(R10),R10;ELSE POINT TO SVBLK
	MOVL	4*SVLEN(R10),R6	;AND LOAD NAME LENGTH
;
;      MERGE HERE WITH STRING IN XR, LENGTH IN WA
;
GTS04::	CLRL	R7		;SET OFFSET TO ZERO
	JSB	SBSTR		;USE SBSTR TO COPY STRING
	JMP	GTS29		;JUMP TO EXIT
;
;      COME HERE TO CONVERT AN INTEGER
;
GTS05::	MOVL	4*ICVAL(R9),R5	;LOAD INTEGER VALUE
	.IF NOT_EQUAL CNCI
	JSB	SYSCI		;CONVERT INTEGER
	MOVL	4*SCLEN(R10),R6	;GET LENGTH
	CLRL	R7		;ZERO OFFSET FOR SBSTR
	JSB	SBSTR		;COPY IN RESULT FROM SYSCI
	JMP	GTS29		;EXIT
	.IF_FALSE
	MOVL	#NUM01,GTSSF	;SET SIGN FLAG NEGATIVE
	TSTL	R5		;SKIP IF INTEGER IS NEGATIVE
	BLSS	GTS06
	MNEGL	R5,R5		;ELSE NEGATE INTEGER
	CLRL	GTSSF		;AND RESET NEGATIVE FLAG
	.PAGE
;
;      GTSTG (CONTINUED)
;
;      HERE WITH SIGN FLAG SET AND SIGN FORCED NEGATIVE AS
;      REQUIRED BY THE CVD INSTRUCTION.
;
GTS06::	MOVL	GTSWK,R9	;POINT TO RESULT WORK AREA
	MOVL	#NSTMX,R7	;INITIALIZE COUNTER TO MAX LENGTH
	MOVAB	CFP$F(R9)[R7],R9;PREPARE TO STORE (RIGHT-LEFT)
;
;      LOOP TO CONVERT DIGITS INTO WORK AREA
;
GTS07::	CVD			;CONVERT ONE DIGIT INTO WA
	MOVB	R6,-(R9)	;STORE IN WORK AREA
	DECL	R7		;DECREMENT COUNTER
	TSTL	R5		;LOOP IF MORE DIGITS TO GO
	BNEQ	GTS07
	;CSC	R9		;COMPLETE STORE CHARACTERS
	.ENDC
;
;      MERGE HERE AFTER CONVERTING INTEGER OR REAL INTO WORK
;      AREA. WB IS SET TO NSTMX - (NUMBER OF CHARS IN RESULT).
;
GTS08::	MOVL	#NSTMX,R6	;GET MAX NUMBER OF CHARACTERS
	SUBL2	R7,R6		;COMPUTE LENGTH OF RESULT
	MOVL	R6,R10		;REMEMBER LENGTH FOR MOVE LATER ON
	ADDL2	GTSSF,R6	;ADD ONE FOR NEGATIVE SIGN IF NEEDED
	JSB	ALOCS		;ALLOCATE STRING FOR RESULT
	MOVL	R9,R8		;SAVE RESULT POINTER FOR THE MOMENT
	MOVAB	CFP$F(R9),R9	;POINT TO CHARS OF RESULT BLOCK
	TSTL	GTSSF		;SKIP IF POSITIVE
	BEQLU	GTS09
	MOVL	#CH$MN,R6	;ELSE LOAD NEGATIVE SIGN
	MOVB	R6,(R9)+	;AND STORE IT
	;CSC	R9		;COMPLETE STORE CHARACTERS
;
;      HERE AFTER DEALING WITH SIGN
;
GTS09::	MOVL	R10,R6		;RECALL LENGTH TO MOVE
	MOVL	GTSWK,R10	;POINT TO RESULT WORK AREA
	MOVAB	CFP$F(R10)[R7],R10 ;POINT TO FIRST RESULT CHARACTER
	MVC			;MOVE CHARS TO RESULT STRING
	MOVL	R8,R9		;RESTORE RESULT POINTER
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	JMP	GTS29		;JUMP TO EXIT
	.PAGE
;
;      GTSTG (CONTINUED)
;
;      HERE TO CONVERT A REAL
;
GTS10::	MOVF	4*RCVAL(R9),R2	;LOAD REAL
	CLRL	GTSSF		;RESET NEGATIVE FLAG
	TSTF	R2		;SKIP IF ZERO
	BNEQ	5207$
	JMP	GTS31
5207$:
	TSTF	R2		;JUMP IF REAL IS POSITIVE
	BGEQ	GTS11
	MOVL	#NUM01,GTSSF	;ELSE SET NEGATIVE FLAG
	MNEGF	R2,R2		;AND GET ABSOLUTE VALUE OF REAL
;
;      NOW SCALE THE REAL TO THE RANGE (0.1 LE X LT 1.0)
;
GTS11::	MOVL	INTV0,R5	;INITIALIZE EXPONENT TO ZERO
;
;      LOOP TO SCALE UP IN STEPS OF 10**10
;
GTS12::	MOVF	R2,GTSRS	;SAVE REAL VALUE
	SUBF2	REAP1,R2	;SUBTRACT 0.1 TO COMPARE
	TSTF	R2		;JUMP IF SCALE UP NOT REQUIRED
	BGEQ	GTS13
	MOVF	GTSRS,R2	;ELSE RELOAD VALUE
	MULF2	REATT,R2	;MULTIPLY BY 10**10
	SUBL2	INTVT,R5	;DECREMENT EXPONENT BY 10
	JMP	GTS12		;LOOP BACK TO TEST AGAIN
;
;      TEST FOR SCALE DOWN REQUIRED
;
GTS13::	MOVF	GTSRS,R2	;RELOAD VALUE
	SUBF2	REAV1,R2	;SUBTRACT 1.0
	TSTF	R2		;JUMP IF NO SCALE DOWN REQUIRED
	BLSS	GTS17
	MOVF	GTSRS,R2	;ELSE RELOAD VALUE
;
;      LOOP TO SCALE DOWN IN STEPS OF 10**10
;
GTS14::	SUBF2	REATT,R2	;SUBTRACT 10**10 TO COMPARE
	TSTF	R2		;JUMP IF LARGE STEP NOT REQUIRED
	BLSS	GTS15
	MOVF	GTSRS,R2	;ELSE RESTORE VALUE
	DIVF2	REATT,R2	;DIVIDE BY 10**10
	MOVF	R2,GTSRS	;STORE NEW VALUE
	ADDL2	INTVT,R5	;INCREMENT EXPONENT BY 10
	JMP	GTS14		;LOOP BACK
	.PAGE
;
;      GTSTG (CONTINUED)
;
;      AT THIS POINT WE HAVE (1.0 LE X LT 10**10)
;      COMPLETE SCALING WITH POWERS OF TEN TABLE
;
GTS15::	MOVL	#REAV1,R9	;POINT TO POWERS OF TEN TABLE
;
;      LOOP TO LOCATE CORRECT ENTRY IN TABLE
;
GTS16::	MOVF	GTSRS,R2	;RELOAD VALUE
	ADDL2	INTV1,R5	;INCREMENT EXPONENT
	ADDL2	#4*CFP$R,R9	;POINT TO NEXT ENTRY IN TABLE
	SUBF2	(R9),R2		;SUBTRACT IT TO COMPARE
	TSTF	R2		;LOOP TILL WE FIND A LARGER ENTRY
	BGEQ	GTS16
	MOVF	GTSRS,R2	;THEN RELOAD THE VALUE
	DIVF2	(R9),R2		;AND COMPLETE SCALING
	MOVF	R2,GTSRS	;STORE VALUE
;
;      WE ARE NOW SCALED, SO ROUND BY ADDING 0.5 * 10**(-CFP$S)
;
GTS17::	MOVF	GTSRS,R2	;GET VALUE AGAIN
	ADDF2	GTSRN,R2	;ADD ROUNDING FACTOR
	MOVF	R2,GTSRS	;STORE RESULT
;
;      THE ROUNDING OPERATION MAY HAVE PUSHED US UP PAST
;      1.0 AGAIN, SO CHECK ONE MORE TIME.
;
	SUBF2	REAV1,R2	;SUBTRACT 1.0 TO COMPARE
	TSTF	R2		;SKIP IF OK
	BLSS	GTS18
	ADDL2	INTV1,R5	;ELSE INCREMENT EXPONENT
	MOVF	GTSRS,R2	;RELOAD VALUE
	DIVF2	REAVT,R2	;DIVIDE BY 10.0 TO RESCALE
	JMP	GTS19		;JUMP TO MERGE
;
;      HERE IF ROUNDING DID NOT MUCK UP SCALING
;
GTS18::	MOVF	GTSRS,R2	;RELOAD ROUNDED VALUE
	.PAGE
;
;      GTSTG (CONTINUED)
;
;      NOW WE HAVE COMPLETED THE SCALING AS FOLLOWS
;
;      (IA)                  SIGNED EXPONENT
;      (RA)                  SCALED REAL (ABSOLUTE VALUE)
;
;      IF THE EXPONENT IS NEGATIVE OR GREATER THAN CFP$S, THEN
;      WE CONVERT THE NUMBER IN THE FORM.
;
;      (NEG SIGN) 0 . (CPF$S DIGITS) E (EXP SIGN) (EXP DIGITS)
;
;      IF THE EXPONENT IS POSITIVE AND LESS THAN OR EQUAL TO
;      CFP$S, THE NUMBER IS CONVERTED IN THE FORM.
;
;      (NEG SIGN) (EXPONENT DIGITS) . (CFP$S-EXPONENT DIGITS)
;
;      IN BOTH CASES, THE FORMATS OBTAINED FROM THE ABOVE
;      RULES ARE MODIFIED BY DELETING TRAILING ZEROS AFTER THE
;      DECIMAL POINT. THERE ARE NO LEADING ZEROS IN THE EXPONENT
;      AND THE EXPONENT SIGN IS ALWAYS PRESENT.
;
GTS19::	MOVL	#CFP$S,R10	;SET NUM DEC DIGITS = CFP$S
	MOVL	#CH$MN,GTSES	;SET EXPONENT SIGN NEGATIVE
	TSTL	R5		;ALL SET IF EXPONENT IS NEGATIVE
	BLSS	GTS21
	MFI	R6		;ELSE FETCH EXPONENT
	CMPL	R6,#CFP$S	;SKIP IF WE CAN USE SPECIAL FORMAT
	BLEQU	GTS20
	MOVL	R6,R5		;ELSE RESTORE EXPONENT
	MNEGL	R5,R5		;SET NEGATIVE FOR CVD
	MOVL	#CH$PL,GTSES	;SET PLUS SIGN FOR EXPONENT SIGN
	JMP	GTS21		;JUMP TO GENERATE EXPONENT
;
;      HERE IF WE CAN USE THE FORMAT WITHOUT AN EXPONENT
;
GTS20::	SUBL2	R6,R10		;COMPUTE DIGITS AFTER DECIMAL POINT
	MOVL	INTV0,R5	;RESET EXPONENT TO ZERO
	.PAGE
;
;      GTSTG (CONTINUED)
;
;      MERGE HERE AS FOLLOWS
;
;      (IA)                  EXPONENT ABSOLUTE VALUE
;      GTSES                 CHARACTER FOR EXPONENT SIGN
;      (RA)                  POSITIVE FRACTION
;      (XL)                  NUMBER OF DIGITS AFTER DEC POINT
;
GTS21::	MOVL	GTSWK,R9	;POINT TO WORK AREA
	MOVL	#NSTMX,R7	;SET CHARACTER CTR TO MAX LENGTH
	MOVAB	CFP$F(R9)[R7],R9;PREPARE TO STORE (RIGHT TO LEFT)
	TSTL	R5		;SKIP EXPONENT IF IT IS ZERO
	BEQL	GTS23
;
;      LOOP TO GENERATE DIGITS OF EXPONENT
;
GTS22::	CVD			;CONVERT A DIGIT INTO WA
	MOVB	R6,-(R9)	;STORE IN WORK AREA
	DECL	R7		;DECREMENT COUNTER
	TSTL	R5		;LOOP BACK IF MORE DIGITS TO GO
	BNEQ	GTS22
;
;      HERE GENERATE EXPONENT SIGN AND E
;
	MOVL	GTSES,R6	;LOAD EXPONENT SIGN
	MOVB	R6,-(R9)	;STORE IN WORK AREA
	MOVL	#CH$LE,R6	;GET CHARACTER LETTER E
	MOVB	R6,-(R9)	;STORE IN WORK AREA
	SUBL2	#NUM02,R7	;DECREMENT COUNTER FOR SIGN AND E
;
;      HERE TO GENERATE THE FRACTION
;
GTS23::	MULF2	GTSSC,R2	;CONVERT REAL TO INTEGER (10**CFP$S)
	CVTFL	R2,R5		;GET INTEGER (OVERFLOW IMPOSSIBLE)
	MNEGL	R5,R5		;NEGATE AS REQUIRED BY CVD
;
;      LOOP TO SUPPRESS TRAILING ZEROS
;
GTS24::	TSTL	R10		;JUMP IF NO DIGITS LEFT TO DO
	BEQLU	GTS27
	CVD			;ELSE CONVERT ONE DIGIT
	CMPL	R6,#CH$D0	;JUMP IF NOT A ZERO
	BNEQU	GTS26
	DECL	R10		;DECREMENT COUNTER
	JMP	GTS24		;LOOP BACK FOR NEXT DIGIT
	.PAGE
;
;      GTSTG (CONTINUED)
;
;      LOOP TO GENERATE DIGITS AFTER DECIMAL POINT
;
GTS25::	CVD			;CONVERT A DIGIT INTO WA
;
;      MERGE HERE FIRST TIME
;
GTS26::	MOVB	R6,-(R9)	;STORE DIGIT
	DECL	R7		;DECREMENT COUNTER
	DECL	R10		;DECREMENT COUNTER
	TSTL	R10		;LOOP BACK IF MORE TO GO
	BNEQU	GTS25
;
;      HERE GENERATE THE DECIMAL POINT
;
GTS27::	MOVL	#CH$DT,R6	;LOAD DECIMAL POINT
	MOVB	R6,-(R9)	;STORE IN WORK AREA
	DECL	R7		;DECREMENT COUNTER
;
;      HERE GENERATE THE DIGITS BEFORE THE DECIMAL POINT
;
GTS28::	CVD			;CONVERT A DIGIT INTO WA
	MOVB	R6,-(R9)	;STORE IN WORK AREA
	DECL	R7		;DECREMENT COUNTER
	TSTL	R5		;LOOP BACK IF MORE TO GO
	BNEQ	GTS28
	;CSC	R9		;COMPLETE STORE CHARACTERS
	JMP	GTS08		;ELSE JUMP BACK TO EXIT
	.ENDC
;
;      EXIT POINT AFTER SUCCESSFUL CONVERSION
;
GTS29::	MOVL	(SP)+,R10	;RESTORE XL
	ADDL2	#4,SP		;POP ARGUMENT
	MOVL	GTSVB,R7	;RESTORE WB
	MOVL	GTSVC,R8	;RESTORE WC
;
;      MERGE HERE IF NO CONVERSION REQUIRED
;
GTS30::	MOVL	4*SCLEN(R9),R6	;LOAD STRING LENGTH
	ADDL3	#4*1,GTSTG_SAVE,R11 ;RETURN TO CALLER
	JMP	(R11)
	.IF NOT_EQUAL CNRA
	.IF_FALSE
;
;      HERE TO RETURN STRING FOR REAL ZERO
;
GTS31::	MOVL	#SCRE0,R10	;POINT TO STRING
	MOVL	#NUM02,R6	;2 CHARS
	CLRL	R7		;ZERO OFFSET
	JSB	SBSTR		;COPY STRING
	JMP	GTS29		;RETURN
	.ENDC
	;ENP			;END PROCEDURE GTSTG
	.PAGE
;
;      GTVAR -- GET VARIABLE FOR I/O/TRACE ASSOCIATION
;
;      GTVAR IS USED TO POINT TO AN ACTUAL VARIABLE LOCATION
;      FOR THE DETACH,INPUT,OUTPUT,TRACE,STOPTR SYSTEM FUNCTIONS
;
;      (XR)                  ARGUMENT TO FUNCTION
;      JSR  GTVAR            CALL TO LOCATE VARIABLE POINTER
;      PPM  LOC              TRANSFER LOC IF NOT OK VARIABLE
;      (XL,WA)               NAME BASE,OFFSET OF VARIABLE
;      (XR,RA)               DESTROYED
;      (WB,WC)               DESTROYED (CONVERT ERROR ONLY)
;      (XR)                  INPUT ARG (CONVERT ERROR ONLY)
;
	.ENABLE	LOCAL_BLOCK
GTVAR::	;PRC			;ENTRY POINT
	CMPL	(R9),#B$NML	;JUMP IF NOT A NAME
	BNEQU	GTVR2
	MOVL	4*NMOFS(R9),R6	;ELSE LOAD NAME OFFSET
	MOVL	4*NMBAS(R9),R10	;LOAD NAME BASE
	CMPL	(R10),#B$EVT	;ERROR IF EXPRESSION VARIABLE
	BEQLU	GTVR1
	CMPL	(R10),#B$KVT	;ALL OK IF NOT KEYWORD VARIABLE
	BNEQU	GTVR3
;
;      HERE ON CONVERSION ERROR
;
GTVR1::	MOVL	(SP)+,R11	;TAKE CONVERT ERROR EXIT
	JMP	@(R11)+
;
;      HERE IF NOT A NAME, TRY CONVERT TO NATURAL VARIABLE
;
GTVR2::	MOVL	R8,GTVRC	;SAVE WC
	JSB	GTNVR		;LOCATE VRBLK IF POSSIBLE
	.ADDRESS GTVR1		;JUMP IF CONVERT ERROR
	MOVL	R9,R10		;ELSE COPY VRBLK NAME BASE
	MOVL	#4*VRVAL,R6	;AND SET OFFSET
	MOVL	GTVRC,R8	;RESTORE WC
;
;      HERE FOR NAME OBTAINED
;
GTVR3::	CMPL	R10,STATE	;ALL OK IF NOT NATURAL VARIABLE
	BGEQU	GTVR4
	CMPL	4*VRSTO(R10),#B$VRE ;ERROR IF PROTECTED VARIABLE
	BEQLU	GTVR1
;
;      COMMON EXIT POINT
;
GTVR4::	ADDL2	#4*1,(SP)	;RETURN TO CALLER
	RSB
	;ENP			;END PROCEDURE GTVAR
	.PAGE
;
;      HASHS -- COMPUTE HASH INDEX FOR STRING
;
;      HASHS IS USED TO CONVERT A STRING TO A UNIQUE INTEGER
;      VALUE. THE RESULTING HASH VALUE IS A POSITIVE INTEGER
;      IN THE RANGE 0 TO CFP$M
;
;      (XR)                  STRING TO BE HASHED
;      JSR  HASHS            CALL TO HASH STRING
;      (IA)                  HASH VALUE
;      (XR,WB,WC)            DESTROYED
;
;      THE HASH FUNCTION USED IS AS FOLLOWS.
;
;      START WITH THE LENGTH OF THE STRING [SGD07]
;
;      TAKE THE FIRST E$HNW WORDS OF THE CHARACTERS FROM
;      THE STRING OR ALL THE WORDS IF FEWER THAN E$HNW.
;
;      COMPUTE THE EXCLUSIVE OR OF ALL THESE WORDS TREATING
;      THEM AS ONE WORD BIT STRING VALUES.
;
;      MOVE THE RESULT AS AN INTEGER WITH THE MTI INSTRUCTION.
;
	.ENABLE	LOCAL_BLOCK
HASHS::	;PRC			;ENTRY POINT
	MOVL	4*SCLEN(R9),R8	;LOAD STRING LENGTH IN CHARACTERS
	MOVL	R8,R7		;INITIALIZE WITH LENGTH
	TSTL	R8		;JUMP IF NULL STRING
	BEQLU	HSHS3
	MOVAB	3+<4*0>(R8),R8	;ELSE GET NUMBER OF WORDS OF CHARS
	ASHL	#-2,R8,R8
	ADDL2	#4*SCHAR,R9	;POINT TO CHARACTERS OF STRING
	CMPL	R8,#E$HNW	;USE WHOLE STRING IF SHORT
	BLEQU	HSHS1
	MOVL	#E$HNW,R8	;ELSE SET TO INVOLVE FIRST E$HNW WDS
;
;      HERE WITH COUNT OF WORDS TO CHECK IN WC
;
HSHS1::				;SET COUNTER TO CONTROL LOOP
;
;      LOOP TO COMPUTE EXCLUSIVE OR
;
HSHS2::	XORL2	(R9)+,R7	;EXCLUSIVE OR NEXT WORD OF CHARS
	SOBGTR	R8,HSHS2	;LOOP TILL ALL PROCESSED
;
;      MERGE HERE WITH EXCLUSIVE OR IN WB
;
HSHS3::	;ZGB	R7		;ZEROISE UNDEFINED BITS
	MCOML	BITSM,R11	;ENSURE IN RANGE 0 TO CFP$M
	BICL2	R11,R7
	MOVL	R7,R5		;MOVE RESULT AS INTEGER
	CLRL	R9		;CLEAR GARBAGE VALUE IN XR
	RSB			;RETURN TO HASHS CALLER
	;ENP			;END PROCEDURE HASHS
	.PAGE
;
;      ICBLD -- BUILD INTEGER BLOCK
;
;      (IA)                  INTEGER VALUE FOR ICBLK
;      JSR  ICBLD            CALL TO BUILD INTEGER BLOCK
;      (XR)                  POINTER TO RESULT ICBLK
;      (WA)                  DESTROYED
;
	.ENABLE	LOCAL_BLOCK
ICBLD::	;PRC			;ENTRY POINT
	MFI	R9,ICBL1	;COPY SMALL INTEGERS
	CMPL	R9,#NUM02	;JUMP IF 0,1 OR 2
	BLEQU	ICBL3
;
;      CONSTRUCT ICBLK
;
ICBL1::	MOVL	DNAMP,R9	;LOAD POINTER TO NEXT AVAILABLE LOC
	ADDL2	#4*ICSI$,R9	;POINT PAST NEW ICBLK
	CMPL	R9,DNAME	;JUMP IF THERE IS ROOM
	BLEQU	ICBL2
	MOVL	#4*ICSI$,R6	;ELSE LOAD LENGTH OF ICBLK
	JSB	ALLOC		;USE STANDARD ALLOCATOR TO GET BLOCK
	ADDL2	R6,R9		;POINT PAST BLOCK TO MERGE
;
;      MERGE HERE WITH XR POINTING PAST THE BLOCK OBTAINED
;
ICBL2::	MOVL	R9,DNAMP	;SET NEW POINTER
	SUBL2	#4*ICSI$,R9	;POINT BACK TO START OF BLOCK
	MOVL	#B$ICL,(R9)	;STORE TYPE WORD
	MOVL	R5,4*ICVAL(R9)	;STORE INTEGER VALUE IN ICBLK
	RSB			;RETURN TO ICBLD CALLER
;
;      OPTIMISE BY NOT BUILDING ICBLKS FOR SMALL INTEGERS
;
ICBL3::	MOVAL	0[R9],R9	;CONVERT INTEGER TO OFFSET
	MOVL	L^INTAB(R9),R9	;POINT TO PRE-BUILT ICBLK
	RSB			;RETURN
	;ENP			;END PROCEDURE ICBLD
	.PAGE
;
;      IDENT -- COMPARE TWO VALUES
;
;      IDENT COMPARES TWO VALUES IN THE SENSE OF THE IDENT
;      DIFFER FUNCTIONS AVAILABLE AT THE SNOBOL LEVEL.
;
;      (XR)                  FIRST ARGUMENT
;      (XL)                  SECOND ARGUMENT
;      JSR  IDENT            CALL TO COMPARE ARGUMENTS
;      PPM  LOC              TRANSFER LOC IF IDENT
;      (NORMAL RETURN IF DIFFER)
;      (XR,XL,WC,RA)         DESTROYED
;
	.ENABLE	LOCAL_BLOCK
IDENT::	;PRC			;ENTRY POINT
	CMPL	R9,R10		;JUMP IF SAME POINTER (IDENT)
	BNEQU	5208$
	JMP	IDEN7
5208$:
	MOVL	(R9),R8		;ELSE LOAD ARG 1 TYPE WORD
	CMPL	R8,(R10)	;DIFFER IF ARG 2 TYPE WORD DIFFER
	BNEQU	IDEN1
	CMPL	R8,#B$SCL	;JUMP IF STRINGS
	BEQLU	IDEN2
	CMPL	R8,#B$ICL	;JUMP IF INTEGERS
	BEQLU	IDEN4
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	CMPL	R8,#B$RCL	;JUMP IF REALS
	BEQLU	IDEN5
	.ENDC
	CMPL	R8,#B$NML	;JUMP IF NAMES
	BEQLU	IDEN6
;
;      FOR ALL OTHER DATATYPES, MUST BE DIFFER IF XR NE XL
;
;      MERGE HERE FOR DIFFER
;
IDEN1::	ADDL2	#4*1,(SP)	;TAKE DIFFER EXIT
	RSB
;
;      HERE FOR STRINGS, IDENT ONLY IF LENGTHS AND CHARS SAME
;
IDEN2::	MOVL	4*SCLEN(R9),R8	;LOAD ARG 1 LENGTH
	CMPL	R8,4*SCLEN(R10)	;DIFFER IF LENGTHS DIFFER
	BNEQU	IDEN1
	MOVAB	3+<4*0>(R8),R8	;GET NUMBER OF WORDS IN STRINGS
	ASHL	#-2,R8,R8
	ADDL2	#4*SCHAR,R9	;POINT TO CHARS OF ARG 1
	ADDL2	#4*SCHAR,R10	;POINT TO CHARS OF ARG 2
				;SET LOOP COUNTER
;
;      LOOP TO COMPARE CHARACTERS. NOTE THAT WA CANNOT BE ZERO
;      SINCE ALL NULL STRINGS POINT TO NULLS AND GIVE XL=XR.
;
IDEN3::	CMPL	(R9),(R10)	;DIFFER IF CHARS DO NOT MATCH
	BNEQU	IDEN8
	ADDL2	#4,R9		;ELSE BUMP ARG ONE POINTER
	ADDL2	#4,R10		;BUMP ARG TWO POINTER
	SOBGTR	R8,IDEN3	;LOOP BACK TILL ALL CHECKED
	.PAGE
;
;      IDENT (CONTINUED)
;
;      HERE TO EXIT FOR CASE OF TWO IDENT STRINGS
;
	CLRL	R10		;CLEAR GARBAGE VALUE IN XL
	CLRL	R9		;CLEAR GARBAGE VALUE IN XR
	MOVL	(SP)+,R11	;TAKE IDENT EXIT
	JMP	@(R11)+
;
;      HERE FOR INTEGERS, IDENT IF SAME VALUES
;
IDEN4::	MOVL	4*ICVAL(R9),R5	;LOAD ARG 1
	SUBL2	4*ICVAL(R10),R5	;SUBTRACT ARG 2 TO COMPARE
	BVS	IDEN1
	TSTL	R5		;DIFFER IF RESULT IS NOT ZERO
	BNEQ	IDEN1
	MOVL	(SP)+,R11	;TAKE IDENT EXIT
	JMP	@(R11)+
	.IF NOT_EQUAL CNRA
	.IF_FALSE
;
;      HERE FOR REALS, IDENT IF SAME VALUES
;
IDEN5::	MOVF	4*RCVAL(R9),R2	;LOAD ARG 1
	SUBF2	4*RCVAL(R10),R2	;SUBTRACT ARG 2 TO COMPARE
	BVS	IDEN1
	TSTF	R2		;DIFFER IF RESULT IS NOT ZERO
	BNEQ	IDEN1
	MOVL	(SP)+,R11	;TAKE IDENT EXIT
	JMP	@(R11)+
	.ENDC
;
;      HERE FOR NAMES, IDENT IF BASES AND OFFSETS SAME
;
IDEN6::	CMPL	4*NMOFS(R9),4*NMOFS(R10) ;DIFFER IF DIFFERENT OFFSET
	BNEQU	IDEN1
	CMPL	4*NMBAS(R9),4*NMBAS(R10) ;DIFFER IF DIFFERENT BASE
	BNEQU	IDEN1
;
;      MERGE HERE TO SIGNAL IDENT FOR IDENTICAL POINTERS
;
IDEN7::	MOVL	(SP)+,R11	;TAKE IDENT EXIT
	JMP	@(R11)+
;
;      HERE FOR DIFFER STRINGS
;
IDEN8::	CLRL	R9		;CLEAR GARBAGE PTR IN XR
	CLRL	R10		;CLEAR GARBAGE PTR IN XL
	ADDL2	#4*1,(SP)	;RETURN TO CALLER (DIFFER)
	RSB
	;ENP			;END PROCEDURE IDENT
	.PAGE
;
;      INOUT - USED TO INITIALISE INPUT AND OUTPUT VARIABLES
;
;      (XL)                  POINTER TO VBL NAME STRING
;      (WB)                  TRBLK TYPE
;      JSR  INOUT            CALL TO PERFORM INITIALISATION
;      (XL)                  VRBLK PTR
;      (XR)                  TRBLK PTR
;      (WA,WC)               DESTROYED
;
;      NOTE THAT TRTER (= TRTRF) FIELD OF STANDARD I/O VARIABLES
;      POINTS TO CORRESPONDING SVBLK NOT TO A TRBLK AS IS THE
;      CASE FOR ORDINARY VARIABLES.
;
	.ENABLE	LOCAL_BLOCK
INOUT::	;PRC			;ENTRY POINT
	MOVL	R7,-(SP)	;STACK TRBLK TYPE
	MOVL	4*SCLEN(R10),R6	;GET NAME LENGTH
	CLRL	R7		;POINT TO START OF NAME
	JSB	SBSTR		;BUILD A PROPER SCBLK
	JSB	GTNVR		;BUILD VRBLK
	.ADDRESS INVALID$	;NO ERROR RETURN
	MOVL	R9,R8		;SAVE VRBLK POINTER
	MOVL	(SP)+,R7	;GET TRTER FIELD
	CLRL	R10		;ZERO TRFPT
	JSB	TRBLD		;BUILD TRBLK
	MOVL	R8,R10		;RECALL VRBLK POINTER
	MOVL	4*VRSVP(R10),4*TRTER(R9) ;STORE SVBLK POINTER
	MOVL	R9,4*VRVAL(R10)	;STORE TRBLK PTR IN VRBLK
	MOVL	#B$VRA,4*VRGET(R10) ;SET TRAPPED ACCESS
	MOVL	#B$VRV,4*VRSTO(R10) ;SET TRAPPED STORE
	RSB			;RETURN TO CALLER
	;ENP			;END PROCEDURE INOUT
	.PAGE
;
;      IOFCB -- GET INPUT/OUTPUT FCBLK POINTER
;
;      USED BY ENDFILE, EJECT AND REWIND TO FIND THE FCBLK
;      (IF ANY) CORRESPONDING TO THEIR ARGUMENT.
;
;      -(XS)                 ARGUMENT
;      JSR  IOFCB            CALL TO FIND FCBLK
;      PPM  LOC              ARG IS AN UNSUITABLE NAME
;      PPM  LOC              ARG IS NULL STRING
;      (XS)                  POPPED
;      (XL)                  PTR TO FILEARG1 VRBLK
;      (XR)                  ARGUMENT
;      (WA)                  FCBLK PTR OR 0
;      (WB)                  DESTROYED
;
	.ENABLE	LOCAL_BLOCK
IOFCB::	MOVL	(SP)+,IOFCB_SAVE;ENTRY POINT
	.SAVE_PSECT LOCAL_BLOCK
	.PSECT	PRC_SAVE,NOEXE
IOFCB_SAVE::.LONG	0
	.RESTORE_PSECT
	JSB	GTSTG		;GET ARG AS STRING
	.ADDRESS IOFC2		;FAIL
	MOVL	R9,R10		;COPY STRING PTR
	JSB	GTNVR		;GET AS NATURAL VARIABLE
	.ADDRESS IOFC3		;FAIL IF NULL
	MOVL	R10,R7		;COPY STRING POINTER AGAIN
	MOVL	R9,R10		;COPY VRBLK PTR FOR RETURN
	CLRL	R6		;IN CASE NO TRBLK FOUND
;
;      LOOP TO FIND FILE ARG1 TRBLK
;
IOFC1::	MOVL	4*VRVAL(R9),R9	;GET POSSIBLE TRBLK PTR
	CMPL	(R9),#B$TRT	;FAIL IF END OF CHAIN
	BNEQU	IOFC2
	CMPL	4*TRTYP(R9),#TRTFC ;LOOP IF NOT FILE ARG TRBLK
	BNEQU	IOFC1
	MOVL	4*TRFPT(R9),R6	;GET FCBLK PTR
	MOVL	R7,R9		;COPY ARG
	ADDL3	#4*2,IOFCB_SAVE,R11 ;RETURN
	JMP	(R11)
;
;      FAIL RETURN
;
IOFC2::	MOVL	IOFCB_SAVE,R11	;FAIL
	JMP	@(R11)+
;
;      NULL ARG
;
IOFC3::	ADDL3	#4*1,IOFCB_SAVE,R11 ;NULL ARG RETURN
	JMP	@(R11)+
	;ENP			;END PROCEDURE IOFCB
	.PAGE
;
;      IOPPF -- PROCESS FILEARG2 FOR IOPUT
;
;      (R$XSC)               FILEARG2 PTR
;      JSR  IOPPF            CALL TO PROCESS FILEARG2
;      (XL)                  FILEARG1 PTR
;      (XR)                  FILE ARG2 PTR
;      -(XS)..-(XS)          FIELDS EXTRACTED FROM FILEARG2
;      (WC)                  NO. OF FIELDS EXTRACTED
;      (WB)                  INPUT/OUTPUT FLAG
;      (WA)                  FCBLK PTR OR 0
;
	.ENABLE	LOCAL_BLOCK
IOPPF::	MOVL	(SP)+,IOPPF_SAVE;ENTRY POINT
	.SAVE_PSECT LOCAL_BLOCK
	.PSECT	PRC_SAVE,NOEXE
IOPPF_SAVE::.LONG	0
	.RESTORE_PSECT
	CLRL	R7		;TO COUNT FIELDS EXTRACTED
;
;      LOOP TO EXTRACT FIELDS
;
IOPP1::	MOVL	#IODEL,R10	;GET DELIMITER
	MOVL	R10,R8		;COPY IT
	JSB	XSCAN		;GET NEXT FIELD
	MOVL	R9,-(SP)	;STACK IT
	INCL	R7		;INCREMENT COUNT
	TSTL	R6		;LOOP
	BNEQU	IOPP1
	MOVL	R7,R8		;COUNT OF FIELDS
	MOVL	IOPTT,R7	;I/O MARKER
	MOVL	R$IOF,R6	;FCBLK PTR OR 0
	MOVL	R$IO2,R9	;FILE ARG2 PTR
	MOVL	R$IO1,R10	;FILEARG1
	JMP	@IOPPF_SAVE	;RETURN
	;ENP			;END PROCEDURE IOPPF
	.PAGE
;
;      IOPUT -- ROUTINE USED BY INPUT AND OUTPUT
;
;      IOPUT SETS UP INPUT/OUTPUT  ASSOCIATIONS. IT BUILDS
;      SUCH TRACE AND FILE CONTROL BLOCKS AS ARE NECESSARY AND
;      CALLS SYSFC,SYSIO TO PERFORM CHECKS ON THE
;      ARGUMENTS AND TO OPEN THE FILES.
;
;         +-----------+   +---------------+       +-----------+
;      +-.I           I   I               I------.I   =B$XRT  I
;      I  +-----------+   +---------------+       +-----------+
;      I  /           /        (R$FCB)            I    *4     I
;      I  /           /                           +-----------+
;      I  +-----------+   +---------------+       I           I-
;      I  I   NAME    +--.I    =B$TRT     I       +-----------+
;      I  /           /   +---------------+       I           I
;      I   (FIRST ARG)    I =TRTIN/=TRTOU I       +-----------+
;      I                  +---------------+             I
;      I                  I     VALUE     I             I
;      I                  +---------------+             I
;      I                  I(TRTRF) 0   OR I--+          I
;      I                  +---------------+  I          I
;      I                  I(TRFPT) 0   OR I----+        I
;      I                  +---------------+  I I        I
;      I                     (I/O TRBLK)     I I        I
;      I  +-----------+                      I I        I
;      I  I           I                      I I        I
;      I  +-----------+                      I I        I
;      I  I           I                      I I        I
;      I  +-----------+   +---------------+  I I        I
;      I  I           +--.I    =B$TRT     I.-+ I        I
;      I  +-----------+   +---------------+    I        I
;      I  /           /   I    =TRTFC     I    I        I
;      I  /           /   +---------------+    I        I
;      I    (FILEARG1     I     VALUE     I    I        I
;      I         VRBLK)   +---------------+    I        I
;      I                  I(TRTRF) 0   OR I--+ I        .
;      I                  +---------------+  I .  +-----------+
;      I                  I(TRFPT) 0   OR I------./   FCBLK   /
;      I                  +---------------+  I    +-----------+
;      I                       (TRTRF)       I
;      I                                     I
;      I                                     I
;      I                  +---------------+  I
;      I                  I    =B$XRT     I.-+
;      I                  +---------------+
;      I                  I      *5       I
;      I                  +---------------+
;      +------------------I               I
;                         +---------------+       +-----------+
;                         I(TRTRF) O   OR I------.I  =B$XRT   I
;                         +---------------+       +-----------+
;                         I  NAME OFFSET  I       I    ETC    I
;                         +---------------+
;                           (IOCHN - CHAIN OF NAME POINTERS)
	.PAGE
;
;      IOPUT (CONTINUED)
;
;      NO ADDITIONAL TRAP BLOCKS ARE USED FOR STANDARD INPUT/OUT
;      FILES. OTHERWISE AN I/O TRAP BLOCK IS ATTACHED TO SECOND
;      ARG (FILEARG1) VRBLK. SEE DIAGRAM ABOVE FOR DETAILS OF
;      THE STRUCTURE BUILT.
;
;      -(XS)                 1ST ARG (VBL TO BE ASSOCIATED)
;      -(XS)                 2ND ARG (FILE ARG1)
;      -(XS)                 3RD ARG (FILE ARG2)
;      (WB)                  0 FOR INPUT, 3 FOR OUTPUT ASSOC.
;      JSR  IOPUT            CALL FOR INPUT/OUTPUT ASSOCIATION
;      PPM  LOC              3RD ARG NOT A STRING
;      PPM  LOC              2ND ARG NOT A SUITABLE NAME
;      PPM  LOC              1ST ARG NOT A SUITABLE NAME
;      PPM  LOC              INAPPROPRIATE FILE SPEC FOR I/O
;      PPM  LOC              I/O FILE DOES NOT EXIST
;      PPM  LOC              I/O FILE CANNOT BE READ/WRITTEN
;      (XS)                  POPPED
;      (XL,XR,WA,WB,WC)      DESTROYED
;
	.ENABLE	LOCAL_BLOCK
IOPUT::	MOVL	(SP)+,IOPUT_SAVE;ENTRY POINT
	.SAVE_PSECT LOCAL_BLOCK
	.PSECT	PRC_SAVE,NOEXE
IOPUT_SAVE::.LONG	0
	.RESTORE_PSECT
	CLRL	R$IOT		;IN CASE NO TRTRF BLOCK USED
	CLRL	R$IOF		;IN CASE NO FCBLK ALOCATED
	MOVL	R7,IOPTT	;STORE I/O TRACE TYPE
	JSB	XSCNI		;PREPARE TO SCAN FILEARG2
	.ADDRESS IOP13		;FAIL
	.ADDRESS IOPA0		;NULL FILE ARG2
;
IOPA0::	MOVL	R9,R$IO2	;KEEP FILE ARG2
	MOVL	R6,R10		;COPY LENGTH
	JSB	GTSTG		;CONVERT FILEARG1 TO STRING
	.ADDRESS IOP14		;FAIL
	MOVL	R9,R$IO1	;KEEP FILEARG1 PTR
	JSB	GTNVR		;CONVERT TO NATURAL VARIABLE
	.ADDRESS IOP00		;JUMP IF NULL
	JMP	IOP04		;JUMP TO PROCESS NON-NULL ARGS
;
;      NULL FILEARG1
;
IOP00::	TSTL	R10		;SKIP IF BOTH ARGS NULL
	BNEQU	5209$
	JMP	IOP01
5209$:
	JSB	IOPPF		;PROCESS FILEARG2
	JSB	SYSFC		;CALL FOR FILEARG2 CHECK
	.ADDRESS IOP16		;FAIL
	JMP	IOP11		;COMPLETE FILE ASSOCIATION
	.PAGE
;
;      IOPUT (CONTINUED)
;
;      HERE WITH 0 OR FCBLK PTR IN (XL)
;
IOP01::	MOVL	IOPTT,R7	;GET TRACE TYPE
	MOVL	R$IOT,R9	;GET 0 OR TRTRF PTR
	JSB	TRBLD		;BUILD TRBLK
	MOVL	R9,R8		;COPY TRBLK POINTER
	MOVL	(SP)+,R9	;GET VARIABLE FROM STACK
	JSB	GTVAR		;POINT TO VARIABLE
	.ADDRESS IOP15		;FAIL
	MOVL	R10,R$ION	;SAVE NAME POINTER
	MOVL	R10,R9		;COPY NAME POINTER
	ADDL2	R6,R9		;POINT TO VARIABLE
	SUBL2	#4*VRVAL,R9	;SUBTRACT OFFSET,MERGE INTO LOOP
;
;      LOOP TO END OF TRBLK CHAIN IF ANY
;
IOP02::	MOVL	R9,R10		;COPY BLK PTR
	MOVL	4*VRVAL(R9),R9	;LOAD PTR TO NEXT TRBLK
	CMPL	(R9),#B$TRT	;JUMP IF NOT TRAPPED
	BNEQU	IOP03
	CMPL	4*TRTYP(R9),IOPTT;LOOP IF NOT SAME ASSOCN
	BNEQU	IOP02
	MOVL	4*TRNXT(R9),R9	;GET VALUE AND DELETE OLD TRBLK
;
;      IOPUT (CONTINUED)
;
;      STORE NEW ASSOCIATION
;
IOP03::	MOVL	R8,4*VRVAL(R10)	;LINK TO THIS TRBLK
	MOVL	R8,R10		;COPY POINTER
	MOVL	R9,4*TRNXT(R10)	;STORE VALUE IN TRBLK
	MOVL	R$ION,R9	;RESTORE POSSIBLE VRBLK POINTER
	MOVL	R6,R7		;KEEP OFFSET TO NAME
	JSB	SETVR		;IF VRBLK, SET VRGET,VRSTO
	MOVL	R$IOT,R9	;GET 0 OR TRTRF PTR
	BEQLU	5210$
	JMP	IOP19
5210$:
	ADDL3	#4*6,IOPUT_SAVE,R11 ;RETURN TO CALLER
	JMP	(R11)
;
;      NON STANDARD FILE
;      SEE IF AN FCBLK HAS ALREADY BEEN ALLOCATED.
;
IOP04::	CLRL	R6		;IN CASE NO FCBLK FOUND
	.PAGE
;
;      IOPUT (CONTINUED)
;
;      SEARCH POSSIBLE TRBLK CHAIN TO PICK UP THE FCBLK
;
IOP05::	MOVL	R9,R7		;REMEMBER BLK PTR
	MOVL	4*VRVAL(R9),R9	;CHAIN ALONG
	CMPL	(R9),#B$TRT	;JUMP IF END OF TRBLK CHAIN
	BNEQU	IOP06
	CMPL	4*TRTYP(R9),#TRTFC ;LOOP IF MORE TO GO
	BNEQU	IOP05
	MOVL	R9,R$IOT	;POINT TO FILE ARG1 TRBLK
	MOVL	4*TRFPT(R9),R6	;GET FCBLK PTR FROM TRBLK
;
;      WA = 0 OR FCBLK PTR
;      WB = PTR TO PRECEDING BLK TO WHICH ANY TRTRF BLOCK
;           FOR FILE ARG1 MUST BE CHAINED.
;
IOP06::	MOVL	R6,R$IOF	;KEEP POSSIBLE FCBLK PTR
	MOVL	R7,R$IOP	;KEEP PRECEDING BLK PTR
	JSB	IOPPF		;PROCESS FILEARG2
	JSB	SYSFC		;SEE IF FCBLK REQUIRED
	.ADDRESS IOP16		;FAIL
	TSTL	R6		;SKIP IF NO NEW FCBLK WANTED
	BNEQU	5211$
	JMP	IOP12
5211$:
	CMPL	R8,#NUM02	;JUMP IF FCBLK IN DYNAMIC
	BLSSU	IOP6A
	JSB	ALOST		;GET IT IN STATIC
	JMP	IOP6B		;SKIP
;
;      OBTAIN FCBLK IN DYNAMIC
;
IOP6A::	JSB	ALLOC		;GET SPACE FOR FCBLK
;
;      MERGE
;
IOP6B::	MOVL	R9,R10		;POINT TO FCBLK
	MOVL	R6,R7		;COPY ITS LENGTH
	ASHL	#-2,R7,R7	;GET COUNT AS WORDS (PATCH SGD APR-80)
				;LOOP COUNTER
;
;      CLEAR FCBLK
;
IOP07::	CLRL	(R9)+		;CLEAR A WORD
	SOBGTR	R7,IOP07	;LOOP
	CMPL	R8,#NUM02	;SKIP IF IN STATIC - DONT SET FIELDS
	BNEQU	5212$
	JMP	IOP09
5212$:
	MOVL	#B$XNT,(R10)	;STORE XNBLK CODE IN CASE
	MOVL	R6,4*1(R10)	;STORE LENGTH
	TSTL	R8		;JUMP IF XNBLK WANTED
	BEQLU	5213$
	JMP	IOP09
5213$:
	MOVL	#B$XRT,(R10)	;XRBLK CODE REQUESTED
;
	.PAGE
;      IOPUT (CONTINUED)
;
;      COMPLETE FCBLK INITIALISATION
;
IOP09::	MOVL	R$IOT,R9	;GET POSSIBLE TRBLK PTR
	MOVL	R10,R$IOF	;STORE FCBLK PTR
	TSTL	R9		;JUMP IF TRBLK ALREADY FOUND
	BNEQU	IOP10
;
;      A NEW TRBLK IS NEEDED
;
	MOVL	#TRTFC,R7	;TRTYP FOR FCBLK TRAP BLK
	JSB	TRBLD		;MAKE THE BLOCK
	MOVL	R9,R$IOT	;COPY TRTRF PTR
	MOVL	R$IOP,R10	;POINT TO PRECEDING BLK
	MOVL	4*VRVAL(R10),4*VRVAL(R9) ;COPY VALUE FIELD TO TRBLK
	MOVL	R9,4*VRVAL(R10)	;LINK NEW TRBLK INTO CHAIN
	MOVL	R10,R9		;POINT TO PREDECESSOR BLK
	JSB	SETVR		;SET TRACE INTERCEPTS
	MOVL	4*VRVAL(R9),R9	;RECOVER TRBLK PTR
;
;      XR IS PTR TO TRBLK, XL IS FCBLK PTR OR 0
;
IOP10::	MOVL	R$IOF,4*TRFPT(R9);STORE FCBLK PTR
;
;      CALL SYSIO TO COMPLETE FILE ACCESSING
;
IOP11::	MOVL	R$IOF,R6	;COPY FCBLK PTR OR 0
	MOVL	IOPTT,R7	;GET INPUT/OUTPUT FLAG
	MOVL	R$IO2,R9	;GET FILE ARG2
	MOVL	R$IO1,R10	;GET FILE ARG1
	JSB	SYSIO		;ASSOCIATE TO THE FILE
	.ADDRESS IOP17		;FAIL
	.ADDRESS IOP18		;FAIL
	TSTL	R$IOT		;NOT STD INPUT IF NON-NULL TRTRF BLK
	BEQLU	5214$
	JMP	IOP01
5214$:
	TSTL	IOPTT		;JUMP IF OUTPUT
	BEQLU	5215$
	JMP	IOP01
5215$:
	TSTL	R8		;NO CHANGE TO STANDARD READ LENGTH
	BNEQU	5216$
	JMP	IOP01
5216$:
	MOVL	R8,CSWIN	;STORE NEW READ LENGTH FOR STD FILE
	JMP	IOP01		;MERGE TO FINISH THE TASK
;
;      SYSFC MAY HAVE RETURNED A POINTER TO A PRIVATE FCBLK
;
IOP12::	TSTL	R10		;JUMP IF PRIVATE FCBLK
	BEQLU	5217$
	JMP	IOP09
5217$:
	JMP	IOP11		;FINISH THE ASSOCIATION
;
;      FAILURE RETURNS
;
IOP13::	MOVL	IOPUT_SAVE,R11	;3RD ARG NOT A STRING
	JMP	@(R11)+
IOP14::	ADDL3	#4*1,IOPUT_SAVE,R11 ;2ND ARG UNSUITABLE
	JMP	@(R11)+
IOP15::	ADDL3	#4*2,IOPUT_SAVE,R11 ;1ST ARG UNSUITABLE
	JMP	@(R11)+
IOP16::	ADDL3	#4*3,IOPUT_SAVE,R11 ;FILE SPEC WRONG
	JMP	@(R11)+
IOP17::	ADDL3	#4*4,IOPUT_SAVE,R11 ;I/O FILE DOES NOT EXIST
	JMP	@(R11)+
IOP18::	ADDL3	#4*5,IOPUT_SAVE,R11 ;I/O FILE CANNOT BE READ/WRITTEN
	JMP	@(R11)+
	.PAGE
;
;      IOPUT (CONTINUED)
;
;      ADD TO IOCHN CHAIN OF ASSSOCIATED VARIABLES UNLESS ALREAD
;      PRESENT.
;
IOP19::	MOVL	R$ION,R8	;WC = NAME BASE, WB = NAME OFFSET
;
;      SEARCH LOOP
;
IOP20::	MOVL	4*TRTRF(R9),R9	;NEXT LINK OF CHAIN
	BEQLU	IOP21
	CMPL	R8,4*IONMB(R9)	;NO MATCH
	BNEQU	IOP20
	CMPL	R7,4*IONMO(R9)	;EXIT IF MATCHED
	BEQLU	IOP22
	JMP	IOP20		;LOOP
;
;      NOT FOUND
;
IOP21::	MOVL	#4*NUM05,R6	;SPACE NEEDED
	JSB	ALLOC		;GET IT
	MOVL	#B$XRT,(R9)	;STORE XRBLK CODE
	MOVL	R6,4*1(R9)	;STORE LENGTH
	MOVL	R8,4*IONMB(R9)	;STORE NAME BASE
	MOVL	R7,4*IONMO(R9)	;STORE NAME OFFSET
	MOVL	R$IOT,R10	;POINT TO TRTRF BLK
	MOVL	4*TRTRF(R10),R6	;GET PTR FIELD CONTENTS
	MOVL	R9,4*TRTRF(R10)	;STORE PTR TO NEW BLOCK
	MOVL	R6,4*TRTRF(R9)	;COMPLETE THE LINKING
;
;      INSERT FCBLK ON FCBLK CHAIN FOR SYSEJ, SYSXI
;
IOP22::	TSTL	R$IOF		;SKIP IF NO FCBLK
	BEQLU	IOP25
	MOVL	R$FCB,R10	;PTR TO HEAD OF EXISTING CHAIN
;
;      SEE IF FCBLK ALREADY ON CHAIN
;
IOP23::	TSTL	R10		;NOT ON IF END OF CHAIN
	BEQLU	IOP24
	CMPL	4*3(R10),R$IOF	;DONT DUPLICATE IF FIND IT
	BEQLU	IOP25
	MOVL	4*2(R10),R10	;GET NEXT LINK
	JMP	IOP23		;LOOP
;
;      NOT FOUND SO ADD AN ENTRY FOR THIS FCBLK
;
IOP24::	MOVL	#4*NUM04,R6	;SPACE NEEDED
	JSB	ALLOC		;GET IT
	MOVL	#B$XRT,(R9)	;STORE BLOCK CODE
	MOVL	R6,4*1(R9)	;STORE LENGTH
	MOVL	R$FCB,4*2(R9)	;STORE PREVIOUS LINK IN THIS NODE
	MOVL	R$IOF,4*3(R9)	;STORE FCBLK PTR
	MOVL	R9,R$FCB	;INSERT NODE INTO FCBLK CHAIN
;
;      RETURN
;
IOP25::	ADDL3	#4*6,IOPUT_SAVE,R11 ;RETURN TO CALLER
	JMP	(R11)
	;ENP			;END PROCEDURE IOPUT
	.PAGE
;
;      KTREX -- EXECUTE KEYWORD TRACE
;
;      KTREX IS USED TO EXECUTE A POSSIBLE KEYWORD TRACE. IT
;      INCLUDES THE TEST ON TRACE AND TESTS FOR TRACE ACTIVE.
;
;      (XL)                  PTR TO TRBLK (OR 0 IF UNTRACED)
;      JSR  KTREX            CALL TO EXECUTE KEYWORD TRACE
;      (XL,WA,WB,WC)         DESTROYED
;      (RA)                  DESTROYED
;
	.ENABLE	LOCAL_BLOCK
KTREX::	;PRC			;ENTRY POINT (RECURSIVE)
	TSTL	R10		;IMMEDIATE EXIT IF KEYWORD UNTRACED
	BEQLU	KTRX3
	TSTL	KVTRA		;IMMEDIATE EXIT IF TRACE = 0
	BEQLU	KTRX3
	DECL	KVTRA		;ELSE DECREMENT TRACE
	MOVL	R9,-(SP)	;SAVE XR
	MOVL	R10,R9		;COPY TRBLK POINTER
	MOVL	4*TRKVR(R9),R10	;LOAD VRBLK POINTER (NMBAS)
	MOVL	#4*VRVAL,R6	;SET NAME OFFSET
	TSTL	4*TRFNC(R9)	;JUMP IF PRINT TRACE
	BEQLU	KTRX1
	JSB	TRXEQ		;ELSE EXECUTE FULL TRACE
	JMP	KTRX2		;AND JUMP TO EXIT
;
;      HERE FOR PRINT TRACE
;
KTRX1::	MOVL	R10,-(SP)	;STACK VRBLK PTR FOR KWNAM
	MOVL	R6,-(SP)	;STACK OFFSET FOR KWNAM
	JSB	PRTSN		;PRINT STATEMENT NUMBER
	MOVL	#CH$AM,R6	;LOAD AMPERSAND
	JSB	PRTCH		;PRINT AMPERSAND
	JSB	PRTNM		;PRINT KEYWORD NAME
	MOVL	#TMBEB,R9	;POINT TO BLANK-EQUAL-BLANK
	JSB	PRTST		;PRINT BLANK-EQUAL-BLANK
	JSB	KWNAM		;GET KEYWORD PSEUDO-VARIABLE NAME
	MOVL	R9,DNAMP	;RESET PTR TO DELETE KVBLK
	JSB	ACESS		;GET KEYWORD VALUE
	.ADDRESS INVALID$	;FAILURE IS IMPOSSIBLE
	JSB	PRTVL		;PRINT KEYWORD VALUE
	JSB	PRTNL		;TERMINATE PRINT LINE
;
;      HERE TO EXIT AFTER COMPLETING TRACE
;
KTRX2::	MOVL	(SP)+,R9	;RESTORE ENTRY XR
;
;      MERGE HERE TO EXIT IF NO TRACE REQUIRED
;
KTRX3::	RSB			;RETURN TO KTREX CALLER
	;ENP			;END PROCEDURE KTREX
	.PAGE
;
;      KWNAM -- GET PSEUDO-VARIABLE NAME FOR KEYWORD
;
;      1(XS)                 NAME BASE FOR VRBLK
;      0(XS)                 OFFSET (SHOULD BE *VRVAL)
;      JSR  KWNAM            CALL TO GET PSEUDO-VARIABLE NAME
;      (XS)                  POPPED TWICE
;      (XL,WA)               RESULTING PSEUDO-VARIABLE NAME
;      (XR,WA,WB)            DESTROYED
;
	.ENABLE	LOCAL_BLOCK
KWNAM::	MOVL	(SP)+,KWNAM_SAVE;ENTRY POINT
	.SAVE_PSECT LOCAL_BLOCK
	.PSECT	PRC_SAVE,NOEXE
KWNAM_SAVE::.LONG	0
	.RESTORE_PSECT
	ADDL2	#4,SP		;IGNORE NAME OFFSET
	MOVL	(SP)+,R9	;LOAD NAME BASE
	CMPL	R9,STATE	;JUMP IF NOT NATURAL VARIABLE NAME
	BGEQU	KWNM1
	TSTL	4*VRLEN(R9)	;ERROR IF NOT SYSTEM VARIABLE
	BNEQU	KWNM1
	MOVL	4*VRSVP(R9),R9	;ELSE POINT TO SVBLK
	MOVL	4*SVBIT(R9),R6	;LOAD BIT MASK
	MCOML	BTKNM,R11	;AND WITH KEYWORD BIT
	BICL2	R11,R6
	BEQLU	KWNM1
	MOVL	4*SVLEN(R9),R6	;ELSE LOAD NAME LENGTH IN CHARACTERS
	MOVAB	3+<4*SVCHS>(R6),R6 ;COMPUTE OFFSET TO FIELD WE WANT
	BICL2	#3,R6
	ADDL2	R6,R9		;POINT TO SVKNM FIELD
	MOVL	(R9),R7		;LOAD SVKNM VALUE
	MOVL	#4*KVSI$,R6	;SET SIZE OF KVBLK
	JSB	ALLOC		;ALLOCATE KVBLK
	MOVL	#B$KVT,(R9)	;STORE TYPE WORD
	MOVL	R7,4*KVNUM(R9)	;STORE KEYWORD NUMBER
	MOVL	#TRBKV,4*KVVAR(R9) ;SET DUMMY TRBLK POINTER
	MOVL	R9,R10		;COPY KVBLK POINTER
	MOVL	#4*KVVAR,R6	;SET PROPER OFFSET
	JMP	@KWNAM_SAVE	;RETURN TO KVNAM CALLER
;
;      HERE IF NOT KEYWORD NAME
;
KWNM1::	JMP	ERROR_251	;KEYWORD OPERAND IS NOT NAME OF DEFINED KEYWORD
	;ENP			;END PROCEDURE KWNAM
	.PAGE
;
;      LCOMP-- COMPARE TWO STRINGS LEXICALLY
;
;      1(XS)                 FIRST ARGUMENT
;      0(XS)                 SECOND ARGUMENT
;      JSR  LCOMP            CALL TO COMPARE ARUMENTS
;      PPM  LOC              TRANSFER LOC FOR ARG1 NOT STRING
;      PPM  LOC              TRANSFER LOC FOR ARG2 NOT STRING
;      PPM  LOC              TRANSFER LOC IF ARG1 LLT ARG2
;      PPM  LOC              TRANSFER LOC IF ARG1 LEQ ARG2
;      PPM  LOC              TRANSFER LOC IF ARG1 LGT ARG2
;      (THE NORMAL RETURN IS NEVER TAKEN)
;      (XS)                  POPPED TWICE
;      (XR,XL)               DESTROYED
;      (WA,WB,WC,RA)         DESTROYED
;
	.ENABLE	LOCAL_BLOCK
LCOMP::	MOVL	(SP)+,LCOMP_SAVE;ENTRY POINT
	.SAVE_PSECT LOCAL_BLOCK
	.PSECT	PRC_SAVE,NOEXE
LCOMP_SAVE::.LONG	0
	.RESTORE_PSECT
	JSB	GTSTG		;CONVERT SECOND ARG TO STRING
	.ADDRESS LCMP6		;JUMP IF SECOND ARG NOT STRING
	MOVL	R9,R10		;ELSE SAVE POINTER
	MOVL	R6,R7		;AND LENGTH
	JSB	GTSTG		;CONVERT FIRST ARGUMENT TO STRING
	.ADDRESS LCMP5		;JUMP IF NOT STRING
	MOVL	R6,R8		;SAVE ARG 1 LENGTH
	MOVAB	CFP$F(R9),R9	;POINT TO CHARS OF ARG 1
	MOVAB	CFP$F(R10),R10	;POINT TO CHARS OF ARG 2
	CMPL	R6,R7		;JUMP IF ARG 1 LENGTH IS SMALLER
	BLEQU	LCMP1
	MOVL	R7,R6		;ELSE SET ARG 2 LENGTH AS SMALLER
;
;      HERE WITH SMALLER LENGTH IN (WA)
;
LCMP1::	CMC	LCMP4,LCMP3	;COMPARE STRINGS, JUMP IF UNEQUAL
	CMPL	R7,R8		;IF EQUAL, JUMP IF LENGTHS UNEQUAL
	BNEQU	LCMP2
	ADDL3	#4*3,LCOMP_SAVE,R11 ;ELSE IDENTICAL STRINGS, LEQ EXIT
	JMP	@(R11)+
	.PAGE
;
;      LCOMP (CONTINUED)
;
;      HERE IF INITIAL STRINGS IDENTICAL, BUT LENGTHS UNEQUAL
;
LCMP2::	CMPL	R8,R7		;JUMP IF ARG 1 LENGTH GT ARG 2 LENG
	BGEQU	LCMP4
;
;      HERE IF FIRST ARG LLT SECOND ARG
;
LCMP3::	ADDL3	#4*2,LCOMP_SAVE,R11 ;TAKE LLT EXIT
	JMP	@(R11)+
;
;      HERE IF FIRST ARG LGT SECOND ARG
;
LCMP4::	ADDL3	#4*4,LCOMP_SAVE,R11 ;TAKE LGT EXIT
	JMP	@(R11)+
;
;      HERE IF FIRST ARG IS NOT A STRING
;
LCMP5::	MOVL	LCOMP_SAVE,R11	;TAKE BAD FIRST ARG EXIT
	JMP	@(R11)+
;
;      HERE FOR SECOND ARG NOT A STRING
;
LCMP6::	ADDL3	#4*1,LCOMP_SAVE,R11 ;TAKE BAD SECOND ARG ERROR EXIT
	JMP	@(R11)+
	;ENP			;END PROCEDURE LCOMP
	.PAGE
;
;      LISTR -- LIST SOURCE LINE
;
;      LISTR IS USED TO LIST A SOURCE LINE DURING THE INITIAL
;      COMPILATION. IT IS CALLED FROM SCANE AND SCANL.
;
;      JSR  LISTR            CALL TO LIST LINE
;      (XR,XL,WA,WB,WC)      DESTROYED
;
;      GLOBAL LOCATIONS USED BY LISTR
;
;      ERLST                 IF LISTING ON ACCOUNT OF AN ERROR
;
;      LSTLC                 COUNT LINES ON CURRENT PAGE
;
;      LSTNP                 MAX NUMBER OF LINES/PAGE
;
;      LSTPF                 SET NON-ZERO IF THE CURRENT SOURCE
;                            LINE HAS BEEN LISTED, ELSE ZERO.
;
;      LSTPG                 COMPILER LISTING PAGE NUMBER
;
;      LSTSN                 SET IF STMNT NUM TO BE LISTED
;
;      R$CIM                 POINTER TO CURRENT INPUT LINE.
;
;      R$TTL                 TITLE FOR SOURCE LISTING
;
;      R$STL                 PTR TO SUB-TITLE STRING
;
;      ENTRY POINT
;
	.ENABLE	LOCAL_BLOCK
LISTR::	;PRC			;ENTRY POINT
	TSTL	CNTTL		;JUMP IF -TITLE OR -STITL
	BEQLU	5218$
	JMP	LIST5
5218$:
	TSTL	LSTPF		;IMMEDIATE EXIT IF ALREADY LISTED
	BEQLU	5219$
	JMP	LIST4
5219$:
	CMPL	LSTLC,LSTNP	;JUMP IF NO ROOM
	BLSSU	5220$
	JMP	LIST6
5220$:
;
;      HERE AFTER PRINTING TITLE (IF NEEDED)
;
LIST0::	MOVL	R$CIM,R9	;LOAD POINTER TO CURRENT IMAGE
	MOVAB	CFP$F(R9),R9	;POINT TO CHARACTERS
	MOVZBL	(R9),R6		;LOAD FIRST CHARACTER
	MOVL	LSTSN,R9	;LOAD STATEMENT NUMBER
	BEQLU	LIST2
	MOVL	R9,R5		;ELSE GET STMNT NUMBER AS INTEGER
	CMPL	STAGE,#STGIC	;SKIP IF EXECUTE TIME
	BNEQU	LIST1
	CMPL	R6,#CH$AS	;NO STMNT NUMBER LIST IF COMMENT
	BEQLU	LIST2
	CMPL	R6,#CH$MN	;NO STMNT NO. IF CONTROL CARD
	BEQLU	LIST2
;
;      PRINT STATEMENT NUMBER
;
LIST1::	JSB	PRTIN		;ELSE PRINT STATEMENT NUMBER
	CLRL	LSTSN		;AND CLEAR FOR NEXT TIME IN
	.PAGE
;
;      LISTR (CONTINUED)
;
;      MERGE HERE AFTER PRINTING STATEMENT NUMBER (IF REQUIRED)
;
LIST2::	MOVL	#STNPD,PROFS	;POINT PAST STATEMENT NUMBER
	MOVL	R$CIM,R9	;LOAD POINTER TO CURRENT IMAGE
	JSB	PRTST		;PRINT IT
	INCL	LSTLC		;BUMP LINE COUNTER
	TSTL	ERLST		;JUMP IF ERROR COPY TO INT.CH.
	BNEQU	LIST3
	JSB	PRTNL		;TERMINATE LINE
	TSTL	CSWDB		;JUMP IF -SINGLE MODE
	BEQLU	LIST3
	JSB	PRTNL		;ELSE ADD A BLANK LINE
	INCL	LSTLC		;AND BUMP LINE COUNTER
;
;      HERE AFTER PRINTING SOURCE IMAGE
;
LIST3::	MOVL	SP,LSTPF	;SET FLAG FOR LINE PRINTED
;
;      MERGE HERE TO EXIT
;
LIST4::	RSB			;RETURN TO LISTR CALLER
;
;      PRINT TITLE AFTER -TITLE OR -STITL CARD
;
LIST5::	CLRL	CNTTL		;CLEAR FLAG
;
;      EJECT TO NEW PAGE AND LIST TITLE
;
LIST6::	JSB	PRTPS		;EJECT
	TSTL	PRICH		;SKIP IF LISTING TO REGULAR PRINTER
	BEQLU	LIST7
	CMPL	R$TTL,#NULLS	;TERMINAL LISTING OMITS NULL TITLE
	BNEQU	5221$
	JMP	LIST0
5221$:
;
;      LIST TITLE
;
LIST7::	JSB	LISTT		;LIST TITLE
	JMP	LIST0		;MERGE
	;ENP			;END PROCEDURE LISTR
	.PAGE
;
;      LISTT -- LIST TITLE AND SUBTITLE
;
;      USED DURING COMPILATION TO PRINT PAGE HEADING
;
;      JSR  LISTT            CALL TO LIST TITLE
;      (XR,WA)               DESTROYED
;
	.ENABLE	LOCAL_BLOCK
LISTT::	;PRC			;ENTRY POINT
	MOVL	R$TTL,R9	;POINT TO SOURCE LISTING TITLE
	JSB	PRTST		;PRINT TITLE
	MOVL	LSTPO,PROFS	;SET OFFSET
	MOVL	#LSTMS,R9	;SET PAGE MESSAGE
	JSB	PRTST		;PRINT PAGE MESSAGE
	INCL	LSTPG		;BUMP PAGE NUMBER
	MOVL	LSTPG,R5	;LOAD PAGE NUMBER AS INTEGER
	JSB	PRTIN		;PRINT PAGE NUMBER
	JSB	PRTNL		;TERMINATE TITLE LINE
	ADDL2	#NUM02,LSTLC	;COUNT TITLE LINE AND BLANK LINE
;
;      PRINT SUB-TITLE (IF ANY)
;
	MOVL	R$STL,R9	;LOAD POINTER TO SUB-TITLE
	BEQLU	LSTT1
	JSB	PRTST		;ELSE PRINT SUB-TITLE
	JSB	PRTNL		;TERMINATE LINE
	INCL	LSTLC		;BUMP LINE COUNT
;
;      RETURN POINT
;
LSTT1::	JSB	PRTNL		;PRINT A BLANK LINE
	RSB			;RETURN TO CALLER
	;ENP			;END PROCEDURE LISTT
	.PAGE
;
;      NEXTS -- ACQUIRE NEXT SOURCE IMAGE
;
;      NEXTS IS USED TO ACQUIRE THE NEXT SOURCE IMAGE AT COMPILE
;      TIME. IT ASSUMES THAT A PRIOR CALL TO READR HAS INPUT
;      A LINE IMAGE (SEE PROCEDURE READR). BEFORE THE CURRENT
;      IMAGE IS FINALLY LOST IT MAY BE LISTED HERE.
;
;      JSR  NEXTS            CALL TO ACQUIRE NEXT INPUT LINE
;      (XR,XL,WA,WB,WC)      DESTROYED
;
;      GLOBAL VALUES AFFECTED
;
;      R$CNI                 ON INPUT, NEXT IMAGE. ON
;                            EXIT RESET TO ZERO
;
;      R$CIM                 ON EXIT, SET TO POINT TO IMAGE
;
;      SCNIL                 INPUT IMAGE LENGTH ON EXIT
;
;      SCNSE                 RESET TO ZERO ON EXIT
;
;      LSTPF                 SET ON EXIT IF LINE IS LISTED
;
	.ENABLE	LOCAL_BLOCK
NEXTS::	;PRC			;ENTRY POINT
	TSTL	CSWLS		;JUMP IF -NOLIST
	BEQLU	NXTS2
	MOVL	R$CIM,R9	;POINT TO IMAGE
	BEQLU	NXTS2
	MOVAB	CFP$F(R9),R9	;GET CHAR PTR
	MOVZBL	(R9),R6		;GET FIRST CHAR
	CMPL	R6,#CH$MN	;JUMP IF NOT CTRL CARD
	BNEQU	NXTS1
	TSTL	CSWPR		;JUMP IF -NOPRINT
	BEQLU	NXTS2
;
;      HERE TO CALL LISTER
;
NXTS1::	JSB	LISTR		;LIST LINE
;
;      HERE AFTER POSSIBLE LISTING
;
NXTS2::	MOVL	R$CNI,R9	;POINT TO NEXT IMAGE
	MOVL	R9,R$CIM	;SET AS NEXT IMAGE
	CLRL	R$CNI		;CLEAR NEXT IMAGE POINTER
	MOVL	4*SCLEN(R9),R6	;GET INPUT IMAGE LENGTH
	MOVL	CSWIN,R7	;GET MAX ALLOWABLE LENGTH
	CMPL	R6,R7		;SKIP IF NOT TOO LONG
	BLEQU	NXTS3
	MOVL	R7,R6		;ELSE TRUNCATE
;
;      HERE WITH LENGTH IN (WA)
;
NXTS3::	MOVL	R6,SCNIL	;USE AS RECORD LENGTH
	CLRL	SCNSE		;RESET SCNSE
	CLRL	LSTPF		;SET LINE NOT LISTED YET
	RSB			;RETURN TO NEXTS CALLER
	;ENP			;END PROCEDURE NEXTS
	.PAGE
;
;      PATIN -- PATTERN CONSTRUCTION FOR LEN,POS,RPOS,TAB,RTAB
;
;      THESE PATTERN TYPES ALL GENERATE A SIMILAR NODE TYPE. SO
;      THE CONSTRUCTION CODE IS SHARED. SEE FUNCTIONS SECTION
;      FOR ACTUAL ENTRY POINTS FOR THESE FIVE FUNCTIONS.
;
;      (WA)                  PCODE FOR EXPRESSION ARG CASE
;      (WB)                  PCODE FOR INTEGER ARG CASE
;      JSR  PATIN            CALL TO BUILD PATTERN NODE
;      PPM  LOC              TRANSFER LOC FOR NOT INTEGER OR EXP
;      PPM  LOC              TRANSFER LOC FOR INT OUT OF RANGE
;      (XR)                  POINTER TO CONSTRUCTED NODE
;      (XL,WA,WB,WC,IA)      DESTROYED
;
	.ENABLE	LOCAL_BLOCK
PATIN::	MOVL	(SP)+,PATIN_SAVE;ENTRY POINT
	.SAVE_PSECT LOCAL_BLOCK
	.PSECT	PRC_SAVE,NOEXE
PATIN_SAVE::.LONG	0
	.RESTORE_PSECT
	MOVL	R6,R10		;PRESERVE EXPRESSION ARG PCODE
	JSB	GTSMI		;TRY TO CONVERT ARG AS SMALL INTEGER
	.ADDRESS PTIN2		;JUMP IF NOT INTEGER
	.ADDRESS PTIN3		;JUMP IF OUT OF RANGE
;
;      COMMON SUCCESSFUL EXIT POINT
;
PTIN1::	JSB	PBILD		;BUILD PATTERN NODE
	ADDL3	#4*2,PATIN_SAVE,R11 ;RETURN TO CALLER
	JMP	(R11)
;
;      HERE IF ARGUMENT IS NOT AN INTEGER
;
PTIN2::	MOVL	R10,R7		;COPY EXPR ARG CASE PCODE
	CMPL	(R9),#B$E$$	;ALL OK IF EXPRESSION ARG
	BLEQU	PTIN1
	MOVL	PATIN_SAVE,R11	;ELSE TAKE ERROR EXIT FOR WRONG TYPE
	JMP	@(R11)+
;
;      HERE FOR ERROR OF OUT OF RANGE INTEGER ARGUMENT
;
PTIN3::	ADDL3	#4*1,PATIN_SAVE,R11 ;TAKE OUT-OF-RANGE ERROR EXIT
	JMP	@(R11)+
	;ENP			;END PROCEDURE PATIN
	.PAGE
;
;      PATST -- PATTERN CONSTRUCTION FOR ANY,NOTANY,
;               BREAK,SPAN AND BREAKX PATTERN FUNCTIONS.
;
;      THESE PATTERN FUNCTIONS BUILD SIMILAR TYPES OF NODES AND
;      THE CONSTRUCTION CODE IS SHARED. SEE FUNCTIONS SECTION
;      FOR ACTUAL ENTRY POINTS FOR THESE FIVE PATTERN FUNCTIONS.
;
;      0(XS)                 STRING ARGUMENT
;      (WB)                  PCODE FOR ONE CHAR ARGUMENT
;      (XL)                  PCODE FOR MULTI-CHAR ARGUMENT
;      (WC)                  PCODE FOR EXPRESSION ARGUMENT
;      JSR  PATST            CALL TO BUILD NODE
;      PPM  LOC              TRANSFER LOC IF NOT STRING OR EXPR
;      (XS)                  POPPED PAST STRING ARGUMENT
;      (XR)                  POINTER TO CONSTRUCTED NODE
;      (XL)                  DESTROYED
;      (WA,WB,WC,RA)         DESTROYED
;
;      NOTE THAT THERE IS A SPECIAL CALL TO PATST IN THE EVALS
;      PROCEDURE WITH A SLIGHTLY DIFFERENT FORM. SEE EVALS
;      FOR DETAILS OF THE FORM OF THIS CALL.
;
	.ENABLE	LOCAL_BLOCK
PATST::	MOVL	(SP)+,PATST_SAVE;ENTRY POINT
	.SAVE_PSECT LOCAL_BLOCK
	.PSECT	PRC_SAVE,NOEXE
PATST_SAVE::.LONG	0
	.RESTORE_PSECT
	JSB	GTSTG		;CONVERT ARGUMENT AS STRING
	.ADDRESS PATS7		;JUMP IF NOT STRING
	CMPL	R6,#NUM01	;JUMP IF NOT ONE CHAR STRING
	BNEQU	PATS2
;
;      HERE FOR ONE CHAR STRING CASE
;
	TSTL	R7		;TREAT AS MULTI-CHAR IF EVALS CALL
	BEQLU	PATS2
	MOVAB	CFP$F(R9),R9	;POINT TO CHARACTER
	MOVZBL	(R9),R9		;LOAD CHARACTER
;
;      COMMON EXIT POINT AFTER SUCCESSFUL CONSTRUCTION
;
PATS1::	JSB	PBILD		;CALL ROUTINE TO BUILD NODE
	ADDL3	#4*1,PATST_SAVE,R11 ;RETURN TO PATST CALLER
	JMP	(R11)
	.PAGE
;
;      PATST (CONTINUED)
;
;      HERE FOR MULTI-CHARACTER STRING CASE
;
PATS2::	MOVL	R10,-(SP)	;SAVE MULTI-CHAR PCODE
	MOVL	R9,-(SP)	;SAVE STRING POINTER
	MOVL	CTMSK,R8	;LOAD CURRENT MASK BIT
	ASHL	#1,R8,R8		;SHIFT TO NEXT POSITION
	TSTL	R8		;SKIP IF POSITION LEFT IN THIS TBL
	BNEQU	PATS4
;
;      HERE WE MUST ALLOCATE A NEW CHARACTER TABLE
;
	MOVL	#4*CTSI$,R6	;SET SIZE OF CTBLK
	JSB	ALLOC		;ALLOCATE CTBLK
	MOVL	R9,R$CTP	;STORE PTR TO NEW CTBLK
	MOVL	#B$CTT,(R9)+	;STORE TYPE CODE, BUMP PTR
	MOVL	#CFP$A,R7	;SET NUMBER OF WORDS TO CLEAR
	MOVL	BITS0,R8	;LOAD ALL ZERO BITS
;
;      LOOP TO CLEAR ALL BITS IN TABLE TO ZEROS
;
PATS3::	MOVL	R8,(R9)+	;MOVE WORD OF ZERO BITS
	SOBGTR	R7,PATS3	;LOOP TILL ALL CLEARED
	MOVL	BITS1,R8	;SET INITIAL BIT POSITION
;
;      MERGE HERE WITH BIT POSITION AVAILABLE
;
PATS4::	MOVL	R8,CTMSK	;SAVE PARM2 (NEW BIT POSITION)
	MOVL	(SP)+,R10	;RESTORE POINTER TO ARGUMENT STRING
	MOVL	4*SCLEN(R10),R7	;LOAD STRING LENGTH
	TSTL	R7		;JUMP IF NULL STRING CASE
	BEQLU	PATS6
				;ELSE SET LOOP COUNTER
	MOVAB	CFP$F(R10),R10	;POINT TO CHARACTERS IN ARGUMENT
	.PAGE
;
;      PATST (CONTINUED)
;
;      LOOP TO SET BITS IN COLUMN OF TABLE
;
PATS5::	MOVZBL	(R10)+,R6	;LOAD NEXT CHARACTER
	MOVAL	0[R6],R6	;CONVERT TO BYTE OFFSET
	MOVL	R$CTP,R9	;POINT TO CTBLK
	ADDL2	R6,R9		;POINT TO CTBLK ENTRY
	MOVL	R8,R6		;COPY BIT MASK
	BISL2	4*CTCHS(R9),R6	;OR IN BITS ALREADY SET
	MOVL	R6,4*CTCHS(R9)	;STORE RESULTING BIT STRING
	SOBGTR	R7,PATS5	;LOOP TILL ALL BITS SET
;
;      COMPLETE PROCESSING FOR MUTI-CHAR STRING CASE
;
PATS6::	MOVL	R$CTP,R9	;LOAD CTBLK PTR AS PARM1 FOR PBILD
	CLRL	R10		;CLEAR GARBAGE PTR IN XL
	MOVL	(SP)+,R7	;LOAD PCODE FOR MULTI-CHAR STR CASE
	JMP	PATS1		;BACK TO EXIT (WC=BITSTRING=PARM2)
;
;      HERE IF ARGUMENT IS NOT A STRING
;
;      NOTE THAT THE CALL FROM EVALS CANNOT PASS AN EXPRESSION
;      SINCE EVALP ALWAYS REEVALUATES EXPRESSIONS.
;
PATS7::	MOVL	R8,R7		;SET PCODE FOR EXPRESSION ARGUMENT
	CMPL	(R9),#B$E$$	;JUMP TO EXIT IF EXPRESSION ARG
	BGTRU	5222$
	JMP	PATS1
5222$:
	MOVL	PATST_SAVE,R11	;ELSE TAKE WRONG TYPE ERROR EXIT
	JMP	@(R11)+
	;ENP			;END PROCEDURE PATST
	.PAGE
;
;      PBILD -- BUILD PATTERN NODE
;
;      (XR)                  PARM1 (ONLY IF REQUIRED)
;      (WB)                  PCODE FOR NODE
;      (WC)                  PARM2 (ONLY IF REQUIRED)
;      JSR  PBILD            CALL TO BUILD NODE
;      (XR)                  POINTER TO CONSTRUCTED NODE
;      (WA)                  DESTROYED
;
	.ENABLE	LOCAL_BLOCK
PBILD::	;PRC			;ENTRY POINT
	MOVL	R9,-(SP)	;STACK POSSIBLE PARM1
	MOVL	R7,R9		;COPY PCODE
	MOVZWL	-2(R9),R9	;LOAD ENTRY POINT ID (BL$PX)
	CMPL	R9,#BL$P1	;JUMP IF ONE PARAMETER
	BEQLU	PBLD1
	CMPL	R9,#BL$P0	;JUMP IF NO PARAMETERS
	BEQLU	PBLD3
;
;      HERE FOR TWO PARAMETER CASE
;
	MOVL	#4*PCSI$,R6	;SET SIZE OF P2BLK
	JSB	ALLOC		;ALLOCATE BLOCK
	MOVL	R8,4*PARM2(R9)	;STORE SECOND PARAMETER
	JMP	PBLD2		;MERGE WITH ONE PARM CASE
;
;      HERE FOR ONE PARAMETER CASE
;
PBLD1::	MOVL	#4*PBSI$,R6	;SET SIZE OF P1BLK
	JSB	ALLOC		;ALLOCATE NODE
;
;      MERGE HERE FROM TWO PARM CASE
;
PBLD2::	MOVL	(SP),4*PARM1(R9);STORE FIRST PARAMETER
	JMP	PBLD4		;MERGE WITH NO PARAMETER CASE
;
;      HERE FOR CASE OF NO PARAMETERS
;
PBLD3::	MOVL	#4*PASI$,R6	;SET SIZE OF P0BLK
	JSB	ALLOC		;ALLOCATE NODE
;
;      MERGE HERE FROM OTHER CASES
;
PBLD4::	MOVL	R7,(R9)		;STORE PCODE
	ADDL2	#4,SP		;POP FIRST PARAMETER
	MOVL	#NDNTH,4*PTHEN(R9) ;SET NOTHEN SUCCESSOR POINTER
	RSB			;RETURN TO PBILD CALLER
	;ENP			;END PROCEDURE PBILD
	.PAGE
;
;      PCONC -- CONCATENATE TWO PATTERNS
;
;      (XL)                  PTR TO RIGHT PATTERN
;      (XR)                  PTR TO LEFT PATTERN
;      JSR  PCONC            CALL TO CONCATENATE PATTERNS
;      (XR)                  PTR TO CONCATENATED PATTERN
;      (XL,WA,WB,WC)         DESTROYED
;
;
;      TO CONCATENATE TWO PATTERNS, ALL SUCCESSORS IN THE LEFT
;      PATTERN WHICH POINT TO THE NOTHEN NODE MUST BE CHANGED TO
;      POINT TO THE RIGHT PATTERN. HOWEVER, THIS MODIFICATION
;      MUST BE PERFORMED ON A COPY OF THE LEFT ARGUMENT RATHER
;      THAN THE LEFT ARGUMENT ITSELF, SINCE THE LEFT ARGUMENT
;      MAY BE POINTED TO BY SOME OTHER VARIABLE VALUE.
;
;      ACCORDINGLY, IT IS NECESSARY TO COPY THE LEFT ARGUMENT.
;      THIS IS NOT A TRIVIAL PROCESS SINCE WE MUST AVOID COPYING
;      NODES MORE THAN ONCE AND THE PATTERN IS A GRAPH STRUCTURE
;      THE FOLLOWING ALGORITHM IS EMPLOYED.
;
;      THE STACK IS USED TO STORE A LIST OF NODES WHICH
;      HAVE ALREADY BEEN COPIED. THE FORMAT OF THE ENTRIES ON
;      THIS LIST CONSISTS OF A TWO WORD BLOCK. THE FIRST WORD
;      IS THE OLD ADDRESS AND THE SECOND WORD IS THE ADDRESS
;      OF THE COPY. THIS LIST IS SEARCHED BY THE PCOPY
;      ROUTINE TO AVOID MAKING DUPLICATE COPIES. A TRICK IS
;      USED TO ACCOMPLISH THE CONCATENATION AT THE SAME TIME.
;      A SPECIAL ENTRY IS MADE TO START WITH ON THE STACK. THIS
;      ENTRY RECORDS THAT THE NOTHEN NODE HAS BEEN COPIED
;      ALREADY AND THE ADDRESS OF ITS COPY IS THE RIGHT PATTERN.
;      THIS AUTOMATICALLY PERFORMS THE CORRECT REPLACEMENTS.
;
	.ENABLE	LOCAL_BLOCK
PCONC::	;PRC			;ENTRY POINT
	CLRL	-(SP)		;MAKE ROOM FOR ONE ENTRY AT BOTTOM
	MOVL	SP,R8		;STORE POINTER TO START OF LIST
	MOVL	#NDNTH,-(SP)	;STACK NOTHEN NODE AS OLD NODE
	MOVL	R10,-(SP)	;STORE RIGHT ARG AS COPY OF NOTHEN
	MOVL	SP,R10		;INITIALIZE POINTER TO STACK ENTRIES
	JSB	PCOPY		;COPY FIRST NODE OF LEFT ARG
	MOVL	R6,4*2(R10)	;STORE AS RESULT UNDER LIST
	.PAGE
;
;      PCONC (CONTINUED)
;
;      THE FOLLOWING LOOP SCANS ENTRIES IN THE LIST AND MAKES
;      SURE THAT THEIR SUCCESSORS HAVE BEEN COPIED.
;
PCNC1::	CMPL	R10,SP		;JUMP IF ALL ENTRIES PROCESSED
	BEQLU	PCNC2
	MOVL	-(R10),R9	;ELSE LOAD NEXT OLD ADDRESS
	MOVL	4*PTHEN(R9),R9	;LOAD POINTER TO SUCCESSOR
	JSB	PCOPY		;COPY SUCCESSOR NODE
	MOVL	-(R10),R9	;LOAD POINTER TO NEW NODE (COPY)
	MOVL	R6,4*PTHEN(R9)	;STORE PTR TO NEW SUCCESSOR
;
;      NOW CHECK FOR SPECIAL CASE OF ALTERNATION NODE WHERE
;      PARM1 POINTS TO A NODE AND MUST BE COPIED LIKE PTHEN.
;
	CMPL	(R9),#P$ALT	;LOOP BACK IF NOT
	BNEQU	PCNC1
	MOVL	4*PARM1(R9),R9	;ELSE LOAD POINTER TO ALTERNATIVE
	JSB	PCOPY		;COPY IT
	MOVL	(R10),R9	;RESTORE PTR TO NEW NODE
	MOVL	R6,4*PARM1(R9)	;STORE PTR TO COPIED ALTERNATIVE
	JMP	PCNC1		;LOOP BACK FOR NEXT ENTRY
;
;      HERE AT END OF COPY PROCESS
;
PCNC2::	MOVL	R8,SP		;RESTORE STACK POINTER
	MOVL	(SP)+,R9	;LOAD POINTER TO COPY
	RSB			;RETURN TO PCONC CALLER
	;ENP			;END PROCEDURE PCONC
	.PAGE
;
;      PCOPY -- COPY A PATTERN NODE
;
;      PCOPY IS CALLED FROM THE PCONC PROCEDURE TO COPY A SINGLE
;      PATTERN NODE. THE COPY IS ONLY CARRIED OUT IF THE NODE
;      HAS NOT BEEN COPIED ALREADY.
;
;      (XR)                  POINTER TO NODE TO BE COPIED
;      (XT)                  PTR TO CURRENT LOC IN COPY LIST
;      (WC)                  POINTER TO LIST OF COPIED NODES
;      JSR  PCOPY            CALL TO COPY A NODE
;      (WA)                  POINTER TO COPY
;      (WB,XR)               DESTROYED
;
	.ENABLE	LOCAL_BLOCK
PCOPY::	MOVL	(SP)+,PCOPY_SAVE;ENTRY POINT
	.SAVE_PSECT LOCAL_BLOCK
	.PSECT	PRC_SAVE,NOEXE
PCOPY_SAVE::.LONG	0
	.RESTORE_PSECT
	MOVL	R10,R7		;SAVE XT
	MOVL	R8,R10		;POINT TO START OF LIST
;
;      LOOP TO SEARCH LIST OF NODES COPIED ALREADY
;
PCOP1::	SUBL2	#4,R10		;POINT TO NEXT ENTRY ON LIST
	CMPL	R9,(R10)	;JUMP IF MATCH
	BEQLU	PCOP2
	SUBL2	#4,R10		;ELSE SKIP OVER COPIED ADDRESS
	CMPL	R10,SP		;LOOP BACK IF MORE TO TEST
	BNEQU	PCOP1
;
;      HERE IF NOT IN LIST, PERFORM COPY
;
	MOVL	(R9),R6		;LOAD FIRST WORD OF BLOCK
	JSB	BLKLN		;GET LENGTH OF BLOCK
	MOVL	R9,R10		;SAVE POINTER TO OLD NODE
	JSB	ALLOC		;ALLOCATE SPACE FOR COPY
	MOVL	R10,-(SP)	;STORE OLD ADDRESS ON LIST
	MOVL	R9,-(SP)	;STORE NEW ADDRESS ON LIST
	;CHK			;CHECK FOR STACK OVERFLOW
	MVW			;MOVE WORDS FROM OLD BLOCK TO COPY
	MOVL	(SP),R6		;LOAD POINTER TO COPY
	JMP	PCOP3		;JUMP TO EXIT
;
;      HERE IF WE FIND ENTRY IN LIST
;
PCOP2::	MOVL	-(R10),R6	;LOAD ADDRESS OF COPY FROM LIST
;
;      COMMON EXIT POINT
;
PCOP3::	MOVL	R7,R10		;RESTORE XT
	JMP	@PCOPY_SAVE	;RETURN TO PCOPY CALLER
	;ENP			;END PROCEDURE PCOPY
	.PAGE
	.IF NOT_EQUAL CNPF
	.IF_FALSE
;
;      PRFLR -- PRINT PROFILE
;      PRFLR IS CALLED TO PRINT THE CONTENTS OF THE PROFILE
;      TABLE IN A FAIRLY READABLE TABULAR FORMAT.
;
;      JSR  PRFLR            CALL TO PRINT PROFILE
;      (WA,IA)               DESTROYED
;
	.ENABLE	LOCAL_BLOCK
PRFLR::	;PRC
	TSTL	PFDMP		;NO PRINTING IF NO PROFILING DONE
	BNEQU	5223$
	JMP	PRFL4
5223$:
	MOVL	R9,-(SP)	;PRESERVE ENTRY XR
	MOVL	R7,PFSVW	;AND ALSO WB
	JSB	PRTPG		;EJECT
	MOVL	#PFMS1,R9	;LOAD MSG /PROGRAM PROFILE/
	JSB	PRTST		;AND PRINT IT
	JSB	PRTNL		;FOLLOWED BY NEWLINE
	JSB	PRTNL		;AND ANOTHER
	MOVL	#PFMS2,R9	;POINT TO FIRST HDR
	JSB	PRTST		;PRINT IT
	JSB	PRTNL		;NEW LINE
	MOVL	#PFMS3,R9	;SECOND HDR
	JSB	PRTST		;PRINT IT
	JSB	PRTNL		;NEW LINE
	JSB	PRTNL		;AND ANOTHER BLANK LINE
	CLRL	R7		;INITIAL STMT COUNT
	MOVL	PFTBL,R9	;POINT TO TABLE ORIGIN
	ADDL2	#4*NUM02,R9	;BIAS PAST XNBLK HEADER [SGD07]
;
;      LOOP HERE TO PRINT SUCCESSIVE ENTRIES
;
PRFL1::	INCL	R7		;BUMP STMT NR
	MOVL	(R9),R5		;LOAD NR OF EXECUTIONS
	BEQL	PRFL3
	MOVL	#PFPD1,PROFS	;POINT WHERE TO PRINT
	JSB	PRTIN		;AND PRINT IT
	CLRL	PROFS		;BACK TO START OF LINE
	MOVL	R7,R5		;LOAD STMT NR
	JSB	PRTIN		;PRINT IT THERE
	MOVL	#PFPD2,PROFS	;AND PAD PAST COUNT
	MOVL	4*CFP$I(R9),R5	;LOAD TOTAL EXEC TIME
	JSB	PRTIN		;PRINT THAT TOO
	MOVL	4*CFP$I(R9),R5	;RELOAD TIME
	MULL2	INTTH,R5	;CONVERT TO MICROSEC
	BVS	PRFL2
	DIVL2	(R9),R5		;DIVIDE BY EXECUTIONS
	MOVL	#PFPD3,PROFS	;PAD LAST PRINT
	JSB	PRTIN		;AND PRINT MCSEC/EXECN
;
;      MERGE AFTER PRINTING TIME
;
PRFL2::	JSB	PRTNL		;THATS ANOTHER LINE
;
;      HERE TO GO TO NEXT ENTRY
;
PRFL3::	ADDL2	#4*PF$I2,R9	;BUMP INDEX PTR [SGD07]
	CMPL	R7,PFNTE	;LOOP IF MORE STMTS
	BLSSU	PRFL1
	MOVL	(SP)+,R9	;RESTORE CALLERS XR
	MOVL	PFSVW,R7	;AND WB TOO
;
;      HERE TO EXIT
;
PRFL4::	RSB			;RETURN
	;ENP			;END OF PRFLR
	.PAGE
;
;      PRFLU -- UPDATE AN ENTRY IN THE PROFILE TABLE
;
;      ON ENTRY, KVSTN CONTAINS NR OF STMT TO PROFILE
;
;      JSR  PRFLU            CALL TO UPDATE ENTRY
;      (IA)                  DESTROYED
;
	.ENABLE	LOCAL_BLOCK
PRFLU::	;PRC
	TSTL	PFFNC		;SKIP IF JUST ENTERED FUNCTION
	BEQLU	5224$
	JMP	PFLU4
5224$:
	MOVL	R9,-(SP)	;PRESERVE ENTRY XR
	MOVL	R6,PFSVW	;SAVE WA [SGD07]
	TSTL	PFTBL		;BRANCH IF TABLE ALLOCATED
	BNEQU	PFLU2
;
;      HERE IF SPACE FOR PROFILE TABLE NOT YET ALLOCATED.
;      CALCULATE SIZE NEEDED, ALLOCATE A STATIC XNBLK, AND
;      INITIALIZE IT ALL TO ZERO.
;      THE TIME TAKEN FOR THIS WILL BE ATTRIBUTED TO THE CURRENT
;      STATEMENT (ASSIGNMENT TO KEYWD PROFILE), BUT SINCE THE
;      TIMING FOR THIS STATEMENT IS UP THE POLE ANYWAY, THIS
;      DOESNT REALLY MATTER...
;
	SUBL2	#NUM01,PFNTE	;ADJUST FOR EXTRA COUNT (END OK) [SGD07]
	MOVL	PFI2A,R5	;CONVRT ENTRY SIZE TO INT
	MOVL	R5,PFSTE	;AND STORE SAFELY FOR LATER
	MOVL	PFNTE,R5	;LOAD TABLE LENGTH AS INTEGER
	MULL2	PFSTE,R5	;MULTIPLY BY ENTRY SIZE
	MFI	R6		;GET BACK ADDRESS-STYLE
	ADDL2	#NUM02,R6	;ADD ON 2 WORD OVERHEAD
	MOVAL	0[R6],R6	;CONVERT THE WHOLE LOT TO BYTES
	JSB	ALOST		;GIMME THE SPACE
	MOVL	R9,PFTBL	;SAVE BLOCK POINTER
	MOVL	#B$XNT,(R9)+	;PUT BLOCK TYPE AND ...
	MOVL	R6,(R9)+	;... LENGTH INTO HEADER
	MFI	R6		;GET BACK NR OF WDS IN DATA AREA
				;LOAD THE COUNTER
;
;      LOOP HERE TO ZERO THE BLOCK DATA
;
PFLU1::	CLRL	(R9)+		;BLANK A WORD
	SOBGTR	R6,PFLU1	;AND ALLLLLLL THE REST
;
;      END OF ALLOCATION. MERGE BACK INTO ROUTINE
;
PFLU2::	MOVL	KVSTN,R5	;LOAD NR OF STMT JUST ENDED
	SUBL2	INTV1,R5	;MAKE INTO INDEX OFFSET
	MULL2	PFSTE,R5	;MAKE OFFSET OF TABLE ENTRY
	MFI	R6		;CONVERT TO ADDRESS
	MOVAL	0[R6],R6	;GET AS BAUS
	ADDL2	#4*NUM02,R6	;OFFSET INCLUDES TABLE HEADER
	MOVL	PFTBL,R9	;GET TABLE START
	CMPL	R6,4*NUM01(R9)	;IF OUT OF TABLE, SKIP IT
	BGEQU	PFLU3
	ADDL2	R6,R9		;ELSE POINT TO ENTRY
	MOVL	(R9),R5		;GET NR OF EXECUTIONS SO FAR
	ADDL2	INTV1,R5	;NUDGE UP ONE
	MOVL	R5,(R9)		;AND PUT BACK
	JSB	SYSTM		;GET TIME NOW
	MOVL	R5,PFETM	;STASH ENDING TIME
	SUBL2	PFSTM,R5	;SUBTRACT START TIME
	ADDL2	4*CFP$I(R9),R5	;ADD CUMULATIVE TIME SO FAR
	MOVL	R5,4*CFP$I(R9)	;AND PUT BACK NEW TOTAL
	MOVL	PFETM,R5	;LOAD END TIME OF THIS STMT ...
	MOVL	R5,PFSTM	;... WHICH IS START TIME OF NEXT
;
;      MERGE HERE TO EXIT
;
PFLU3::	MOVL	(SP)+,R9	;RESTORE CALLERS XR
	MOVL	PFSVW,R6	;RESTORE SAVED REG
	RSB			;AND RETURN
;
;      HERE IF PROFILE IS SUPPRESSED BECAUSE A PROGRAM DEFINED
;      FUNCTION IS ABOUT TO BE ENTERED, AND SO THE CURRENT STMT
;      HAS NOT YET FINISHED
;
PFLU4::	CLRL	PFFNC		;RESET THE CONDITION FLAG
	RSB			;AND IMMEDIATE RETURN
	;ENP			;END OF PROCEDURE PRFLU
	.PAGE
	.ENDC
;
;      PRPAR - PROCESS PRINT PARAMETERS
;
;      (WC)                  IF NONZERO ASSOCIATE TERMINAL ONLY
;      JSR  PRPAR            CALL TO PROCESS PRINT PARAMETERS
;      (XL,XR,WA,WB,WC)      DESTROYED
;
;      SINCE MEMORY ALLOCATION IS UNDECIDED ON INITIAL CALL,
;      TERMINAL CANNOT BE ASSOCIATED. THE ENTRY WITH WC NON-ZERO
;      IS PROVIDED SO A LATER CALL CAN BE MADE TO COMPLETE THIS.
;
	.ENABLE	LOCAL_BLOCK
PRPAR::	;PRC			;ENTRY POINT
	TSTL	R8		;JUMP TO ASSOCIATE TERMINAL
	BEQLU	5225$
	JMP	PRPA7
5225$:
	JSB	SYSPP		;GET PRINT PARAMETERS
	TSTL	R7		;JUMP IF LINES/PAGE SPECIFIED
	BNEQU	PRPA1
	MOVL	#CFP$M,R7	;ELSE USE A LARGE VALUE
	ASHL	#-1,R7,R7	;BUT NOT TOO LARGE
;
;      STORE LINE COUNT/PAGE
;
PRPA1::	MOVL	R7,LSTNP	;STORE NUMBER OF LINES/PAGE
	MOVL	R7,LSTLC	;PRETEND PAGE IS FULL INITIALLY
	CLRL	LSTPG		;CLEAR PAGE NUMBER
	MOVL	PRLEN,R7	;GET PRIOR LENGTH IF ANY
	BEQLU	PRPA2
	CMPL	R6,R7		;SKIP STORING IF TOO BIG
	BGTRU	PRPA3
;
;      STORE PRINT BUFFER LENGTH
;
PRPA2::	MOVL	R6,PRLEN	;STORE VALUE
;
;      PROCESS BITS OPTIONS
;
PRPA3::	MOVL	BITS3,R7	;BIT 3 MASK
	MCOML	R8,R11		;GET -NOLIST BIT
	BICL2	R11,R7
	BEQLU	PRPA4
	CLRL	CSWLS		;SET -NOLIST
;
;      CHECK IF FAIL REPORTS GOTO INTERACTIVE CHANNEL
;
PRPA4::	MOVL	BITS1,R7	;BIT 1 MASK
	MCOML	R8,R11		;GET BIT
	BICL2	R11,R7
	MOVL	R7,ERICH	;STORE INT. CHAN. ERROR FLAG
	MOVL	BITS2,R7	;BIT 2 MASK
	MCOML	R8,R11		;GET BIT
	BICL2	R11,R7
	MOVL	R7,PRICH	;FLAG FOR STD PRINTER ON INT. CHAN.
	MOVL	BITS4,R7	;BIT 4 MASK
	MCOML	R8,R11		;GET BIT
	BICL2	R11,R7
	MOVL	R7,CPSTS	;FLAG FOR COMPILE STATS SUPPRESSN.
	MOVL	BITS5,R7	;BIT 5 MASK
	MCOML	R8,R11		;GET BIT
	BICL2	R11,R7
	MOVL	R7,EXSTS	;FLAG FOR EXEC STATS SUPPRESSION
	.PAGE
;
;      PRPAR (CONTINUED)
;
	MOVL	BITS6,R7	;BIT 6 MASK
	MCOML	R8,R11		;GET BIT
	BICL2	R11,R7
	MOVL	R7,PRECL	;EXTENDED/COMPACT LISTING FLAG
	SUBL2	#NUM08,R6	;POINT 8 CHARS FROM LINE END
	TSTL	R7		;JUMP IF NOT EXTENDED
	BEQLU	PRPA5
	MOVL	R6,LSTPO	;STORE FOR LISTING PAGE HEADINGS
;
;       CONTINUE OPTION PROCESSING
;
PRPA5::	MOVL	BITS7,R7	;BIT 7 MASK
	MCOML	R8,R11		;GET BIT 7
	BICL2	R11,R7
	MOVL	R7,CSWEX	;SET -NOEXECUTE IF NON-ZERO
	MOVL	BIT10,R7	;BIT 10 MASK
	MCOML	R8,R11		;GET BIT 10
	BICL2	R11,R7
	MOVL	R7,HEADP	;PRETEND PRINTED TO OMIT HEADERS
	MOVL	BITS9,R7	;BIT 9 MASK
	MCOML	R8,R11		;GET BIT 9
	BICL2	R11,R7
	MOVL	R7,PRSTO	;KEEP IT AS STD LISTING OPTION
	TSTL	R7		;SKIP IF CLEAR
	BEQLU	PRPA6
	MOVL	PRLEN,R6	;GET PRINT BUFFER LENGTH
	SUBL2	#NUM08,R6	;POINT 8 CHARS FROM LINE END
	MOVL	R6,LSTPO	;STORE PAGE OFFSET
;
;      CHECK FOR TERMINAL
;
PRPA6::	MCOML	BITS8,R11	;SEE IF TERMINAL TO BE ACTIVATED
	BICL2	R11,R8
	BEQLU	5226$
	JMP	PRPA7
5226$:
	TSTL	INITR		;JUMP IF NO TERMINAL TO DETACH
	BEQLU	PRPA8
	MOVL	#V$TER,R10	;PTR TO /TERMINAL/
	JSB	GTNVR		;GET VRBLK POINTER
	.ADDRESS INVALID$	;CANT FAIL
	MOVL	#NULLS,4*VRVAL(R9) ;CLEAR VALUE OF TERMINAL
	JSB	SETVR		;REMOVE ASSOCIATION
	JMP	PRPA8		;RETURN
;
;      ASSOCIATE TERMINAL
;
PRPA7::	MOVL	SP,INITR	;NOTE TERMINAL ASSOCIATED
	TSTL	DNAMB		;CANT IF MEMORY NOT ORGANISED
	BEQLU	PRPA8
	MOVL	#V$TER,R10	;POINT TO TERMINAL STRING
	MOVL	#TRTOU,R7	;OUTPUT TRACE TYPE
	JSB	INOUT		;ATTACH OUTPUT TRBLK TO VRBLK
	MOVL	R9,-(SP)	;STACK TRBLK PTR
	MOVL	#V$TER,R10	;POINT TO TERMINAL STRING
	MOVL	#TRTIN,R7	;INPUT TRACE TYPE
	JSB	INOUT		;ATTACH INPUT TRACE BLK
	MOVL	(SP)+,4*VRVAL(R9);ADD OUTPUT TRBLK TO CHAIN
;
;      RETURN POINT
;
PRPA8::	RSB			;RETURN
	;ENP			;END PROCEDURE PRPAR
	.PAGE
;
;      PRTCH -- PRINT A CHARACTER
;
;      PRTCH IS USED TO PRINT A SINGLE CHARACTER
;
;      (WA)                  CHARACTER TO BE PRINTED
;      JSR  PRTCH            CALL TO PRINT CHARACTER
;
	.ENABLE	LOCAL_BLOCK
PRTCH::	;PRC			;ENTRY POINT
	MOVL	R9,-(SP)	;SAVE XR
	CMPL	PROFS,PRLEN	;JUMP IF ROOM IN BUFFER
	BNEQU	PRCH1
	JSB	PRTNL		;ELSE PRINT THIS LINE
;
;      HERE AFTER MAKING SURE WE HAVE ROOM
;
PRCH1::	MOVL	PRBUF,R9	;POINT TO PRINT BUFFER
	MOVL	PROFS,R11	;[GET IN SCRATCH REGISTER]
	MOVAB	CFP$F(R9)[R11],R9;POINT TO NEXT CHARACTER LOCATION
	MOVB	R6,(R9)		;STORE NEW CHARACTER
	;CSC	R9		;COMPLETE STORE CHARACTERS
	INCL	PROFS		;BUMP POINTER
	MOVL	(SP)+,R9	;RESTORE ENTRY XR
	RSB			;RETURN TO PRTCH CALLER
	;ENP			;END PROCEDURE PRTCH
	.PAGE
;
;      PRTIC -- PRINT TO INTERACTIVE CHANNEL
;
;      PRTIC IS CALLED TO PRINT THE CONTENTS OF THE STANDARD
;      PRINT BUFFER TO THE INTERACTIVE CHANNEL. IT IS ONLY
;      CALLED AFTER PRTST HAS SET UP THE STRING FOR PRINTING.
;      IT DOES NOT CLEAR THE BUFFER.
;
;      JSR  PRTIC            CALL FOR PRINT
;      (WA,WB)               DESTROYED
;
	.ENABLE	LOCAL_BLOCK
PRTIC::	;PRC			;ENTRY POINT
	MOVL	R9,-(SP)	;SAVE XR
	MOVL	PRBUF,R9	;POINT TO BUFFER
	MOVL	PROFS,R6	;NO OF CHARS
	JSB	SYSPI		;PRINT
	.ADDRESS PRTC2		;FAIL RETURN
;
;      RETURN
;
PRTC1::	MOVL	(SP)+,R9	;RESTORE XR
	RSB			;RETURN
;
;      ERROR OCCURED
;
PRTC2::	CLRL	ERICH		;PREVENT LOOPING
	JMP	ERROR_252	;ERROR ON PRINTING TO INTERACTIVE CHANNEL
	JMP	PRTC1		;RETURN
	;ENP			;PROCEDURE PRTIC
	.PAGE
;
;      PRTIS -- PRINT TO INTERACTIVE AND STANDARD PRINTER
;
;      PRTIS PUTS A LINE FROM THE PRINT BUFFER ONTO THE
;      INTERACTIVE CHANNEL (IF ANY) AND THE STANDARD PRINTER.
;      IT ALWAYS PRINTS TO THE STANDARD PRINTER BUT DOES
;      NOT DUPLICATE LINES IF THE STANDARD PRINTER IS
;      INTERACTIVE.  IT CLEARS DOWN THE PRINT BUFFER.
;
;      JSR  PRTIS            CALL FOR PRINTING
;      (WA,WB)               DESTROYED
;
	.ENABLE	LOCAL_BLOCK
PRTIS::	;PRC			;ENTRY POINT
	TSTL	PRICH		;JUMP IF STANDARD PRINTER IS INT.CH.
	BNEQU	PRTS1
	TSTL	ERICH		;SKIP IF NOT DOING INT. ERROR REPS.
	BEQLU	PRTS1
	JSB	PRTIC		;PRINT TO INTERACTIVE CHANNEL
;
;      MERGE AND EXIT
;
PRTS1::	JSB	PRTNL		;PRINT TO STANDARD PRINTER
	RSB			;RETURN
	;ENP			;END PROCEDURE PRTIS
	.PAGE
;
;      PRTIN -- PRINT AN INTEGER
;
;      PRTIN PRINTS THE INTEGER VALUE WHICH IS IN THE INTEGER
;      ACCUMULATOR. BLOCKS BUILT IN DYNAMIC STORAGE
;      DURING THIS PROCESS ARE IMMEDIATELY DELETED.
;
;      (IA)                  INTEGER VALUE TO BE PRINTED
;      JSR  PRTIN            CALL TO PRINT INTEGER
;      (IA,RA)               DESTROYED
;
	.ENABLE	LOCAL_BLOCK
PRTIN::	;PRC			;ENTRY POINT
	MOVL	R9,-(SP)	;SAVE XR
	JSB	ICBLD		;BUILD INTEGER BLOCK
	CMPL	R9,DNAMB	;JUMP IF ICBLK BELOW DYNAMIC
	BLEQU	PRTI1
	CMPL	R9,DNAMP	;JUMP IF ABOVE DYNAMIC
	BGEQU	PRTI1
	MOVL	R9,DNAMP	;IMMEDIATELY DELETE IT
;
;      DELETE ICBLK FROM DYNAMIC STORE
;
PRTI1::	MOVL	R9,-(SP)	;STACK PTR FOR GTSTG
	JSB	GTSTG		;CONVERT TO STRING
	.ADDRESS INVALID$	;CONVERT ERROR IS IMPOSSIBLE
	MOVL	R9,DNAMP	;RESET POINTER TO DELETE SCBLK
	JSB	PRTST		;PRINT INTEGER STRING
	MOVL	(SP)+,R9	;RESTORE ENTRY XR
	RSB			;RETURN TO PRTIN CALLER
	;ENP			;END PROCEDURE PRTIN
	.PAGE
;
;      PRTMI -- PRINT MESSAGE AND INTEGER
;
;      PRTMI IS USED TO PRINT MESSAGES TOGETHER WITH AN INTEGER
;      VALUE STARTING IN COLUMN 15 (USED BY THE ROUTINES AT
;      THE END OF COMPILATION).
;
;      JSR  PRTMI            CALL TO PRINT MESSAGE AND INTEGER
;
	.ENABLE	LOCAL_BLOCK
PRTMI::	;PRC			;ENTRY POINT
	JSB	PRTST		;PRINT STRING MESSAGE
	MOVL	#PRTMF,PROFS	;SET OFFSET TO COL 15
	JSB	PRTIN		;PRINT INTEGER
	JSB	PRTNL		;PRINT LINE
	RSB			;RETURN TO PRTMI CALLER
	;ENP			;END PROCEDURE PRTMI
	.PAGE
;
;      PRTMX  -- AS PRTMI WITH EXTRA COPY TO INTERACTIVE CHAN.
;
;      JSR  PRTMX            CALL FOR PRINTING
;      (WA,WB)               DESTROYED
;
	.ENABLE	LOCAL_BLOCK
PRTMX::	;PRC			;ENTRY POINT
	JSB	PRTST		;PRINT STRING MESSAGE
	MOVL	#PRTMF,PROFS	;SET PTR TO COLUMN 15
	JSB	PRTIN		;PRINT INTEGER
	JSB	PRTIS		;PRINT LINE
	RSB			;RETURN
	;ENP			;END PROCEDURE PRTMX
	.PAGE
;
;      PRTNL -- PRINT NEW LINE (END PRINT LINE)
;
;      PRTNL PRINTS THE CONTENTS OF THE PRINT BUFFER, RESETS
;      THE BUFFER TO ALL BLANKS AND RESETS THE PRINT POINTER.
;
;      JSR  PRTNL            CALL TO PRINT LINE
;
	.ENABLE	LOCAL_BLOCK
PRTNL::	;PRC			;ENTRY POINT
	TSTL	HEADP		;WERE HEADERS PRINTED
	BNEQU	PRNL0
	JSB	PRTPS		;NO - PRINT THEM
;
;      CALL SYSPR
;
PRNL0::	MOVL	R9,-(SP)	;SAVE ENTRY XR
	MOVL	R6,PRTSA	;SAVE WA
	MOVL	R7,PRTSB	;SAVE WB
	MOVL	PRBUF,R9	;LOAD POINTER TO BUFFER
	MOVL	PROFS,R6	;LOAD NUMBER OF CHARS IN BUFFER
	JSB	SYSPR		;CALL SYSTEM PRINT ROUTINE
	.ADDRESS PRNL2		;JUMP IF FAILED
	MOVL	PRLNW,R6	;LOAD LENGTH OF BUFFER IN WORDS
	ADDL2	#4*SCHAR,R9	;POINT TO CHARS OF BUFFER
	MOVL	NULLW,R7	;GET WORD OF BLANKS
;
;      LOOP TO BLANK BUFFER
;
PRNL1::	MOVL	R7,(R9)+	;STORE WORD OF BLANKS, BUMP PTR
	SOBGTR	R6,PRNL1	;LOOP TILL ALL BLANKED
;
;      EXIT POINT
;
	MOVL	PRTSB,R7	;RESTORE WB
	MOVL	PRTSA,R6	;RESTORE WA
	MOVL	(SP)+,R9	;RESTORE ENTRY XR
	CLRL	PROFS		;RESET PRINT BUFFER POINTER
	RSB			;RETURN TO PRTNL CALLER
;
;      FILE FULL OR NO OUTPUT FILE FOR LOAD MODULE
;
PRNL2::	TSTL	PRTEF		;JUMP IF NOT FIRST TIME
	BNEQU	PRNL3
	MOVL	SP,PRTEF	;MARK FIRST OCCURRENCE
	JMP	ERROR_253	;PRINT LIMIT EXCEEDED ON STANDARD OUTPUT CHANNEL
;
;      STOP AT ONCE
;
PRNL3::	MOVL	#NINI8,R7	;ENDING CODE
	MOVL	KVSTN,R6	;STATEMENT NUMBER
	JSB	SYSEJ		;STOP
	;ENP			;END PROCEDURE PRTNL
	.PAGE
;
;      PRTNM -- PRINT VARIABLE NAME
;
;      PRTNM IS USED TO PRINT A CHARACTER REPRESENTATION OF THE
;      NAME OF A VARIABLE (NOT A VALUE OF DATATYPE NAME)
;      NAMES OF PSEUDO-VARIABLES MAY NOT BE PASSED TO PRTNM.
;
;      (XL)                  NAME BASE
;      (WA)                  NAME OFFSET
;      JSR  PRTNM            CALL TO PRINT NAME
;      (WB,WC,RA)            DESTROYED
;
	.ENABLE	LOCAL_BLOCK
PRTNM::	;PRC			;ENTRY POINT (RECURSIVE, SEE PRTVL)
	MOVL	R6,-(SP)	;SAVE WA (OFFSET IS COLLECTABLE)
	MOVL	R9,-(SP)	;SAVE ENTRY XR
	MOVL	R10,-(SP)	;SAVE NAME BASE
	CMPL	R10,STATE	;JUMP IF NOT NATURAL VARIABLE
	BGEQU	PRN02
;
;      HERE FOR NATURAL VARIABLE NAME, RECOGNIZED BY THE FACT
;      THAT THE NAME BASE POINTS INTO THE STATIC AREA.
;
	MOVL	R10,R9		;POINT TO VRBLK
	JSB	PRTVN		;PRINT NAME OF VARIABLE
;
;      COMMON EXIT POINT
;
PRN01::	MOVL	(SP)+,R10	;RESTORE NAME BASE
	MOVL	(SP)+,R9	;RESTORE ENTRY VALUE OF XR
	MOVL	(SP)+,R6	;RESTORE WA
	RSB			;RETURN TO PRTNM CALLER
;
;      HERE FOR CASE OF NON-NATURAL VARIABLE
;
PRN02::	MOVL	R6,R7		;COPY NAME OFFSET
	CMPL	(R10),#B$PDT	;JUMP IF ARRAY OR TABLE
	BNEQU	PRN03
;
;      FOR PROGRAM DEFINED DATATYPE, PRT FLD NAME, LEFT PAREN
;
	MOVL	4*PDDFP(R10),R9	;LOAD POINTER TO DFBLK
	ADDL2	R6,R9		;ADD NAME OFFSET
	MOVL	4*PDFOF(R9),R9	;LOAD VRBLK POINTER FOR FIELD
	JSB	PRTVN		;PRINT FIELD NAME
	MOVL	#CH$PP,R6	;LOAD LEFT PAREN
	JSB	PRTCH		;PRINT CHARACTER
	.PAGE
;
;      PRTNM (CONTINUED)
;
;      NOW WE PRINT AN IDENTIFYING NAME FOR THE OBJECT IF ONE
;      CAN BE FOUND. THE FOLLOWING CODE SEARCHES FOR A NATURAL
;      VARIABLE WHICH CONTAINS THIS OBJECT AS VALUE. IF SUCH A
;      VARIABLE IS FOUND, ITS NAME IS PRINTED, ELSE THE VALUE
;      OF THE OBJECT (AS PRINTED BY PRTVL) IS USED INSTEAD.
;
;      FIRST WE POINT TO THE PARENT TBBLK IF THIS IS THE CASE OF
;      A TABLE ELEMENT. TO DO THIS, CHASE DOWN THE TRNXT CHAIN.
;
PRN03::	CMPL	(R10),#B$TET	;JUMP IF WE GOT THERE (OR NOT TE)
	BNEQU	PRN04
	MOVL	4*TENXT(R10),R10;ELSE MOVE OUT ON CHAIN
	JMP	PRN03		;AND LOOP BACK
;
;      NOW WE ARE READY FOR THE SEARCH. TO SPEED THINGS UP IN
;      THE CASE OF CALLS FROM DUMP WHERE THE SAME NAME BASE
;      WILL OCCUR REPEATEDLY WHILE DUMPING AN ARRAY OR TABLE,
;      WE REMEMBER THE LAST VRBLK POINTER FOUND IN PRNMV. SO
;      FIRST CHECK TO SEE IF WE HAVE THIS ONE AGAIN.
;
PRN04::	MOVL	PRNMV,R9	;POINT TO VRBLK WE FOUND LAST TIME
	MOVL	HSHTB,R6	;POINT TO HASH TABLE IN CASE NOT
	JMP	PRN07		;JUMP INTO SEARCH FOR SPECIAL CHECK
;
;      LOOP THROUGH HASH SLOTS
;
PRN05::	MOVL	R6,R9		;COPY SLOT POINTER
	ADDL2	#4,R6		;BUMP SLOT POINTER
	SUBL2	#4*VRNXT,R9	;INTRODUCE STANDARD VRBLK OFFSET
;
;      LOOP THROUGH VRBLKS ON ONE HASH CHAIN
;
PRN06::	MOVL	4*VRNXT(R9),R9	;POINT TO NEXT VRBLK ON HASH CHAIN
;
;      MERGE HERE FIRST TIME TO CHECK BLOCK WE FOUND LAST TIME
;
PRN07::	MOVL	R9,R8		;COPY VRBLK POINTER
	BEQLU	PRN09
	.PAGE
;
;      PRTNM (CONTINUED)
;
;      LOOP TO FIND VALUE (CHASE DOWN POSSIBLE TRBLK CHAIN)
;
PRN08::	MOVL	4*VRVAL(R9),R9	;LOAD VALUE
	CMPL	(R9),#B$TRT	;LOOP IF THAT WAS A TRBLK
	BEQLU	PRN08
;
;      NOW WE HAVE THE VALUE, IS THIS THE BLOCK WE WANT
;
	CMPL	R9,R10		;JUMP IF THIS MATCHES THE NAME BASE
	BEQLU	PRN10
	MOVL	R8,R9		;ELSE POINT BACK TO THAT VRBLK
	JMP	PRN06		;AND LOOP BACK
;
;      HERE TO MOVE TO NEXT HASH SLOT
;
PRN09::	CMPL	R6,HSHTE	;LOOP BACK IF MORE TO GO
	BLSSU	PRN05
	MOVL	R10,R9		;ELSE NOT FOUND, COPY VALUE POINTER
	JSB	PRTVL		;PRINT VALUE
	JMP	PRN11		;AND MERGE AHEAD
;
;      HERE WHEN WE FIND A MATCHING ENTRY
;
PRN10::	MOVL	R8,R9		;COPY VRBLK POINTER
	MOVL	R9,PRNMV	;SAVE FOR NEXT TIME IN
	JSB	PRTVN		;PRINT VARIABLE NAME
;
;      MERGE HERE IF NO ENTRY FOUND
;
PRN11::	MOVL	(R10),R8	;LOAD FIRST WORD OF NAME BASE
	CMPL	R8,#B$PDT	;JUMP IF NOT PROGRAM DEFINED
	BNEQU	PRN13
;
;      FOR PROGRAM DEFINED DATATYPE, ADD RIGHT PAREN AND EXIT
;
	MOVL	#CH$RP,R6	;LOAD RIGHT PAREN, MERGE
;
;      MERGE HERE TO PRINT FINAL RIGHT PAREN OR BRACKET
;
PRN12::	JSB	PRTCH		;PRINT FINAL CHARACTER
	MOVL	R7,R6		;RESTORE NAME OFFSET
	JMP	PRN01		;MERGE BACK TO EXIT
	.PAGE
;
;      PRTNM (CONTINUED)
;
;      HERE FOR ARRAY OR TABLE
;
PRN13::	MOVL	#CH$BB,R6	;LOAD LEFT BRACKET
	JSB	PRTCH		;AND PRINT IT
	MOVL	(SP),R10	;RESTORE BLOCK POINTER
	MOVL	(R10),R8	;LOAD TYPE WORD AGAIN
	CMPL	R8,#B$TET	;JUMP IF NOT TABLE
	BNEQU	PRN15
;
;      HERE FOR TABLE, PRINT SUBSCRIPT VALUE
;
	MOVL	4*TESUB(R10),R9	;LOAD SUBSCRIPT VALUE
	MOVL	R7,R10		;SAVE NAME OFFSET
	JSB	PRTVL		;PRINT SUBSCRIPT VALUE
	MOVL	R10,R7		;RESTORE NAME OFFSET
;
;      MERGE HERE FROM ARRAY CASE TO PRINT RIGHT BRACKET
;
PRN14::	MOVL	#CH$RB,R6	;LOAD RIGHT BRACKET
	JMP	PRN12		;MERGE BACK TO PRINT IT
;
;      HERE FOR ARRAY OR VECTOR, TO PRINT SUBSCRIPT(S)
;
PRN15::	MOVL	R7,R6		;COPY NAME OFFSET
	ASHL	#-2,R6,R6	;CONVERT TO WORDS
	CMPL	R8,#B$ART	;JUMP IF ARBLK
	BEQLU	PRN16
;
;      HERE FOR VECTOR
;
	SUBL2	#VCVLB,R6	;ADJUST FOR STANDARD FIELDS
	MOVL	R6,R5		;MOVE TO INTEGER ACCUM
	JSB	PRTIN		;PRINT LINEAR SUBSCRIPT
	JMP	PRN14		;MERGE BACK FOR RIGHT BRACKET
	.PAGE
;
;      PRTNM (CONTINUED)
;
;      HERE FOR ARRAY. FIRST CALCULATE ABSOLUTE SUBSCRIPT
;      OFFSETS BY SUCCESSIVE DIVISIONS BY THE DIMENSION VALUES.
;      THIS MUST BE DONE RIGHT TO LEFT SINCE THE ELEMENTS ARE
;      STORED ROW-WISE. THE SUBSCRIPTS ARE STACKED AS INTEGERS.
;
PRN16::	MOVL	4*AROFS(R10),R8	;LOAD LENGTH OF BOUNDS INFO
	ADDL2	#4,R8		;ADJUST FOR ARPRO FIELD
	ASHL	#-2,R8,R8	;CONVERT TO WORDS
	SUBL2	R8,R6		;GET LINEAR ZERO-ORIGIN SUBSCRIPT
	MOVL	R6,R5		;GET INTEGER VALUE
	MOVL	4*ARNDM(R10),R6	;SET NUM OF DIMENSIONS AS LOOP COUNT
	ADDL2	4*AROFS(R10),R10;POINT PAST BOUNDS INFORMATION
	SUBL2	#4*ARLBD,R10	;SET OK OFFSET FOR PROPER PTR LATER
;
;      LOOP TO STACK SUBSCRIPT OFFSETS
;
PRN17::	SUBL2	#4*ARDMS,R10	;POINT TO NEXT SET OF BOUNDS
	MOVL	R5,PRNSI	;SAVE CURRENT OFFSET
	RMI	4*ARDIM(R10)	;GET REMAINDER ON DIVIDING BY DIMENS
	MFI	-(SP)		;STORE ON STACK (ONE WORD)
	MOVL	PRNSI,R5	;RELOAD ARGUMENT
	DIVL2	4*ARDIM(R10),R5	;DIVIDE TO GET QUOTIENT
	SOBGTR	R6,PRN17	;LOOP TILL ALL STACKED
	CLRL	R9		;SET OFFSET TO FIRST SET OF BOUNDS
	MOVL	4*ARNDM(R10),R7	;LOAD COUNT OF DIMS TO CONTROL LOOP
	JMP	PRN19		;JUMP INTO PRINT LOOP
;
;      LOOP TO PRINT SUBSCRIPTS FROM STACK ADJUSTING BY ADDING
;      THE APPROPRIATE LOW BOUND VALUE FROM THE ARBLK
;
PRN18::	MOVL	#CH$CM,R6	;LOAD A COMMA
	JSB	PRTCH		;PRINT IT
;
;      MERGE HERE FIRST TIME IN (NO COMMA REQUIRED)
;
PRN19::	MOVL	(SP)+,R5	;LOAD SUBSCRIPT OFFSET AS INTEGER
	ADDL2	R9,R10		;POINT TO CURRENT LBD
	ADDL2	4*ARLBD(R10),R5	;ADD LBD TO GET SIGNED SUBSCRIPT
	SUBL2	R9,R10		;POINT BACK TO START OF ARBLK
	JSB	PRTIN		;PRINT SUBSCRIPT
	ADDL2	#4*ARDMS,R9	;BUMP OFFSET TO NEXT BOUNDS
	SOBGTR	R7,PRN18	;LOOP BACK TILL ALL PRINTED
	JMP	PRN14		;MERGE BACK TO PRINT RIGHT BRACKET
	;ENP			;END PROCEDURE PRTNM
	.PAGE
;
;      PRTNV -- PRINT NAME VALUE
;
;      PRTNV IS USED BY THE TRACE AND DUMP ROUTINES TO PRINT
;      A LINE OF THE FORM
;
;      NAME = VALUE
;
;      NOTE THAT THE NAME INVOLVED CAN NEVER BE A PSEUDO-VAR
;
;      (XL)                  NAME BASE
;      (WA)                  NAME OFFSET
;      JSR  PRTNV            CALL TO PRINT NAME = VALUE
;      (WB,WC,RA)            DESTROYED
;
	.ENABLE	LOCAL_BLOCK
PRTNV::	;PRC			;ENTRY POINT
	JSB	PRTNM		;PRINT ARGUMENT NAME
	MOVL	R9,-(SP)	;SAVE ENTRY XR
	MOVL	R6,-(SP)	;SAVE NAME OFFSET (COLLECTABLE)
	MOVL	#TMBEB,R9	;POINT TO BLANK EQUAL BLANK
	JSB	PRTST		;PRINT IT
	MOVL	R10,R9		;COPY NAME BASE
	ADDL2	R6,R9		;POINT TO VALUE
	MOVL	(R9),R9		;LOAD VALUE POINTER
	JSB	PRTVL		;PRINT VALUE
	JSB	PRTNL		;TERMINATE LINE
	MOVL	(SP)+,R6	;RESTORE NAME OFFSET
	MOVL	(SP)+,R9	;RESTORE ENTRY XR
	RSB			;RETURN TO CALLER
	;ENP			;END PROCEDURE PRTNV
	.PAGE
;
;      PRTPG  -- PRINT A PAGE THROW
;
;      PRINTS A PAGE THROW OR A FEW BLANK LINES ON THE STANDARD
;      LISTING CHANNEL DEPENDING ON THE LISTING OPTIONS CHOSEN.
;
;      JSR  PRTPG            CALL FOR PAGE EJECT
;
	.ENABLE	LOCAL_BLOCK
PRTPG::	;PRC			;ENTRY POINT
	CMPL	STAGE,#STGXT	;JUMP IF EXECUTION TIME
	BEQLU	PRP01
	TSTL	LSTLC		;RETURN IF TOP OF PAGE ALREADY
	BNEQU	5227$
	JMP	PRP06
5227$:
	CLRL	LSTLC		;CLEAR LINE COUNT
;
;      CHECK TYPE OF LISTING
;
PRP01::	MOVL	R9,-(SP)	;PRESERVE XR
	TSTL	PRSTD		;EJECT IF FLAG SET
	BNEQU	PRP02
	TSTL	PRICH		;JUMP IF INTERACTIVE LISTING CHANNEL
	BNEQU	PRP03
	TSTL	PRECL		;JUMP IF COMPACT LISTING
	BEQLU	PRP03
;
;      PERFORM AN EJECT
;
PRP02::	JSB	SYSEP		;EJECT
	JMP	PRP04		;MERGE
;
;      COMPACT OR INTERACTIVE CHANNEL LISTING. CANT PRINT
;      BLANKS UNTIL CHECK MADE FOR HEADERS PRINTED AND FLAG SET.
;
;
PRP03::	MOVL	HEADP,R9	;REMEMBER HEADP
	MOVL	SP,HEADP	;SET TO AVOID REPEATED PRTPG CALLS
	JSB	PRTNL		;PRINT BLANK LINE
	JSB	PRTNL		;PRINT BLANK LINE
	JSB	PRTNL		;PRINT BLANK LINE
	MOVL	#NUM03,LSTLC	;COUNT BLANK LINES
	MOVL	R9,HEADP	;RESTORE HEADER FLAG
	.PAGE
;
;      PRPTG (CONTINUED)
;
;      PRINT THE HEADING
;
PRP04::	TSTL	HEADP		;JUMP IF HEADER LISTED
	BNEQU	PRP05
	MOVL	SP,HEADP	;MARK HEADERS PRINTED
	MOVL	R10,-(SP)	;KEEP XL
	MOVL	#HEADR,R9	;POINT TO LISTING HEADER
	JSB	PRTST		;PLACE IT
	JSB	SYSID		;GET SYSTEM IDENTIFICATION
	JSB	PRTST		;APPEND EXTRA CHARS
	JSB	PRTNL		;PRINT IT
	MOVL	R10,R9		;EXTRA HEADER LINE
	JSB	PRTST		;PLACE IT
	JSB	PRTNL		;PRINT IT
	JSB	PRTNL		;PRINT A BLANK
	JSB	PRTNL		;AND ANOTHER
	ADDL2	#NUM04,LSTLC	;FOUR HEADER LINES PRINTED
	MOVL	(SP)+,R10	;RESTORE XL
;
;      MERGE IF HEADER NOT PRINTED
;
PRP05::	MOVL	(SP)+,R9	;RESTORE XR
;
;      RETURN
;
PRP06::	RSB			;RETURN
	;ENP			;END PROCEDURE PRTPG
	.PAGE
;
;      PRTPS - PRINT PAGE WITH TEST FOR STANDARD LISTING OPTION
;
;      IF THE STANDARD LISTING OPTION IS SELECTED, INSIST THAT
;      AN EJECT BE DONE
;
;      JSR  PRTPS            CALL FOR EJECT
;
	.ENABLE	LOCAL_BLOCK
PRTPS::	;PRC			;ENTRY POINT
	MOVL	PRSTO,PRSTD	;COPY OPTION FLAG
	JSB	PRTPG		;PRINT PAGE
	CLRL	PRSTD		;CLEAR FLAG
	RSB			;RETURN
	;ENP			;END PROCEDURE PRTPS
	.PAGE
;
;      PRTSN -- PRINT STATEMENT NUMBER
;
;      PRTSN IS USED TO INITIATE A PRINT TRACE LINE BY PRINTING
;      ASTERISKS AND THE CURRENT STATEMENT NUMBER. THE ACTUAL
;      FORMAT OF THE OUTPUT GENERATED IS.
;
;      ***NNNNN**** III.....IIII
;
;      NNNNN IS THE STATEMENT NUMBER WITH LEADING ZEROS REPLACED
;      BY ASTERISKS (E.G. *******9****)
;
;      III...III REPRESENTS A VARIABLE LENGTH OUTPUT CONSISTING
;      OF A NUMBER OF LETTER I CHARACTERS EQUAL TO FNCLEVEL.
;
;      JSR  PRTSN            CALL TO PRINT STATEMENT NUMBER
;      (WC)                  DESTROYED
;
	.ENABLE	LOCAL_BLOCK
PRTSN::	;PRC			;ENTRY POINT
	MOVL	R9,-(SP)	;SAVE ENTRY XR
	MOVL	R6,PRSNA	;SAVE ENTRY WA
	MOVL	#TMASB,R9	;POINT TO ASTERISKS
	JSB	PRTST		;PRINT ASTERISKS
	MOVL	#NUM04,PROFS	;POINT INTO MIDDLE OF ASTERISKS
	MOVL	KVSTN,R5	;LOAD STATEMENT NUMBER AS INTEGER
	JSB	PRTIN		;PRINT INTEGER STATEMENT NUMBER
	MOVL	#PRSNF,PROFS	;POINT PAST ASTERISKS PLUS BLANK
	MOVL	KVFNC,R9	;GET FNCLEVEL
	MOVL	#CH$LI,R6	;SET LETTER I
;
;      LOOP TO GENERATE LETTER I FNCLEVEL TIMES
;
PRSN1::	TSTL	R9		;JUMP IF ALL SET
	BEQLU	PRSN2
	JSB	PRTCH		;ELSE PRINT AN I
	DECL	R9		;DECREMENT COUNTER
	JMP	PRSN1		;LOOP BACK
;
;      MERRE WITH ALL LETTER I CHARACTERS GENERATED
;
PRSN2::	MOVL	#CH$BL,R6	;GET BLANK
	JSB	PRTCH		;PRINT BLANK
	MOVL	PRSNA,R6	;RESTORE ENTRY WA
	MOVL	(SP)+,R9	;RESTORE ENTRY XR
	RSB			;RETURN TO PRTSN CALLER
	;ENP			;END PROCEDURE PRTSN
	.PAGE
;
;      PRTST -- PRINT STRING
;
;      PRTST PLACES A STRING OF CHARACTERS IN THE PRINT BUFFER
;
;      SEE PRTNL FOR GLOBAL LOCATIONS USED
;
;      NOTE THAT THE FIRST WORD OF THE BLOCK (NORMALLY B$SCL)
;      IS NOT USED AND NEED NOT BE SET CORRECTLY (SEE PRTVN)
;
;      (XR)                  STRING TO BE PRINTED
;      JSR  PRTST            CALL TO PRINT STRING
;      (PROFS)               UPDATED PAST CHARS PLACED
;
	.ENABLE	LOCAL_BLOCK
PRTST::	;PRC			;ENTRY POINT
	TSTL	HEADP		;WERE HEADERS PRINTED
	BNEQU	PRST0
	JSB	PRTPS		;NO - PRINT THEM
;
;      CALL SYSPR
;
PRST0::	MOVL	R6,PRSVA	;SAVE WA
	MOVL	R7,PRSVB	;SAVE WB
	CLRL	R7		;SET CHARS PRINTED COUNT TO ZERO
;
;      LOOP TO PRINT SUCCESSIVE LINES FOR LONG STRING
;
PRST1::	MOVL	4*SCLEN(R9),R6	;LOAD STRING LENGTH
	SUBL2	R7,R6		;SUBTRACT COUNT OF CHARS ALREADY OUT
	TSTL	R6		;JUMP TO EXIT IF NONE LEFT
	BNEQU	5228$
	JMP	PRST4
5228$:
	MOVL	R10,-(SP)	;ELSE STACK ENTRY XL
	MOVL	R9,-(SP)	;SAVE ARGUMENT
	MOVL	R9,R10		;COPY FOR EVENTUAL MOVE
	MOVL	PRLEN,R9	;LOAD PRINT BUFFER LENGTH
	SUBL2	PROFS,R9	;GET CHARS LEFT IN PRINT BUFFER
	BNEQU	PRST2
	JSB	PRTNL		;ELSE PRINT THIS LINE
	MOVL	PRLEN,R9	;AND SET FULL WIDTH AVAILABLE
	.PAGE
;
;      PRTST (CONTINUED)
;
;      HERE WITH CHARS TO PRINT AND SOME ROOM IN BUFFER
;
PRST2::	CMPL	R6,R9		;JUMP IF ROOM FOR REST OF STRING
	BLEQU	PRST3
	MOVL	R9,R6		;ELSE SET TO FILL LINE
;
;      MERGE HERE WITH CHARACTER COUNT IN WA
;
PRST3::	MOVL	PRBUF,R9	;POINT TO PRINT BUFFER
	MOVAB	CFP$F(R10)[R7],R10 ;POINT TO LOCATION IN STRING
	MOVL	PROFS,R11	;[GET IN SCRATCH REGISTER]
	MOVAB	CFP$F(R9)[R11],R9;POINT TO LOCATION IN BUFFER
	ADDL2	R6,R7		;BUMP STRING CHARS COUNT
	ADDL2	R6,PROFS	;BUMP BUFFER POINTER
	MOVL	R7,PRSVC	;PRESERVE CHAR COUNTER
	MVC			;MOVE CHARACTERS TO BUFFER
	MOVL	PRSVC,R7	;RECOVER CHAR COUNTER
	MOVL	(SP)+,R9	;RESTORE ARGUMENT POINTER
	MOVL	(SP)+,R10	;RESTORE ENTRY XL
	JMP	PRST1		;LOOP BACK TO TEST FOR MORE
;
;      HERE TO EXIT AFTER PRINTING STRING
;
PRST4::	MOVL	PRSVB,R7	;RESTORE ENTRY WB
	MOVL	PRSVA,R6	;RESTORE ENTRY WA
	RSB			;RETURN TO PRTST CALLER
	;ENP			;END PROCEDURE PRTST
	.PAGE
;
;      PRTTR -- PRINT TO TERMINAL
;
;      CALLED TO PRINT CONTENTS OF STANDARD PRINT BUFFER TO
;      ONLINE TERMINAL. CLEARS BUFFER DOWN AND RESETS PROFS.
;
;      JSR  PRTTR            CALL FOR PRINT
;      (WA,WB)               DESTROYED
;
	.ENABLE	LOCAL_BLOCK
PRTTR::	;PRC			;ENTRY POINT
	MOVL	R9,-(SP)	;SAVE XR
	JSB	PRTIC		;PRINT BUFFER CONTENTS
	MOVL	PRBUF,R9	;POINT TO PRINT BFR TO CLEAR IT
	MOVL	PRLNW,R6	;GET BUFFER LENGTH
	ADDL2	#4*SCHAR,R9	;POINT PAST SCBLK HEADER
	MOVL	NULLW,R7	;GET BLANKS
;
;      LOOP TO CLEAR BUFFER
;
PRTT1::	MOVL	R7,(R9)+	;CLEAR A WORD
	SOBGTR	R6,PRTT1	;LOOP
	CLRL	PROFS		;RESET PROFS
	MOVL	(SP)+,R9	;RESTORE XR
	RSB			;RETURN
	;ENP			;END PROCEDURE PRTTR
	.PAGE
;
;      PRTVL -- PRINT A VALUE
;
;      PRTVL PLACES AN APPROPRIATE CHARACTER REPRESENTATION OF
;      A DATA VALUE IN THE PRINT BUFFER FOR DUMP/TRACE USE.
;
;      (XR)                  VALUE TO BE PRINTED
;      JSR  PRTVL            CALL TO PRINT VALUE
;      (WA,WB,WC,RA)         DESTROYED
;
	.ENABLE	LOCAL_BLOCK
PRTVL::	;PRC			;ENTRY POINT, RECURSIVE
	MOVL	R10,-(SP)	;SAVE ENTRY XL
	MOVL	R9,-(SP)	;SAVE ARGUMENT
	;CHK			;CHECK FOR STACK OVERFLOW
;
;      LOOP BACK HERE AFTER FINDING A TRAP BLOCK (TRBLK)
;
PRV01::	MOVL	4*IDVAL(R9),PRVSI;COPY IDVAL (IF ANY)
	MOVL	(R9),R10	;LOAD FIRST WORD OF BLOCK
	MOVZWL	-2(R10),R10	;LOAD ENTRY POINT ID
	BSW	R10,BL$$T,PRV02	;SWITCH ON BLOCK TYPE
	IFF	BL$TR,PRV04	;TRBLK
	IFF	BL$AR,PRV05	;ARBLK
	IFF	BL$IC,PRV08	;ICBLK
	IFF	BL$NM,PRV09	;NMBLK
	IFF	BL$PD,PRV10	;PDBLK
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	IFF	BL$RC,PRV08	;RCBLK
	.ENDC
	IFF	BL$SC,PRV11	;SCBLK
	IFF	BL$SE,PRV12	;SEBLK
	IFF	BL$TB,PRV13	;TBBLK
	IFF	BL$VC,PRV13	;VCBLK
	ESW			;END OF SWITCH ON BLOCK TYPE
;
;      HERE FOR BLOCKS FOR WHICH WE JUST PRINT DATATYPE NAME
;
PRV02::	JSB	DTYPE		;GET DATATYPE NAME
	JSB	PRTST		;PRINT DATATYPE NAME
;
;      COMMON EXIT POINT
;
PRV03::	MOVL	(SP)+,R9	;RELOAD ARGUMENT
	MOVL	(SP)+,R10	;RESTORE XL
	RSB			;RETURN TO PRTVL CALLER
;
;      HERE FOR TRBLK
;
PRV04::	MOVL	4*TRVAL(R9),R9	;LOAD REAL VALUE
	JMP	PRV01		;AND LOOP BACK
	.PAGE
;
;      PRTVL (CONTINUED)
;
;      HERE FOR ARRAY (ARBLK)
;
;      PRINT ARRAY ( PROTOTYPE ) BLANK NUMBER IDVAL
;
PRV05::	MOVL	R9,R10		;PRESERVE ARGUMENT
	MOVL	#SCARR,R9	;POINT TO DATATYPE NAME (ARRAY)
	JSB	PRTST		;PRINT IT
	MOVL	#CH$PP,R6	;LOAD LEFT PAREN
	JSB	PRTCH		;PRINT LEFT PAREN
	ADDL2	4*AROFS(R10),R10;POINT TO PROTOTYPE
	MOVL	(R10),R9	;LOAD PROTOTYPE
	JSB	PRTST		;PRINT PROTOTYPE
;
;      VCBLK, TBBLK MERGE HERE FOR ) BLANK NUMBER IDVAL
;
PRV06::	MOVL	#CH$RP,R6	;LOAD RIGHT PAREN
	JSB	PRTCH		;PRINT RIGHT PAREN
;
;      PDBLK MERGES HERE TO PRINT BLANK NUMBER IDVAL
;
PRV07::	MOVL	#CH$BL,R6	;LOAD BLANK
	JSB	PRTCH		;PRINT IT
	MOVL	#CH$NM,R6	;LOAD NUMBER SIGN
	JSB	PRTCH		;PRINT IT
	MOVL	PRVSI,R5	;GET IDVAL
	JSB	PRTIN		;PRINT ID NUMBER
	JMP	PRV03		;BACK TO EXIT
;
;      HERE FOR INTEGER (ICBLK), REAL (RCBLK)
;
;      PRINT CHARACTER REPRESENTATION OF VALUE
;
PRV08::	MOVL	R9,-(SP)	;STACK ARGUMENT FOR GTSTG
	JSB	GTSTG		;CONVERT TO STRING
	.ADDRESS INVALID$	;ERROR RETURN IS IMPOSSIBLE
	JSB	PRTST		;PRINT THE STRING
	MOVL	R9,DNAMP	;DELETE GARBAGE STRING FROM STORAGE
	JMP	PRV03		;BACK TO EXIT
	.PAGE
;
;      PRTVL (CONTINUED)
;
;      NAME (NMBLK)
;
;      FOR PSEUDO-VARIABLE, JUST PRINT DATATYPE NAME (NAME)
;      FOR ALL OTHER NAMES, PRINT DOT FOLLOWED BY NAME REP
;
PRV09::	MOVL	4*NMBAS(R9),R10	;LOAD NAME BASE
	MOVL	(R10),R6	;LOAD FIRST WORD OF BLOCK
	CMPL	R6,#B$KVT	;JUST PRINT NAME IF KEYWORD
	BNEQU	5229$
	JMP	PRV02
5229$:
	CMPL	R6,#B$EVT	;JUST PRINT NAME IF EXPRESSION VAR
	BNEQU	5230$
	JMP	PRV02
5230$:
	MOVL	#CH$DT,R6	;ELSE GET DOT
	JSB	PRTCH		;AND PRINT IT
	MOVL	4*NMOFS(R9),R6	;LOAD NAME OFFSET
	JSB	PRTNM		;PRINT NAME
	JMP	PRV03		;BACK TO EXIT
;
;      PROGRAM DATATYPE (PDBLK)
;
;      PRINT DATATYPE NAME CH$BL CH$NM IDVAL
;
PRV10::	JSB	DTYPE		;GET DATATYPE NAME
	JSB	PRTST		;PRINT DATATYPE NAME
	JMP	PRV07		;MERGE BACK TO PRINT ID
;
;      HERE FOR STRING (SCBLK)
;
;      PRINT QUOTE STRING-CHARACTERS QUOTE
;
PRV11::	MOVL	#CH$SQ,R6	;LOAD SINGLE QUOTE
	JSB	PRTCH		;PRINT QUOTE
	JSB	PRTST		;PRINT STRING VALUE
	JSB	PRTCH		;PRINT ANOTHER QUOTE
	JMP	PRV03		;BACK TO EXIT
	.PAGE
;
;      PRTVL (CONTINUED)
;
;      HERE FOR SIMPLE EXPRESSION (SEBLK)
;
;      PRINT ASTERISK VARIABLE-NAME
;
PRV12::	MOVL	#CH$AS,R6	;LOAD ASTERISK
	JSB	PRTCH		;PRINT ASTERISK
	MOVL	4*SEVAR(R9),R9	;LOAD VARIABLE POINTER
	JSB	PRTVN		;PRINT VARIABLE NAME
	JMP	PRV03		;JUMP BACK TO EXIT
;
;      HERE FOR TABLE (TBBLK) AND ARRAY (VCBLK)
;
;      PRINT DATATYPE ( PROTOTYPE ) BLANK NUMBER IDVAL
;
PRV13::	MOVL	R9,R10		;PRESERVE ARGUMENT
	JSB	DTYPE		;GET DATATYPE NAME
	JSB	PRTST		;PRINT DATATYPE NAME
	MOVL	#CH$PP,R6	;LOAD LEFT PAREN
	JSB	PRTCH		;PRINT LEFT PAREN
	MOVL	4*TBLEN(R10),R6	;LOAD LENGTH OF BLOCK (=VCLEN)
	ASHL	#-2,R6,R6	;CONVERT TO WORD COUNT
	SUBL2	#TBSI$,R6	;ALLOW FOR STANDARD FIELDS
	CMPL	(R10),#B$TBT	;JUMP IF TABLE
	BEQLU	PRV14
	ADDL2	#VCTBD,R6	;FOR VCBLK, ADJUST SIZE
;
;      PRINT PROTOTYPE
;
PRV14::	MOVL	R6,R5		;MOVE AS INTEGER
	JSB	PRTIN		;PRINT INTEGER PROTOTYPE
	JMP	PRV06		;MERGE BACK FOR REST
	;ENP			;END PROCEDURE PRTVL
	.PAGE
;
;      PRTVN -- PRINT NATURAL VARIABLE NAME
;
;      PRTVN PRINTS THE NAME OF A NATURAL VARIABLE
;
;      (XR)                  POINTER TO VRBLK
;      JSR  PRTVN            CALL TO PRINT VARIABLE NAME
;
	.ENABLE	LOCAL_BLOCK
PRTVN::	;PRC			;ENTRY POINT
	MOVL	R9,-(SP)	;STACK VRBLK POINTER
	ADDL2	#4*VRSOF,R9	;POINT TO POSSIBLE STRING NAME
	TSTL	4*SCLEN(R9)	;JUMP IF NOT SYSTEM VARIABLE
	BNEQU	PRVN1
	MOVL	4*VRSVO(R9),R9	;POINT TO SVBLK WITH NAME
;
;      MERGE HERE WITH DUMMY SCBLK POINTER IN XR
;
PRVN1::	JSB	PRTST		;PRINT STRING NAME OF VARIABLE
	MOVL	(SP)+,R9	;RESTORE VRBLK POINTER
	RSB			;RETURN TO PRTVN CALLER
	;ENP			;END PROCEDURE PRTVN
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	.PAGE
;
;      RCBLD -- BUILD A REAL BLOCK
;
;      (RA)                  REAL VALUE FOR RCBLK
;      JSR  RCBLD            CALL TO BUILD REAL BLOCK
;      (XR)                  POINTER TO RESULT RCBLK
;      (WA)                  DESTROYED
;
	.ENABLE	LOCAL_BLOCK
RCBLD::	;PRC			;ENTRY POINT
	MOVL	DNAMP,R9	;LOAD POINTER TO NEXT AVAILABLE LOC
	ADDL2	#4*RCSI$,R9	;POINT PAST NEW RCBLK
	CMPL	R9,DNAME	;JUMP IF THERE IS ROOM
	BLEQU	RCBL1
	MOVL	#4*RCSI$,R6	;ELSE LOAD RCBLK LENGTH
	JSB	ALLOC		;USE STANDARD ALLOCATOR TO GET BLOCK
	ADDL2	R6,R9		;POINT PAST BLOCK TO MERGE
;
;      MERGE HERE WITH XR POINTING PAST THE BLOCK OBTAINED
;
RCBL1::	MOVL	R9,DNAMP	;SET NEW POINTER
	SUBL2	#4*RCSI$,R9	;POINT BACK TO START OF BLOCK
	MOVL	#B$RCL,(R9)	;STORE TYPE WORD
	MOVF	R2,4*RCVAL(R9)	;STORE REAL VALUE IN RCBLK
	RSB			;RETURN TO RCBLD CALLER
	;ENP			;END PROCEDURE RCBLD
	.ENDC
	.PAGE
;
;      READR -- READ NEXT SOURCE IMAGE AT COMPILE TIME
;
;      READR IS USED TO READ THE NEXT SOURCE IMAGE. TO PROCESS
;      CONTINUATION CARDS PROPERLY, THE COMPILER MUST READ ONE
;      LINE AHEAD. THUS READR DOES NOT DESTROY THE CURRENT IMAGE
;      SEE ALSO THE NEXTS ROUTINE WHICH ACTUALLY GETS THE IMAGE.
;
;      JSR  READR            CALL TO READ NEXT IMAGE
;      (XR)                  PTR TO NEXT IMAGE (0 IF NONE)
;      (R$CNI)               COPY OF POINTER
;      (WA,WB,WC,XL)         DESTROYED
;
	.ENABLE	LOCAL_BLOCK
READR::	;PRC			;ENTRY POINT
	MOVL	R$CNI,R9	;GET PTR TO NEXT IMAGE
	BNEQU	READ3
	CMPL	STAGE,#STGIC	;EXIT IF NOT INITIAL COMPILE
	BNEQU	READ3
	MOVL	CSWIN,R6	;MAX READ LENGTH
	JSB	ALOCS		;ALLOCATE BUFFER
	JSB	SYSRD		;READ INPUT IMAGE
	.ADDRESS READ4		;JUMP IF END OF FILE
	MOVL	SP,R7		;SET TRIMR TO PERFORM TRIM
	CMPL	4*SCLEN(R9),CSWIN;USE SMALLER OF STRING LNTH ..
	BLEQU	READ1
	MOVL	CSWIN,4*SCLEN(R9);... AND XXX OF -INXXX
;
;      PERFORM THE TRIM
;
READ1::	JSB	TRIMR		;TRIM TRAILING BLANKS
;
;      MERGE HERE AFTER READ
;
READ2::	MOVL	R9,R$CNI	;STORE COPY OF POINTER
;
;      MERGE HERE IF NO READ ATTEMPTED
;
READ3::	RSB			;RETURN TO READR CALLER
;
;      HERE ON END OF FILE
;
READ4::	MOVL	R9,DNAMP	;POP UNUSED SCBLK
	CLRL	R9		;ZERO PTR AS RESULT
	JMP	READ2		;MERGE
	;ENP			;END PROCEDURE READR
	.PAGE
;
;      SBSTR -- BUILD A SUBSTRING
;
;      (XL)                  PTR TO SCBLK CONTAINING CHARS
;      (WA)                  NUMBER OF CHARS IN SUBSTRING
;      (WB)                  OFFSET TO FIRST CHAR IN SCBLK
;      JSR  SBSTR            CALL TO BUILD SUBSTRING
;      (XR)                  PTR TO NEW SCBLK WITH SUBSTRING
;      (XL)                  ZERO
;      (WA,WB,WC,XL,IA)      DESTROYED
;
;      NOTE THAT SBSTR IS CALLED WITH A DUMMY STRING POINTER
;      (POINTING INTO A VRBLK OR SVBLK) TO COPY THE NAME OF A
;      VARIABLE AS A STANDARD STRING VALUE.
;
	.ENABLE	LOCAL_BLOCK
SBSTR::	;PRC			;ENTRY POINT
	TSTL	R6		;JUMP IF NULL SUBSTRING
	BEQLU	SBST2
	JSB	ALOCS		;ELSE ALLOCATE SCBLK
	MOVL	R8,R6		;MOVE NUMBER OF CHARACTERS
	MOVL	R9,R8		;SAVE PTR TO NEW SCBLK
	MOVAB	CFP$F(R10)[R7],R10 ;PREPARE TO LOAD CHARS FROM OLD BLK
	MOVAB	CFP$F(R9),R9	;PREPARE TO STORE CHARS IN NEW BLK
	MVC			;MOVE CHARACTERS TO NEW STRING
	MOVL	R8,R9		;THEN RESTORE SCBLK POINTER
;
;      RETURN POINT
;
SBST1::	CLRL	R10		;CLEAR GARBAGE POINTER IN XL
	RSB			;RETURN TO SBSTR CALLER
;
;      HERE FOR NULL SUBSTRING
;
SBST2::	MOVL	#NULLS,R9	;SET NULL STRING AS RESULT
	JMP	SBST1		;RETURN
	;ENP			;END PROCEDURE SBSTR
	.PAGE
;
;      SCANE -- SCAN AN ELEMENT
;
;      SCANE IS CALLED AT COMPILE TIME (BY EXPAN ,CMPIL,CNCRD)
;      TO SCAN ONE ELEMENT FROM THE INPUT IMAGE.
;
;      (SCNCC)               NON-ZERO IF CALLED FROM CNCRD
;      JSR  SCANE            CALL TO SCAN ELEMENT
;      (XR)                  RESULT POINTER (SEE BELOW)
;      (XL)                  SYNTAX TYPE CODE (T$XXX)
;
;      THE FOLLOWING GLOBAL LOCATIONS ARE USED.
;
;      R$CIM                 POINTER TO STRING BLOCK (SCBLK)
;                            FOR CURRENT INPUT IMAGE.
;
;      R$CNI                 POINTER TO NEXT INPUT IMAGE STRING
;                            POINTER (ZERO IF NONE).
;
;      R$SCP                 SAVE POINTER (EXIT XR) FROM LAST
;                            CALL IN CASE RESCAN IS SET.
;
;      SCNBL                 THIS LOCATION IS SET NON-ZERO ON
;                            EXIT IF SCANE SCANNED PAST BLANKS
;                            BEFORE LOCATING THE CURRENT ELEMENT
;                            THE END OF A LINE COUNTS AS BLANKS.
;
;      SCNCC                 CNCRD SETS THIS NON-ZERO TO SCAN
;                            CONTROL CARD NAMES AND CLEARS IT
;                            ON RETURN
;
;      SCNIL                 LENGTH OF CURRENT INPUT IMAGE
;
;      SCNGO                 IF SET NON-ZERO ON ENTRY, F AND S
;                            ARE RETURNED AS SEPARATE SYNTAX
;                            TYPES (NOT LETTERS) (GOTO PRO-
;                            CESSING). SCNGO IS RESET ON EXIT.
;
;      SCNPT                 OFFSET TO CURRENT LOC IN R$CIM
;
;      SCNRS                 IF SET NON-ZERO ON ENTRY, SCANE
;                            RETURNS THE SAME RESULT AS ON THE
;                            LAST CALL (RESCAN). SCNRS IS RESET
;                            ON EXIT FROM ANY CALL TO SCANE.
;
;      SCNTP                 SAVE SYNTAX TYPE FROM LAST
;                            CALL (IN CASE RESCAN IS SET).
	.PAGE
;
;      SCANE (CONTINUED)
;
;
;
;      ELEMENT SCANNED       XL        XR
;      ---------------       --        --
;
;      CONTROL CARD NAME     0         POINTER TO SCBLK FOR NAME
;
;      UNARY OPERATOR        T$UOP     PTR TO OPERATOR DVBLK
;
;      LEFT PAREN            T$LPR     T$LPR
;
;      LEFT BRACKET          T$LBR     T$LBR
;
;      COMMA                 T$CMA     T$CMA
;
;      FUNCTION CALL         T$FNC     PTR TO FUNCTION VRBLK
;
;      VARIABLE              T$VAR     PTR TO VRBLK
;
;      STRING CONSTANT       T$CON     PTR TO SCBLK
;
;      INTEGER CONSTANT      T$CON     PTR TO ICBLK
;
	.IF NOT_EQUAL CNRA
	.IF_FALSE
;      REAL CONSTANT         T$CON     PTR TO RCBLK
;
	.ENDC
;      BINARY OPERATOR       T$BOP     PTR TO OPERATOR DVBLK
;
;      RIGHT PAREN           T$RPR     T$RPR
;
;      RIGHT BRACKET         T$RBR     T$RBR
;
;      COLON                 T$COL     T$COL
;
;      SEMI-COLON            T$SMC     T$SMC
;
;      F (SCNGO NE 0)        T$FGO     T$FGO
;
;      S (SCNGO NE 0)        T$SGO     T$SGO
	.PAGE
;
;      SCANE (CONTINUED)
;
;      ENTRY POINT
;
	.ENABLE	LOCAL_BLOCK
SCANE::	;PRC			;ENTRY POINT
	CLRL	SCNBL		;RESET BLANKS FLAG
	MOVL	R6,SCNSA	;SAVE WA
	MOVL	R7,SCNSB	;SAVE WB
	MOVL	R8,SCNSC	;SAVE WC
	TSTL	SCNRS		;JUMP IF NO RESCAN
	BEQLU	SCN03
;
;      HERE FOR RESCAN REQUEST
;
	MOVL	SCNTP,R10	;SET PREVIOUS RETURNED SCAN TYPE
	MOVL	R$SCP,R9	;SET PREVIOUS RETURNED POINTER
	CLRL	SCNRS		;RESET RESCAN SWITCH
	JMP	SCN13		;JUMP TO EXIT
;
;      COME HERE TO READ NEW IMAGE TO TEST FOR CONTINUATION
;
SCN01::	JSB	READR		;READ NEXT IMAGE
	MOVL	#4*DVUBS,R7	;SET WB FOR NOT READING NAME
	TSTL	R9		;TREAT AS SEMI-COLON IF NONE
	BNEQU	5231$
	JMP	SCN30
5231$:
	MOVAB	CFP$F(R9),R9	;ELSE POINT TO FIRST CHARACTER
	MOVZBL	(R9),R8		;LOAD FIRST CHARACTER
	CMPL	R8,#CH$DT	;JUMP IF DOT FOR CONTINUATION
	BEQLU	SCN02
	CMPL	R8,#CH$PL	;ELSE TREAT AS SEMICOLON UNLESS PLUS
	BEQLU	5232$
	JMP	SCN30
5232$:
;
;      HERE FOR CONTINUATION LINE
;
SCN02::	JSB	NEXTS		;ACQUIRE NEXT SOURCE IMAGE
	MOVL	#NUM01,SCNPT	;SET SCAN POINTER PAST CONTINUATION
	MOVL	SP,SCNBL	;SET BLANKS FLAG
	.PAGE
;
;      SCANE (CONTINUED)
;
;      MERGE HERE TO SCAN NEXT ELEMENT ON CURRENT LINE
;
SCN03::	MOVL	SCNPT,R6	;LOAD CURRENT OFFSET
	CMPL	R6,SCNIL	;CHECK CONTINUATION IF END
	BNEQU	5233$
	JMP	SCN01
5233$:
	MOVL	R$CIM,R10	;POINT TO CURRENT LINE
	MOVAB	CFP$F(R10)[R6],R10 ;POINT TO CURRENT CHARACTER
	MOVL	R6,SCNSE	;SET START OF ELEMENT LOCATION
	MOVL	#OPDVS,R8	;POINT TO OPERATOR DV LIST
	MOVL	#4*DVUBS,R7	;SET CONSTANT FOR OPERATOR CIRCUIT
	JMP	SCN06		;START SCANNING
;
;      LOOP HERE TO IGNORE LEADING BLANKS AND TABS
;
SCN05::	TSTL	R7		;JUMP IF TRAILING
	BNEQU	5234$
	JMP	SCN10
5234$:
	INCL	SCNSE		;INCREMENT START OF ELEMENT
	CMPL	R6,SCNIL	;JUMP IF END OF IMAGE
	BNEQU	5235$
	JMP	SCN01
5235$:
	MOVL	SP,SCNBL	;NOTE BLANKS SEEN
;
;      THE FOLLOWING JUMP IS USED REPEATEDLY FOR SCANNING OUT
;      THE CHARACTERS OF A NUMERIC CONSTANT OR VARIABLE NAME.
;      THE REGISTERS ARE USED AS FOLLOWS.
;
;      (XR)                  SCRATCH
;      (XL)                  PTR TO NEXT CHARACTER
;      (WA)                  CURRENT SCAN OFFSET
;      (WB)                  *DVUBS (0 IF SCANNING NAME,CONST)
;      (WC)                  =OPDVS (0 IF SCANNING CONSTANT)
;
SCN06::	MOVZBL	(R10)+,R9	;GET NEXT CHARACTER
	INCL	R6		;BUMP SCAN OFFSET
	MOVL	R6,SCNPT	;STORE OFFSET PAST CHAR SCANNED
	BSW	R9,CFP$A,SCN07	;SWITCH ON SCANNED CHARACTER
;
;      SWITCH TABLE FOR SWITCH ON CHARACTER
;
	IFF	CH$BL,SCN05	;BLANK
	.IF NOT_EQUAL CAHT
	IFF	CH$HT,SCN05	;HORIZONTAL TAB
	.ENDC
	.IF NOT_EQUAL CAVT
	IFF	CH$VT,SCN05	;VERTICAL TAB
	.ENDC
	IFF	CH$D0,SCN08	;DIGIT 0
	IFF	CH$D1,SCN08	;DIGIT 1
	IFF	CH$D2,SCN08	;DIGIT 2
	IFF	CH$D3,SCN08	;DIGIT 3
	IFF	CH$D4,SCN08	;DIGIT 4
	IFF	CH$D5,SCN08	;DIGIT 5
	IFF	CH$D6,SCN08	;DIGIT 6
	IFF	CH$D7,SCN08	;DIGIT 7
	IFF	CH$D8,SCN08	;DIGIT 8
	IFF	CH$D9,SCN08	;DIGIT 9
	.PAGE
;
;      SCANE (CONTINUED)
;
	IFF	CH$LA,SCN09	;LETTER A
	IFF	CH$LB,SCN09	;LETTER B
	IFF	CH$LC,SCN09	;LETTER C
	IFF	CH$LD,SCN09	;LETTER D
	IFF	CH$LE,SCN09	;LETTER E
	IFF	CH$LG,SCN09	;LETTER G
	IFF	CH$LH,SCN09	;LETTER H
	IFF	CH$LI,SCN09	;LETTER I
	IFF	CH$LJ,SCN09	;LETTER J
	IFF	CH$LK,SCN09	;LETTER K
	IFF	CH$LL,SCN09	;LETTER L
	IFF	CH$LM,SCN09	;LETTER M
	IFF	CH$LN,SCN09	;LETTER N
	IFF	CH$LO,SCN09	;LETTER O
	IFF	CH$LP,SCN09	;LETTER P
	IFF	CH$LQ,SCN09	;LETTER Q
	IFF	CH$LR,SCN09	;LETTER R
	IFF	CH$LT,SCN09	;LETTER T
	IFF	CH$LU,SCN09	;LETTER U
	IFF	CH$LV,SCN09	;LETTER V
	IFF	CH$LW,SCN09	;LETTER W
	IFF	CH$LX,SCN09	;LETTER X
	IFF	CH$LY,SCN09	;LETTER Y
	IFF	CH$L$,SCN09	;LETTER Z
	.IF NOT_EQUAL CASL
	IFF	CH$$A,SCN09	;SHIFTED A
	IFF	CH$$B,SCN09	;SHIFTED B
	IFF	CH$$C,SCN09	;SHIFTED C
	IFF	CH$$D,SCN09	;SHIFTED D
	IFF	CH$$E,SCN09	;SHIFTED E
	IFF	CH$$F,SCN20	;SHIFTED F
	IFF	CH$$G,SCN09	;SHIFTED G
	IFF	CH$$H,SCN09	;SHIFTED H
	IFF	CH$$I,SCN09	;SHIFTED I
	IFF	CH$$J,SCN09	;SHIFTED J
	IFF	CH$$K,SCN09	;SHIFTED K
	IFF	CH$$L,SCN09	;SHIFTED L
	IFF	CH$$M,SCN09	;SHIFTED M
	IFF	CH$$N,SCN09	;SHIFTED N
	IFF	CH$$O,SCN09	;SHIFTED O
	IFF	CH$$P,SCN09	;SHIFTED P
	IFF	CH$$Q,SCN09	;SHIFTED Q
	IFF	CH$$R,SCN09	;SHIFTED R
	IFF	CH$$S,SCN21	;SHIFTED S
	IFF	CH$$T,SCN09	;SHIFTED T
	IFF	CH$$U,SCN09	;SHIFTED U
	IFF	CH$$V,SCN09	;SHIFTED V
	IFF	CH$$W,SCN09	;SHIFTED W
	IFF	CH$$X,SCN09	;SHIFTED X
	IFF	CH$$Y,SCN09	;SHIFTED Y
	IFF	CH$$$,SCN09	;SHIFTED Z
	.ENDC
	.PAGE
;
;      SCANE (CONTINUED)
;
	IFF	CH$SQ,SCN16	;SINGLE QUOTE
	IFF	CH$DQ,SCN17	;DOUBLE QUOTE
	IFF	CH$LF,SCN20	;LETTER F
	IFF	CH$LS,SCN21	;LETTER S
	IFF	CH$UN,SCN24	;UNDERLINE
	IFF	CH$PP,SCN25	;LEFT PAREN
	IFF	CH$RP,SCN26	;RIGHT PAREN
	IFF	CH$RB,SCN27	;RIGHT BRACKET
	IFF	CH$BB,SCN28	;LEFT BRACKET
	IFF	CH$CB,SCN27	;RIGHT BRACKET
	IFF	CH$OB,SCN28	;LEFT BRACKET
	IFF	CH$CL,SCN29	;COLON
	IFF	CH$SM,SCN30	;SEMI-COLON
	IFF	CH$CM,SCN31	;COMMA
	IFF	CH$DT,SCN32	;DOT
	IFF	CH$PL,SCN33	;PLUS
	IFF	CH$MN,SCN34	;MINUS
	IFF	CH$NT,SCN35	;NOT
	IFF	CH$DL,SCN36	;DOLLAR
	IFF	CH$EX,SCN37	;EXCLAMATION MARK
	IFF	CH$PC,SCN38	;PERCENT
	IFF	CH$SL,SCN40	;SLASH
	IFF	CH$NM,SCN41	;NUMBER SIGN
	IFF	CH$AT,SCN42	;AT
	IFF	CH$BR,SCN43	;VERTICAL BAR
	IFF	CH$AM,SCN44	;AMPERSAND
	IFF	CH$QU,SCN45	;QUESTION MARK
	IFF	CH$EQ,SCN46	;EQUAL
	IFF	CH$AS,SCN49	;ASTERISK
	ESW			;END SWITCH ON CHARACTER
;
;      HERE FOR ILLEGAL CHARACTER (UNDERLINE MERGES)
;
SCN07::	TSTL	R7		;JUMP IF SCANNING NAME OR CONSTANT
	BNEQU	5236$
	JMP	SCN10
5236$:
	JMP	ERROR_230	;SYNTAX ERROR. ILLEGAL CHARACTER
	.PAGE
;
;      SCANE (CONTINUED)
;
;      HERE FOR DIGITS 0-9
;
SCN08::	TSTL	R7		;KEEP SCANNING IF NAME/CONSTANT
	BNEQU	5237$
	JMP	SCN09
5237$:
	CLRL	R8		;ELSE SET FLAG FOR SCANNING CONSTANT
;
;      HERE FOR LETTER. LOOP HERE WHEN SCANNING NAME/CONSTANT
;
SCN09::	CMPL	R6,SCNIL	;JUMP IF END OF IMAGE
	BEQLU	SCN11
	CLRL	R7		;SET FLAG FOR SCANNING NAME/CONST
	JMP	SCN06		;MERGE BACK TO CONTINUE SCAN
;
;      COME HERE FOR DELIMITER ENDING NAME OR CONSTANT
;
SCN10::	DECL	R6		;RESET OFFSET TO POINT TO DELIMITER
;
;      COME HERE AFTER FINISHING SCAN OF NAME OR CONSTANT
;
SCN11::	MOVL	R6,SCNPT	;STORE UPDATED SCAN OFFSET
	MOVL	SCNSE,R7	;POINT TO START OF ELEMENT
	SUBL2	R7,R6		;GET NUMBER OF CHARACTERS
	MOVL	R$CIM,R10	;POINT TO LINE IMAGE
	TSTL	R8		;JUMP IF NAME
	BNEQU	SCN15
;
;      HERE AFTER SCANNING OUT NUMERIC CONSTANT
;
	JSB	SBSTR		;GET STRING FOR CONSTANT
	MOVL	R9,DNAMP	;DELETE FROM STORAGE (NOT NEEDED)
	JSB	GTNUM		;CONVERT TO NUMERIC
	.ADDRESS SCN14		;JUMP IF CONVERSION FAILURE
;
;      MERGE HERE TO EXIT WITH CONSTANT
;
SCN12::	MOVL	#T$CON,R10	;SET RESULT TYPE OF CONSTANT
	.PAGE
;
;      SCANE (CONTINUED)
;
;      COMMON EXIT POINT (XR,XL) SET
;
SCN13::	MOVL	SCNSA,R6	;RESTORE WA
	MOVL	SCNSB,R7	;RESTORE WB
	MOVL	SCNSC,R8	;RESTORE WC
	MOVL	R9,R$SCP	;SAVE XR IN CASE RESCAN
	MOVL	R10,SCNTP	;SAVE XL IN CASE RESCAN
	CLRL	SCNGO		;RESET POSSIBLE GOTO FLAG
	RSB			;RETURN TO SCANE CALLER
;
;      HERE IF CONVERSION ERROR ON NUMERIC ITEM
;
SCN14::	JMP	ERROR_231	;SYNTAX ERROR. INVALID NUMERIC ITEM
;
;      HERE AFTER SCANNING OUT VARIABLE NAME
;
SCN15::	JSB	SBSTR		;BUILD STRING NAME OF VARIABLE
	TSTL	SCNCC		;RETURN IF CNCRD CALL
	BEQLU	5238$
	JMP	SCN13
5238$:
	JSB	GTNVR		;LOCATE/BUILD VRBLK
	.ADDRESS INVALID$	;DUMMY (UNUSED) ERROR RETURN
	MOVL	#T$VAR,R10	;SET TYPE AS VARIABLE
	JMP	SCN13		;BACK TO EXIT
;
;      HERE FOR SINGLE QUOTE (START OF STRING CONSTANT)
;
SCN16::	TSTL	R7		;TERMINATOR IF SCANNING NAME OR CNST
	BNEQU	5239$
	JMP	SCN10
5239$:
	MOVL	#CH$SQ,R7	;SET TERMINATOR AS SINGLE QUOTE
	JMP	SCN18		;MERGE
;
;      HERE FOR DOUBLE QUOTE (START OF STRING CONSTANT)
;
SCN17::	TSTL	R7		;TERMINATOR IF SCANNING NAME OR CNST
	BNEQU	5240$
	JMP	SCN10
5240$:
	MOVL	#CH$DQ,R7	;SET DOUBLE QUOTE TERMINATOR, MERGE
;
;      LOOP TO SCAN OUT STRING CONSTANT
;
SCN18::	CMPL	R6,SCNIL	;ERROR IF END OF IMAGE
	BEQLU	SCN19
	MOVZBL	(R10)+,R8	;ELSE LOAD NEXT CHARACTER
	INCL	R6		;BUMP OFFSET
	CMPL	R8,R7		;LOOP BACK IF NOT TERMINATOR
	BNEQU	SCN18
	.PAGE
;
;      SCANE (CONTINUED)
;
;      HERE AFTER SCANNING OUT STRING CONSTANT
;
	MOVL	SCNPT,R7	;POINT TO FIRST CHARACTER
	MOVL	R6,SCNPT	;SAVE OFFSET PAST FINAL QUOTE
	DECL	R6		;POINT BACK PAST LAST CHARACTER
	SUBL2	R7,R6		;GET NUMBER OF CHARACTERS
	MOVL	R$CIM,R10	;POINT TO INPUT IMAGE
	JSB	SBSTR		;BUILD SUBSTRING VALUE
	JMP	SCN12		;BACK TO EXIT WITH CONSTANT RESULT
;
;      HERE IF NO MATCHING QUOTE FOUND
;
SCN19::	MOVL	R6,SCNPT	;SET UPDATED SCAN POINTER
	JMP	ERROR_232	;SYNTAX ERROR. UNMATCHED STRING QUOTE
;
;      HERE FOR F (POSSIBLE FAILURE GOTO)
;
SCN20::	MOVL	#T$FGO,R9	;SET RETURN CODE FOR FAIL GOTO
	JMP	SCN22		;JUMP TO MERGE
;
;      HERE FOR S (POSSIBLE SUCCESS GOTO)
;
SCN21::	MOVL	#T$SGO,R9	;SET SUCCESS GOTO AS RETURN CODE
;
;      SPECIAL GOTO CASES MERGE HERE
;
SCN22::	TSTL	SCNGO		;TREAT AS NORMAL LETTER IF NOT GOTO
	BNEQU	5241$
	JMP	SCN09
5241$:
;
;      MERGE HERE FOR SPECIAL CHARACTER EXIT
;
SCN23::	TSTL	R7		;JUMP IF END OF NAME/CONSTANT
	BNEQU	5242$
	JMP	SCN10
5242$:
	MOVL	R9,R10		;ELSE COPY CODE
	JMP	SCN13		;AND JUMP TO EXIT
;
;      HERE FOR UNDERLINE
;
SCN24::	TSTL	R7		;PART OF NAME IF SCANNING NAME
	BNEQU	5243$
	JMP	SCN09
5243$:
	JMP	SCN07		;ELSE ILLEGAL
	.PAGE
;
;      SCANE (CONTINUED)
;
;      HERE FOR LEFT PAREN
;
SCN25::	MOVL	#T$LPR,R9	;SET LEFT PAREN RETURN CODE
	TSTL	R7		;RETURN LEFT PAREN UNLESS NAME
	BNEQU	SCN23
	TSTL	R8		;DELIMITER IF SCANNING CONSTANT
	BNEQU	5244$
	JMP	SCN10
5244$:
;
;      HERE FOR LEFT PAREN AFTER NAME (FUNCTION CALL)
;
	MOVL	SCNSE,R7	;POINT TO START OF NAME
	MOVL	R6,SCNPT	;SET POINTER PAST LEFT PAREN
	DECL	R6		;POINT BACK PAST LAST CHAR OF NAME
	SUBL2	R7,R6		;GET NAME LENGTH
	MOVL	R$CIM,R10	;POINT TO INPUT IMAGE
	JSB	SBSTR		;GET STRING NAME FOR FUNCTION
	JSB	GTNVR		;LOCATE/BUILD VRBLK
	.ADDRESS INVALID$	;DUMMY (UNUSED) ERROR RETURN
	MOVL	#T$FNC,R10	;SET CODE FOR FUNCTION CALL
	JMP	SCN13		;BACK TO EXIT
;
;      PROCESSING FOR SPECIAL CHARACTERS
;
SCN26::	MOVL	#T$RPR,R9	;RIGHT PAREN, SET CODE
	JMP	SCN23		;TAKE SPECIAL CHARACTER EXIT
;
SCN27::	MOVL	#T$RBR,R9	;RIGHT BRACKET, SET CODE
	JMP	SCN23		;TAKE SPECIAL CHARACTER EXIT
;
SCN28::	MOVL	#T$LBR,R9	;LEFT BRACKET, SET CODE
	JMP	SCN23		;TAKE SPECIAL CHARACTER EXIT
;
SCN29::	MOVL	#T$COL,R9	;COLON, SET CODE
	JMP	SCN23		;TAKE SPECIAL CHARACTER EXIT
;
SCN30::	MOVL	#T$SMC,R9	;SEMI-COLON, SET CODE
	JMP	SCN23		;TAKE SPECIAL CHARACTER EXIT
;
SCN31::	MOVL	#T$CMA,R9	;COMMA, SET CODE
	JMP	SCN23		;TAKE SPECIAL CHARACTER EXIT
	.PAGE
;
;      SCANE (CONTINUED)
;
;      HERE FOR OPERATORS. ON ENTRY, WC POINTS TO THE TABLE OF
;      OPERATOR DOPE VECTORS AND WB IS THE INCREMENT TO STEP
;      TO THE NEXT PAIR (BINARY/UNARY) OF DOPE VECTORS IN THE
;      LIST. ON REACHING SCN46, THE POINTER HAS BEEN ADJUSTED TO
;      POINT TO THE APPROPRIATE PAIR OF DOPE VECTORS.
;      THE FIRST THREE ENTRIES ARE SPECIAL SINCE THEY CAN OCCUR
;      AS PART OF A VARIABLE NAME (.) OR CONSTANT (.+-).
;
SCN32::	TSTL	R7		;DOT CAN BE PART OF NAME OR CONSTANT
	BNEQU	5245$
	JMP	SCN09
5245$:
	ADDL2	R7,R8		;ELSE BUMP POINTER
;
SCN33::	TSTL	R8		;PLUS CAN BE PART OF CONSTANT
	BNEQU	5246$
	JMP	SCN09
5246$:
	TSTL	R7		;PLUS CANNOT BE PART OF NAME
	BNEQU	5247$
	JMP	SCN48
5247$:
	ADDL2	R7,R8		;ELSE BUMP POINTER
;
SCN34::	TSTL	R8		;MINUS CAN BE PART OF CONSTANT
	BNEQU	5248$
	JMP	SCN09
5248$:
	TSTL	R7		;MINUS CANNOT BE PART OF NAME
	BNEQU	5249$
	JMP	SCN48
5249$:
	ADDL2	R7,R8		;ELSE BUMP POINTER
;
SCN35::	ADDL2	R7,R8		;NOT
SCN36::	ADDL2	R7,R8		;DOLLAR
SCN37::	ADDL2	R7,R8		;EXCLAMATION
SCN38::	ADDL2	R7,R8		;PERCENT
SCN39::	ADDL2	R7,R8		;ASTERISK
SCN40::	ADDL2	R7,R8		;SLASH
SCN41::	ADDL2	R7,R8		;NUMBER SIGN
SCN42::	ADDL2	R7,R8		;AT SIGN
SCN43::	ADDL2	R7,R8		;VERTICAL BAR
SCN44::	ADDL2	R7,R8		;AMPERSAND
SCN45::	ADDL2	R7,R8		;QUESTION MARK
;
;      ALL OPERATORS COME HERE (EQUAL MERGES DIRECTLY)
;      (WC) POINTS TO THE BINARY/UNARY PAIR OF OPERATOR DVBLKS.
;
SCN46::	TSTL	R7		;OPERATOR TERMINATES NAME/CONSTANT
	BNEQU	5250$
	JMP	SCN10
5250$:
	MOVL	R8,R9		;ELSE COPY DV POINTER
	MOVZBL	(R10),R8	;LOAD NEXT CHARACTER
	MOVL	#T$BOP,R10	;SET BINARY OP IN CASE
	CMPL	R6,SCNIL	;SHOULD BE BINARY IF IMAGE END
	BEQLU	SCN47
	CMPL	R8,#CH$BL	;SHOULD BE BINARY IF FOLLOWED BY BLK
	BEQLU	SCN47
	.IF NOT_EQUAL CAHT
	CMPL	R8,#CH$HT	;JUMP IF HORIZONTAL TAB
	BEQLU	SCN47
	.ENDC
	.IF NOT_EQUAL CAVT
	CMPL	R8,#CH$VT	;JUMP IF VERTICAL TAB
	BEQLU	SCN47
	.ENDC
	CMPL	R8,#CH$SM	;SEMICOLON CAN IMMEDIATELY FOLLOW =
	BEQLU	SCN47
;
;      HERE FOR UNARY OPERATOR
;
	ADDL2	#4*DVBS$,R9	;POINT TO DV FOR UNARY OP
	MOVL	#T$UOP,R10	;SET TYPE FOR UNARY OPERATOR
	CMPL	SCNTP,#T$UOK	;OK UNARY IF OK PRECEDING ELEMENT
	BGTRU	5251$
	JMP	SCN13
5251$:
	.PAGE
;
;      SCANE (CONTINUED)
;
;      MERGE HERE TO REQUIRE PRECEDING BLANKS
;
SCN47::	TSTL	SCNBL		;ALL OK IF PRECEDING BLANKS, EXIT
	BEQLU	5252$
	JMP	SCN13
5252$:
;
;      FAIL OPERATOR IN THIS POSITION
;
SCN48::	JMP	ERROR_233	;SYNTAX ERROR. INVALID USE OF OPERATOR
;
;      HERE FOR ASTERISK, COULD BE ** SUBSTITUTE FOR EXCLAMATION
;
SCN49::	TSTL	R7		;END OF NAME IF SCANNING NAME
	BNEQU	5253$
	JMP	SCN10
5253$:
	CMPL	R6,SCNIL	;NOT ** IF * AT IMAGE END
	BEQLU	SCN39
	MOVL	R6,R9		;ELSE SAVE OFFSET PAST FIRST *
	MOVL	R6,SCNOF	;SAVE ANOTHER COPY
	MOVZBL	(R10)+,R6	;LOAD NEXT CHARACTER
	CMPL	R6,#CH$AS	;NOT ** IF NEXT CHAR NOT *
	BNEQU	SCN50
	INCL	R9		;ELSE STEP OFFSET PAST SECOND *
	CMPL	R9,SCNIL	;OK EXCLAM IF END OF IMAGE
	BEQLU	SCN51
	MOVZBL	(R10),R6	;ELSE LOAD NEXT CHARACTER
	CMPL	R6,#CH$BL	;EXCLAMATION IF BLANK
	BEQLU	SCN51
	.IF NOT_EQUAL CAHT
	CMPL	R6,#CH$HT	;EXCLAMATION IF HORIZONTAL TAB
	BEQLU	SCN51
	.ENDC
	.IF NOT_EQUAL CAVT
	CMPL	R6,#CH$VT	;EXCLAMATION IF VERTICAL TAB
	BEQLU	SCN51
	.ENDC
;
;      UNARY *
;
SCN50::	MOVL	SCNOF,R6	;RECOVER STORED OFFSET
	MOVL	R$CIM,R10	;POINT TO LINE AGAIN
	MOVAB	CFP$F(R10)[R6],R10 ;POINT TO CURRENT CHAR
	JMP	SCN39		;MERGE WITH UNARY *
;
;      HERE FOR ** AS SUBSTITUTE FOR EXCLAMATION
;
SCN51::	MOVL	R9,SCNPT	;SAVE SCAN POINTER PAST 2ND *
	MOVL	R9,R6		;COPY SCAN POINTER
	JMP	SCN37		;MERGE WITH EXCLAMATION
	;ENP			;END PROCEDURE SCANE
	.PAGE
;
;      SCNGF -- SCAN GOTO FIELD
;
;      SCNGF IS CALLED FROM CMPIL TO SCAN AND ANALYZE A GOTO
;      FIELD INCLUDING THE SURROUNDING BRACKETS OR PARENTHESES.
;      FOR A NORMAL GOTO, THE RESULT RETURNED IS EITHER A VRBLK
;      POINTER FOR A SIMPLE LABEL OPERAND, OR A POINTER TO AN
;      EXPRESSION TREE WITH A SPECIAL OUTER UNARY OPERATOR
;      (O$GOC). FOR A DIRECT GOTO, THE RESULT RETURNED IS A
;      POINTER TO AN EXPRESSION TREE WITH THE SPECIAL OUTER
;      UNARY OPERATOR O$GOD.
;
;      JSR  SCNGF            CALL TO SCAN GOTO FIELD
;      (XR)                  RESULT (SEE ABOVE)
;      (XL,WA,WB,WC)         DESTROYED
;
	.ENABLE	LOCAL_BLOCK
SCNGF::	;PRC			;ENTRY POINT
	JSB	SCANE		;SCAN INITIAL ELEMENT
	CMPL	R10,#T$LPR	;SKIP IF LEFT PAREN (NORMAL GOTO)
	BEQLU	SCNG1
	CMPL	R10,#T$LBR	;SKIP IF LEFT BRACKET (DIRECT GOTO)
	BEQLU	SCNG2
	JMP	ERROR_234	;SYNTAX ERROR. GOTO FIELD INCORRECT
;
;      HERE FOR LEFT PAREN (NORMAL GOTO)
;
SCNG1::	MOVL	#NUM01,R7	;SET EXPAN FLAG FOR NORMAL GOTO
	JSB	EXPAN		;ANALYZE GOTO FIELD
	CMPL	R9,STATE	;JUMP TO EXIT IF SIMPLE LABEL NAME
	BLEQU	SCNG4
	MOVL	#OPDVN,R6	;ELSE POINT TO OPDV FOR COMPLEX GOTO
	JMP	SCNG3		;AND MERGE
;
;      HERE FOR LEFT BRACKET (DIRECT GOTO)
;
SCNG2::	MOVL	#NUM02,R7	;SET EXPAN FLAG FOR DIRECT GOTO
	JSB	EXPAN		;SCAN GOTO FIELD
	MOVL	#OPDVD,R6	;SET OPDV POINTER FOR DIRECT GOTO
	.PAGE
;
;      SCNGF (CONTINUED)
;
;      MERGE HERE TO BUILD OUTER UNARY OPERATOR BLOCK
;
SCNG3::	MOVL	R6,-(SP)	;STACK OPERATOR DV POINTER
	MOVL	R9,-(SP)	;STACK POINTER TO EXPRESSION TREE
	JSB	EXPOP		;POP OPERATOR OFF
	MOVL	(SP)+,R9	;RELOAD NEW EXPRESSION TREE POINTER
;
;      COMMON EXIT POINT
;
SCNG4::	RSB			;RETURN TO CALLER
	;ENP			;END PROCEDURE SCNGF
	.PAGE
;
;      SETVR -- SET VRGET,VRSTO FIELDS OF VRBLK
;
;      SETVR SETS THE PROPER VALUES IN THE VRGET AND VRSTO
;      FIELDS OF A VRBLK. IT IS CALLED WHENEVER TRBLKS ARE
;      ADDED OR SUBTRACTED (TRACE,STOPTR,INPUT,OUTPUT,DETACH)
;
;      (XR)                  POINTER TO VRBLK
;      JSR  SETVR            CALL TO SET FIELDS
;      (XL,WA)               DESTROYED
;
;      NOTE THAT SETVR IGNORES THE CALL IF XR DOES NOT POINT
;      INTO THE STATIC REGION (I.E. IS SOME OTHER NAME BASE)
;
	.ENABLE	LOCAL_BLOCK
SETVR::	;PRC			;ENTRY POINT
	CMPL	R9,STATE	;EXIT IF NOT NATURAL VARIABLE
	BGEQU	SETV1
;
;      HERE IF WE HAVE A VRBLK
;
	MOVL	R9,R10		;COPY VRBLK POINTER
	MOVL	#B$VRL,4*VRGET(R9) ;STORE NORMAL GET VALUE
	CMPL	4*VRSTO(R9),#B$VRE ;SKIP IF PROTECTED VARIABLE
	BEQLU	SETV1
	MOVL	#B$VRS,4*VRSTO(R9) ;STORE NORMAL STORE VALUE
	MOVL	4*VRVAL(R10),R10;POINT TO NEXT ENTRY ON CHAIN
	CMPL	(R10),#B$TRT	;JUMP IF END OF TRBLK CHAIN
	BNEQU	SETV1
	MOVL	#B$VRA,4*VRGET(R9) ;STORE TRAPPED ROUTINE ADDRESS
	MOVL	#B$VRV,4*VRSTO(R9) ;SET TRAPPED ROUTINE ADDRESS
;
;      MERGE HERE TO EXIT TO CALLER
;
SETV1::	RSB			;RETURN TO SETVR CALLER
	;ENP			;END PROCEDURE SETVR
	.IF NOT_EQUAL CNSR
	.IF_FALSE
	.PAGE
;
;      SORTA -- SORT ARRAY
;
;      ROUTINE TO SORT AN ARRAY OR TABLE ON SAME BASIS AS IN
;      SITBOL. A TABLE IS CONVERTED TO AN ARRAY, LEAVING TWO
;      DIMENSIONAL ARRAYS AND VECTORS AS CASES TO BE CONSIDERED.
;      WHOLE ROWS OF ARRAYS ARE PERMUTED ACCORDING TO THE
;      ORDERING OF THE KEYS THEY CONTAIN, AND THE STRIDE
;      REFERRED TO, IS THE THE LENGTH OF A ROW. IT IS ONE
;      FOR A VECTOR.
;      THE SORT USED IS HEAPSORT, FUNDAMENTALS OF DATA STRUCTURE
;      HOROWITZ AND SAHNI, PITMAN 1977, PAGE 347.
;      IT IS AN ORDER N*LOG(N) ALGORITHM. IN ORDER
;      TO MAKE IT STABLE, COMPARANDS MAY NOT COMPARE EQUAL. THIS
;      IS ACHIEVED BY SORTING A COPY ARRAY (REFERRED TO AS THE
;      SORT ARRAY) CONTAINING AT ITS HIGH ADDRESS END, BYTE
;      OFFSETS TO THE ROWS TO BE SORTED HELD IN THE ORIGINAL
;      ARRAY (REFERRED TO AS THE KEY ARRAY). SORTC, THE
;      COMPARISON ROUTINE, ACCESSES THE KEYS THROUGH THESE
;      OFFSETS AND IN THE CASE OF EQUALITY, RESOLVES IT BY
;      COMPARING THE OFFSETS THEMSELVES. THE SORT PERMUTES THE
;      OFFSETS WHICH ARE THEN USED IN A FINAL OPERATION TO COPY
;      THE ACTUAL ITEMS INTO THE NEW ARRAY IN SORTED ORDER.
;      REFERENCES TO ZEROTH ITEM ARE TO NOTIONAL ITEM
;      PRECEDING FIRST ACTUAL ITEM.
;      REVERSE SORTING FOR RSORT IS DONE BY HAVING THE LESS THAN
;      TEST FOR KEYS EFFECTIVELY BE REPLACED BY A
;      GREATER THAN TEST.
;
;      1(XS)                 FIRST ARG - ARRAY OR TABLE
;      0(XS)                 2ND ARG - INDEX OR PDTYPE NAME
;      (WA)                  0 , NON-ZERO FOR SORT , RSORT
;      JSR  SORTA            CALL TO SORT ARRAY
;      (XR)                  SORTED ARRAY
;      (XL,WA,WB,WC)         DESTROYED
	.PAGE
;
;      SORTA (CONTINUED)
;
	.ENABLE	LOCAL_BLOCK
SORTA::	MOVL	(SP)+,SORTA_SAVE;ENTRY POINT
	.SAVE_PSECT LOCAL_BLOCK
	.PSECT	PRC_SAVE,NOEXE
SORTA_SAVE::.LONG	0
	.RESTORE_PSECT
	MOVL	R6,SRTSR	;SORT/RSORT INDICATOR
	MOVL	#4*NUM01,SRTST	;DEFAULT STRIDE OF 1
	CLRL	SRTOF		;DEFAULT ZERO OFFSET TO SORT KEY
	MOVL	#NULLS,SRTDF	;CLEAR DATATYPE FIELD NAME
	MOVL	(SP)+,R$SXR	;UNSTACK ARGUMENT 2
	MOVL	(SP)+,R9	;GET FIRST ARGUMENT
	JSB	GTARR		;CONVERT TO ARRAY
	.ADDRESS SRT16		;FAIL
	MOVL	R9,-(SP)	;STACK PTR TO RESULTING KEY ARRAY
	MOVL	R9,-(SP)	;ANOTHER COPY FOR COPYB
	JSB	COPYB		;GET COPY ARRAY FOR SORTING INTO
	.ADDRESS INVALID$	;CANT FAIL
	MOVL	R9,-(SP)	;STACK POINTER TO SORT ARRAY
	MOVL	R$SXR,R9	;GET SECOND ARG
	MOVL	4*1(SP),R10	;GET PTR TO KEY ARRAY
	CMPL	(R10),#B$VCT	;JUMP IF ARBLK
	BNEQU	SRT02
	CMPL	R9,#NULLS	;JUMP IF NULL SECOND ARG
	BEQLU	SRT01
	JSB	GTNVR		;GET VRBLK PTR FOR IT
	.ADDRESS ERROR_257	;ERRONEOUS 2ND ARG IN SORT/RSORT OF VECTOR
	MOVL	R9,SRTDF	;STORE DATATYPE FIELD NAME VRBLK
;
;      COMPUTE N AND OFFSET TO ITEM A(0) IN VECTOR CASE
;
SRT01::	MOVL	#4*VCLEN,R8	;OFFSET TO A(0)
	MOVL	#4*VCVLS,R7	;OFFSET TO FIRST ITEM
	MOVL	4*VCLEN(R10),R6	;GET BLOCK LENGTH
	SUBL2	#4*VCSI$,R6	;GET NO. OF ENTRIES, N (IN BYTES)
	JMP	SRT04		;MERGE
;
;      HERE FOR ARRAY
;
SRT02::	MOVL	4*ARDIM(R10),R5	;GET POSSIBLE DIMENSION
	MFI	R6		;CONVERT TO SHORT INTEGER
	MOVAL	0[R6],R6	;FURTHER CONVERT TO BAUS
	MOVL	#4*ARVLS,R7	;OFFSET TO FIRST VALUE IF ONE
	MOVL	#4*ARPRO,R8	;OFFSET BEFORE VALUES IF ONE DIM.
	CMPL	4*ARNDM(R10),#NUM01 ;JUMP IN FACT IF ONE DIM.
	BNEQU	5254$
	JMP	SRT04
5254$:
	CMPL	4*ARNDM(R10),#NUM02 ;FAIL UNLESS TWO DIMENS
	BEQLU	5255$
	JMP	SRT16
5255$:
	MOVL	4*ARLB2(R10),R5	;GET LOWER BOUND 2 AS DEFAULT
	CMPL	R9,#NULLS	;JUMP IF DEFAULT SECOND ARG
	BEQLU	SRT03
	JSB	GTINT		;CONVERT TO INTEGER
	.ADDRESS SRT17		;FAIL
	MOVL	4*ICVAL(R9),R5	;GET ACTUAL INTEGER VALUE
	.PAGE
;
;      SORTA (CONTINUED)
;
;      HERE WITH SORT COLUMN INDEX IN IA IN ARRAY CASE
;
SRT03::	SUBL2	4*ARLB2(R10),R5	;SUBTRACT LOW BOUND
	BVC	5256$
	JMP	SRT17
5256$:
	TSTL	R5		;FAIL IF BELOW LOW BOUND
	BGEQ	5257$
	JMP	SRT17
5257$:
	SUBL2	4*ARDM2(R10),R5	;CHECK AGAINST DIMENSION
	BLSS	5258$
	JMP	SRT17
5258$:
	ADDL2	4*ARDM2(R10),R5	;RESTORE VALUE
	MFI	R6		;GET AS SMALL INTEGER
	MOVAL	0[R6],R6	;OFFSET WITHIN ROW TO KEY
	MOVL	R6,SRTOF	;KEEP OFFSET
	MOVL	4*ARDM2(R10),R5	;SECOND DIMENSION IS ROW LENGTH
	MFI	R6		;CONVERT TO SHORT INTEGER
	MOVL	R6,R9		;COPY ROW LENGTH
	MOVAL	0[R6],R6	;CONVERT TO BYTES
	MOVL	R6,SRTST	;STORE AS STRIDE
	MOVL	4*ARDIM(R10),R5	;GET NUMBER OF ROWS
	MFI	R6		;AS A SHORT INTEGER
	MOVAL	0[R6],R6	;CONVERT N TO BAUS
	MOVL	4*ARLEN(R10),R8	;OFFSET PAST ARRAY END
	SUBL2	R6,R8		;ADJUST, GIVING SPACE FOR N OFFSETS
	SUBL2	#4,R8		;POINT TO A(0)
	MOVL	4*AROFS(R10),R7	;OFFSET TO WORD BEFORE FIRST ITEM
	ADDL2	#4,R7		;OFFSET TO FIRST ITEM
;
;      SEPARATE PRE-PROCESSING FOR ARRAYS AND VECTORS DONE.
;      TO SIMPLIFY LATER KEY COMPARISONS, REMOVAL OF ANY TRBLK
;      TRAP BLOCKS FROM ENTRIES IN KEY ARRAY IS EFFECTED.
;
;      (XL) = 1(XS) = POINTER TO KEY ARRAY
;      (XS) = POINTER TO SORT ARRAY
;      WA = NUMBER OF ITEMS, N (CONVERTED TO BYTES).
;      WB = OFFSET TO FIRST ITEM OF ARRAYS.
;      WC = OFFSET TO A(0)
;
SRT04::	CMPL	R6,#4*NUM01	;RETURN IF ONLY A SINGLE ITEM
	BGTRU	5259$
	JMP	SRT15
5259$:
	MOVL	R6,SRTSN	;STORE NUMBER OF ITEMS (IN BAUS)
	MOVL	R8,SRTSO	;STORE OFFSET TO A(0)
	MOVL	4*ARLEN(R10),R8	;LENGTH OF ARRAY OR VEC (=VCLEN)
	ADDL2	R10,R8		;POINT PAST END OF ARRAY OR VECTOR
	MOVL	R7,SRTSF	;STORE OFFSET TO FIRST ROW
	ADDL2	R7,R10		;POINT TO FIRST ITEM IN KEY ARRAY
;
;      LOOP THROUGH ARRAY
;
SRT05::	MOVL	(R10),R9	;GET AN ENTRY
;
;      HUNT ALONG TRBLK CHAIN
;
SRT06::	CMPL	(R9),#B$TRT	;JUMP OUT IF NOT TRBLK
	BNEQU	SRT07
	MOVL	4*TRVAL(R9),R9	;GET VALUE FIELD
	JMP	SRT06		;LOOP
	.PAGE
;
;      SORTA (CONTINUED)
;
;      XR IS VALUE FROM END OF CHAIN
;
SRT07::	MOVL	R9,(R10)+	;STORE AS ARRAY ENTRY
	CMPL	R10,R8		;LOOP IF NOT DONE
	BLSSU	SRT05
	MOVL	(SP),R10	;GET ADRS OF SORT ARRAY
	MOVL	SRTSF,R9	;INITIAL OFFSET TO FIRST KEY
	MOVL	SRTST,R7	;GET STRIDE
	ADDL2	SRTSO,R10	;OFFSET TO A(0)
	ADDL2	#4,R10		;POINT TO A(1)
	MOVL	SRTSN,R8	;GET N
	ASHL	#-2,R8,R8	;CONVERT FROM BYTES
	MOVL	R8,SRTNR	;STORE AS ROW COUNT
				;LOOP COUNTER
;
;      STORE KEY OFFSETS AT TOP OF SORT ARRAY
;
SRT08::	MOVL	R9,(R10)+	;STORE AN OFFSET
	ADDL2	R7,R9		;BUMP OFFSET BY STRIDE
	SOBGTR	R8,SRT08	;LOOP THROUGH ROWS
;
;      PERFORM THE SORT ON OFFSETS IN SORT ARRAY.
;
;      (SRTSN)               NUMBER OF ITEMS TO SORT, N (BYTES)
;      (SRTSO)               OFFSET TO A(0)
;
SRT09::	MOVL	SRTSN,R6	;GET N
	MOVL	SRTNR,R8	;GET NUMBER OF ROWS
	ASHL	#-1,R8,R8	;I = N / 2 (WC=I, INDEX INTO ARRAY)
	MOVAL	0[R8],R8	;CONVERT BACK TO BYTES
;
;      LOOP TO FORM INITIAL HEAP
;
SRT10::	JSB	SORTH		;SORTH(I,N)
	SUBL2	#4,R8		;I = I - 1
	BNEQU	SRT10
	MOVL	R6,R8		;I = N
;
;      SORTING LOOP. AT THIS POINT, A(1) IS THE LARGEST
;      ITEM, SINCE ALGORITHM INITIALISES IT AS, AND THEN MAINTAI
;      IT AS, ROOT OF TREE.
;
SRT11::	SUBL2	#4,R8		;I = I - 1 (N - 1 INITIALLY)
	BEQLU	SRT12
	MOVL	(SP),R9		;GET SORT ARRAY ADDRESS
	ADDL2	SRTSO,R9	;POINT TO A(0)
	MOVL	R9,R10		;A(0) ADDRESS
	ADDL2	R8,R10		;A(I) ADDRESS
	MOVL	4*1(R10),R7	;COPY A(I+1)
	MOVL	4*1(R9),4*1(R10);MOVE A(1) TO A(I+1)
	MOVL	R7,4*1(R9)	;COMPLETE EXCHANGE OF A(1), A(I+1)
	MOVL	R8,R6		;N = I FOR SORTH
	MOVL	#4*NUM01,R8	;I = 1 FOR SORTH
	JSB	SORTH		;SORTH(1,N)
	MOVL	R6,R8		;RESTORE WC
	JMP	SRT11		;LOOP
	.PAGE
;
;      SORTA (CONTINUED)
;
;      OFFSETS HAVE BEEN PERMUTED INTO REQUIRED ORDER BY SORT.
;      COPY ARRAY ELEMENTS OVER THEM.
;
SRT12::	MOVL	(SP),R10	;BASE ADRS OF KEY ARRAY
	MOVL	R10,R8		;COPY IT
	ADDL2	SRTSO,R8	;OFFSET OF A(0)
	ADDL2	SRTSF,R10	;ADRS OF FIRST ROW OF SORT ARRAY
	MOVL	SRTST,R7	;GET STRIDE
	ASHL	#-2,R7,R7	;CONVERT TO WORDS
;
;      COPYING LOOP FOR SUCCESSIVE ITEMS. SORTED OFFSETS ARE
;      HELD AT END OF SORT ARRAY.
;
SRT13::	ADDL2	#4,R8		;ADRS OF NEXT OF SORTED OFFSETS
	MOVL	R8,R9		;COPY IT FOR ACCESS
	MOVL	(R9),R9		;GET OFFSET
	ADDL2	4*1(SP),R9	;ADD KEY ARRAY BASE ADRS
	MOVL	R7,R6		;GET COUNT OF WORDS IN ROW
;
;      COPY A COMPLETE ROW
;
SRT14::	MOVL	(R9)+,(R10)+	;MOVE A WORD
	SOBGTR	R6,SRT14	;LOOP
	DECL	SRTNR		;DECREMENT ROW COUNT
	TSTL	SRTNR		;REPEAT TILL ALL ROWS DONE
	BNEQU	SRT13
;
;      RETURN POINT
;
SRT15::	MOVL	(SP)+,R9	;POP RESULT ARRAY PTR
	ADDL2	#4,SP		;POP KEY ARRAY PTR
	CLRL	R$SXL		;CLEAR JUNK
	CLRL	R$SXR		;CLEAR JUNK
	JMP	@SORTA_SAVE	;RETURN
;
;      ERROR POINT
;
SRT16::	JMP	ERROR_256	;SORT/RSORT 1ST ARG NOT SUITABLE ARRAY OR TABLE
SRT17::	JMP	ERROR_258	;SORT/RSORT 2ND ARG OUT OF RANGE OR NON-INTEGER
	;ENP			;END PROCUDURE SORTA
	.PAGE
;
;      SORTC --  COMPARE SORT KEYS
;
;      COMPARE TWO SORT KEYS GIVEN THEIR OFFSETS. IF
;      EQUAL, COMPARE KEY OFFSETS TO GIVE STABLE SORT.
;      NOTE THAT IF SRTSR IS NON-ZERO (REQUEST FOR REVERSE
;      SORT), THE QUOTED RETURNS ARE INVERTED.
;      FOR OBJECTS OF DIFFERING DATATYPES, THE ENTRY POINT
;      IDENTIFICATIONS ARE COMPARED.
;
;      (XL)                  BASE ADRS FOR KEYS
;      (WA)                  OFFSET TO KEY 1 ITEM
;      (WB)                  OFFSET TO KEY 2 ITEM
;      (SRTSR)               ZERO/NON-ZERO FOR SORT/RSORT
;      (SRTOF)               OFFSET WITHIN ROW TO COMPARANDS
;      JSR  SORTC            CALL TO COMPARE KEYS
;      PPM  LOC              KEY1 LESS THAN KEY2
;                            NORMAL RETURN, KEY1 GT THAN KEY2
;      (XL,XR,WA,WB)         DESTROYED
;
	.ENABLE	LOCAL_BLOCK
SORTC::	;PRC			;ENTRY POINT
	MOVL	R6,SRTS1	;SAVE OFFSET 1
	MOVL	R7,SRTS2	;SAVE OFFSET 2
	MOVL	R8,SRTSC	;SAVE WC
	ADDL2	SRTOF,R10	;ADD OFFSET TO COMPARAND FIELD
	MOVL	R10,R9		;COPY BASE + OFFSET
	ADDL2	R6,R10		;ADD KEY1 OFFSET
	ADDL2	R7,R9		;ADD KEY2 OFFSET
	MOVL	(R10),R10	;GET KEY1
	MOVL	(R9),R9		;GET KEY2
	CMPL	SRTDF,#NULLS	;JUMP IF DATATYPE FIELD NAME USED
	BEQLU	5260$
	JMP	SRC11
5260$:
	.PAGE
;
;      SORTC (CONTINUED)
;
;      MERGE AFTER DEALING WITH FIELD NAME. TRY FOR STRINGS.
;
SRC01::	MOVL	(R10),R8	;GET TYPE CODE
	CMPL	R8,(R9)		;SKIP IF NOT SAME DATATYPE
	BNEQU	SRC02
	CMPL	R8,#B$SCL	;JUMP IF BOTH STRINGS
	BEQLU	SRC09
;
;      NOW TRY FOR NUMERIC
;
SRC02::	MOVL	R10,R$SXL	;KEEP ARG1
	MOVL	R9,R$SXR	;KEEP ARG2
	MOVL	R10,-(SP)	;STACK
	MOVL	R9,-(SP)	;ARGS
	JSB	ACOMP		;COMPARE OBJECTS
	.ADDRESS SRC10		;NOT NUMERIC
	.ADDRESS SRC10		;NOT NUMERIC
	.ADDRESS SRC03		;KEY1 LESS
	.ADDRESS SRC08		;KEYS EQUAL
	.ADDRESS SRC05		;KEY1 GREATER
;
;      RETURN IF KEY1 SMALLER (SORT), GREATER (RSORT)
;
SRC03::	TSTL	SRTSR		;JUMP IF RSORT
	BNEQU	SRC06
;
SRC04::	MOVL	SRTSC,R8	;RESTORE WC
	MOVL	(SP)+,R11	;RETURN
	JMP	@(R11)+
;
;      RETURN IF KEY1 GREATER (SORT), SMALLER (RSORT)
;
SRC05::	TSTL	SRTSR		;JUMP IF RSORT
	BNEQU	SRC04
;
SRC06::	MOVL	SRTSC,R8	;RESTORE WC
	ADDL2	#4*1,(SP)	;RETURN
	RSB
;
;      KEYS ARE OF SAME DATATYPE
;
SRC07::	CMPL	R10,R9		;ITEM FIRST CREATED IS LESS
	BLSSU	SRC03
	CMPL	R10,R9		;ADDRESSES RISE IN ORDER OF CREATION
	BGTRU	SRC05
;
;      DROP THROUGH OR MERGE FOR IDENTICAL OR EQUAL OBJECTS
;
SRC08::	CMPL	SRTS1,SRTS2	;TEST OFFSETS OR KEY ADDRSS INSTEAD
	BLSSU	SRC04
	JMP	SRC06		;OFFSET 1 GREATER
	.PAGE
;
;      SORTC (CONTINUED)
;
;      STRINGS
;
SRC09::	MOVL	R10,-(SP)	;STACK
	MOVL	R9,-(SP)	;ARGS
	JSB	LCOMP		;COMPARE OBJECTS
	.ADDRESS INVALID$	;CANT
	.ADDRESS INVALID$	;FAIL
	.ADDRESS SRC03		;KEY1 LESS
	.ADDRESS SRC08		;KEYS EQUAL
	.ADDRESS SRC05		;KEY1 GREATER
;
;      ARITHMETIC COMPARISON FAILED - RECOVER ARGS
;
SRC10::	MOVL	R$SXL,R10	;GET ARG1
	MOVL	R$SXR,R9	;GET ARG2
	MOVL	(R10),R8	;GET TYPE OF KEY1
	CMPL	R8,(R9)		;JUMP IF KEYS OF SAME TYPE
	BEQLU	SRC07
	MOVL	R8,R10		;GET BLOCK TYPE WORD
	MOVL	(R9),R9		;GET BLOCK TYPE WORD
	MOVZWL	-2(R10),R10	;ENTRY POINT ID FOR KEY1
	MOVZWL	-2(R9),R9	;ENTRY POINT ID FOR KEY2
	CMPL	R10,R9		;JUMP IF KEY1 GT KEY2
	BGTRU	SRC05
	JMP	SRC03		;KEY1 LT KEY2
;
;      DATATYPE FIELD NAME USED
;
SRC11::	JSB	SORTF		;CALL ROUTINE TO FIND FIELD 1
	MOVL	R10,-(SP)	;STACK ITEM POINTER
	MOVL	R9,R10		;GET KEY2
	JSB	SORTF		;FIND FIELD 2
	MOVL	R10,R9		;PLACE AS KEY2
	MOVL	(SP)+,R10	;RECOVER KEY1
	JMP	SRC01		;MERGE
	;ENP			;PROCEDURE SORTC
	.PAGE
;
;      SORTF -- FIND FIELD FOR SORTC
;
;      ROUTINE USED BY SORTC TO OBTAIN ITEM CORRESPONDING
;      TO A GIVEN FIELD NAME, IF THIS EXISTS, IN A PROGRAMMER
;      DEFINED OBJECT PASSED AS ARGUMENT.
;      IF SUCH A MATCH OCCURS, RECORD IS KEPT OF DATATYPE
;      NAME, FIELD NAME AND OFFSET TO FIELD IN ORDER TO
;      SHORT-CIRCUIT LATER SEARCHES ON SAME TYPE. NOTE THAT
;      DFBLKS ARE STORED IN STATIC AND HENCE CANNOT BE MOVED.
;
;      (SRTDF)               VRBLK POINTER OF FIELD NAME
;      (XL)                  POSSIBLE PDBLK POINTER
;      JSR  SORTF            CALL TO SEARCH FOR FIELD NAME
;      (XL)                  ITEM FOUND OR ORIGINAL PDBLK PTR
;      (WC)                  DESTROYED
;
	.ENABLE	LOCAL_BLOCK
SORTF::	;PRC			;ENTRY POINT
	CMPL	(R10),#B$PDT	;RETURN IF NOT PDBLK
	BNEQU	SRTF3
	MOVL	R9,-(SP)	;KEEP XR
	MOVL	SRTFD,R9	;GET POSSIBLE FORMER DFBLK PTR
	BEQLU	SRTF4
	CMPL	R9,4*PDDFP(R10)	;JUMP IF NOT RIGHT DATATYPE
	BNEQU	SRTF4
	CMPL	SRTDF,SRTFF	;JUMP IF NOT RIGHT FIELD NAME
	BNEQU	SRTF4
	ADDL2	SRTFO,R10	;ADD OFFSET TO REQUIRED FIELD
;
;      HERE WITH XL POINTING TO FOUND FIELD
;
SRTF1::	MOVL	(R10),R10	;GET ITEM FROM FIELD
;
;      RETURN POINT
;
SRTF2::	MOVL	(SP)+,R9	;RESTORE XR
;
SRTF3::	RSB			;RETURN
	.PAGE
;
;      SORTF (CONTINUED)
;
;      CONDUCT A SEARCH
;
SRTF4::	MOVL	R10,R9		;COPY ORIGINAL POINTER
	MOVL	4*PDDFP(R9),R9	;POINT TO DFBLK
	MOVL	R9,SRTFD	;KEEP A COPY
	MOVL	4*FARGS(R9),R8	;GET NUMBER OF FIELDS
	MOVAL	0[R8],R8	;CONVERT TO BYTES
	ADDL2	4*DFLEN(R9),R9	;POINT PAST LAST FIELD
;
;      LOOP TO FIND NAME IN PDFBLK
;
SRTF5::	SUBL2	#4,R8		;COUNT DOWN
	SUBL2	#4,R9		;POINT IN FRONT
	CMPL	(R9),SRTDF	;SKIP OUT IF FOUND
	BEQLU	SRTF6
	TSTL	R8		;LOOP
	BNEQU	SRTF5
	JMP	SRTF2		;RETURN - NOT FOUND
;
;      FOUND
;
SRTF6::	MOVL	(R9),SRTFF	;KEEP FIELD NAME PTR
	ADDL2	#4*PDFLD,R8	;ADD OFFSET TO FIRST FIELD
	MOVL	R8,SRTFO	;STORE AS FIELD OFFSET
	ADDL2	R8,R10		;POINT TO FIELD
	JMP	SRTF1		;RETURN
	;ENP			;PROCEDURE SORTF
	.PAGE
;
;      SORTH -- HEAP ROUTINE FOR SORTA
;
;      THIS ROUTINE CONSTRUCTS A HEAP FROM ELEMENTS OF ARRAY, A.
;      IN THIS APPLICATION, THE ELEMENTS ARE OFFSETS TO KEYS IN
;      A KEY ARRAY.
;
;      (XS)                  POINTER TO SORT ARRAY BASE
;      1(XS)                 POINTER TO KEY ARRAY BASE
;      (WA)                  MAX ARRAY INDEX, N (IN BYTES)
;      (WC)                  OFFSET J IN A TO ROOT (IN *1 TO *N)
;      JSR  SORTH            CALL SORTH(J,N) TO MAKE HEAP
;      (XL,XR,WB)            DESTROYED
;
	.ENABLE	LOCAL_BLOCK
SORTH::	MOVL	(SP)+,SORTH_SAVE;ENTRY POINT
	.SAVE_PSECT LOCAL_BLOCK
	.PSECT	PRC_SAVE,NOEXE
SORTH_SAVE::.LONG	0
	.RESTORE_PSECT
	MOVL	R6,SRTSN	;SAVE N
	MOVL	R8,SRTWC	;KEEP WC
	MOVL	(SP),R10	;SORT ARRAY BASE ADRS
	ADDL2	SRTSO,R10	;ADD OFFSET TO A(0)
	ADDL2	R8,R10		;POINT TO A(J)
	MOVL	(R10),SRTRT	;GET OFFSET TO ROOT
	ADDL2	R8,R8		;DOUBLE J - CANT EXCEED N
;
;      LOOP TO MOVE DOWN TREE USING DOUBLED INDEX J
;
SRH01::	CMPL	R8,SRTSN	;DONE IF J GT N
	BLEQU	5261$
	JMP	SRH03
5261$:
	CMPL	R8,SRTSN	;SKIP IF J EQUALS N
	BEQLU	SRH02
	MOVL	(SP),R9		;SORT ARRAY BASE ADRS
	MOVL	4*1(SP),R10	;KEY ARRAY BASE ADRS
	ADDL2	SRTSO,R9	;POINT TO A(0)
	ADDL2	R8,R9		;ADRS OF A(J)
	MOVL	4*1(R9),R6	;GET A(J+1)
	MOVL	(R9),R7		;GET A(J)
;
;      COMPARE SONS. (WA) RIGHT SON, (WB) LEFT SON
;
	JSB	SORTC		;COMPARE KEYS - LT(A(J+1),A(J))
	.ADDRESS SRH02		;A(J+1) LT A(J)
	ADDL2	#4,R8		;POINT TO GREATER SON, A(J+1)
	.PAGE
;
;      SORTH (CONTINUED)
;
;      COMPARE ROOT WITH GREATER SON
;
SRH02::	MOVL	4*1(SP),R10	;KEY ARRAY BASE ADRS
	MOVL	(SP),R9		;GET SORT ARRAY ADDRESS
	ADDL2	SRTSO,R9	;ADRS OF A(0)
	MOVL	R9,R7		;COPY THIS ADRS
	ADDL2	R8,R9		;ADRS OF GREATER SON, A(J)
	MOVL	(R9),R6		;GET A(J)
	MOVL	R7,R9		;POINT BACK TO A(0)
	MOVL	SRTRT,R7	;GET ROOT
	JSB	SORTC		;COMPARE THEM - LT(A(J),ROOT)
	.ADDRESS SRH03		;FATHER EXCEEDS SONS - DONE
	MOVL	(SP),R9		;GET SORT ARRAY ADRS
	ADDL2	SRTSO,R9	;POINT TO A(0)
	MOVL	R9,R10		;COPY IT
	MOVL	R8,R6		;COPY J
	ASHL	#-2,R8,R8	;CONVERT TO WORDS
	ASHL	#-1,R8,R8	;GET J/2
	MOVAL	0[R8],R8	;CONVERT BACK TO BYTES
	ADDL2	R6,R10		;POINT TO A(J)
	ADDL2	R8,R9		;ADRS OF A(J/2)
	MOVL	(R10),(R9)	;A(J/2) = A(J)
	MOVL	R6,R8		;RECOVER J
	AOV	R8,R8,SRH03	;J = J*2. DONE IF TOO BIG
	JMP	SRH01		;LOOP
;
;      FINISH BY COPYING ROOT OFFSET BACK INTO ARRAY
;
SRH03::	ASHL	#-2,R8,R8	;CONVERT TO WORDS
	ASHL	#-1,R8,R8	;J = J/2
	MOVAL	0[R8],R8	;CONVERT BACK TO BYTES
	MOVL	(SP),R9		;SORT ARRAY ADRS
	ADDL2	SRTSO,R9	;ADRS OF A(0)
	ADDL2	R8,R9		;ADRS OF A(J/2)
	MOVL	SRTRT,(R9)	;A(J/2) = ROOT
	MOVL	SRTSN,R6	;RESTORE WA
	MOVL	SRTWC,R8	;RESTORE WC
	JMP	@SORTH_SAVE	;RETURN
	;ENP			;END PROCEDURE SORTH
	.PAGE
	.ENDC
	.PAGE
;
;      TFIND -- LOCATE TABLE ELEMENT
;
;      (XR)                  SUBSCRIPT VALUE FOR ELEMENT
;      (XL)                  POINTER TO TABLE
;      (WB)                  ZERO BY VALUE, NON-ZERO BY NAME
;      JSR  TFIND            CALL TO LOCATE ELEMENT
;      PPM  LOC              TRANSFER LOCATION IF ACCESS FAILS
;      (XR)                  ELEMENT VALUE (IF BY VALUE)
;      (XR)                  DESTROYED (IF BY NAME)
;      (XL,WA)               TEBLK NAME (IF BY NAME)
;      (XL,WA)               DESTROYED (IF BY VALUE)
;      (WC,RA)               DESTROYED
;
;      NOTE THAT IF A CALL BY VALUE SPECIFIES A NON-EXISTENT
;      SUBSCRIPT, NULL IS RETURNED WITHOUT BUILDING A NEW TEBLK.
;
	.ENABLE	LOCAL_BLOCK
TFIND::	;PRC			;ENTRY POINT
	MOVL	R7,-(SP)	;SAVE NAME/VALUE INDICATOR
	MOVL	R9,-(SP)	;SAVE SUBSCRIPT VALUE
	MOVL	R10,-(SP)	;SAVE TABLE POINTER
	MOVL	4*TBLEN(R10),R6	;LOAD LENGTH OF TBBLK
	ASHL	#-2,R6,R6	;CONVERT TO WORD COUNT
	SUBL2	#TBBUK,R6	;GET NUMBER OF BUCKETS
	MOVL	R6,R5		;CONVERT TO INTEGER VALUE
	MOVL	R5,TFNSI	;SAVE FOR LATER
	MOVL	(R9),R10	;LOAD FIRST WORD OF SUBSCRIPT
	MOVZWL	-2(R10),R10	;LOAD BLOCK ENTRY ID (BL$XX)
	BSW	R10,BL$$D,TFN00	;SWITCH ON BLOCK TYPE
	IFF	BL$IC,TFN02	;JUMP IF INTEGER
	.IF NOT_EQUAL CNRA
	.IF_FALSE
	IFF	BL$RC,TFN02	;REAL
	.ENDC
	IFF	BL$P0,TFN03	;JUMP IF PATTERN
	IFF	BL$P1,TFN03	;JUMP IF PATTERN
	IFF	BL$P2,TFN03	;JUMP IF PATTERN
	IFF	BL$NM,TFN04	;JUMP IF NAME
	IFF	BL$SC,TFN05	;JUMP IF STRING
	ESW			;END SWITCH ON BLOCK TYPE
;
;      HERE FOR BLOCKS FOR WHICH WE USE THE SECOND WORD OF THE
;      BLOCK AS THE HASH SOURCE (SEE BLOCK FORMATS FOR DETAILS).
;
TFN00::	MOVL	4*1(R9),R6	;LOAD SECOND WORD
;
;      MERGE HERE WITH ONE WORD HASH SOURCE IN WA
;
TFN01::	MOVL	R6,R5		;CONVERT TO INTEGER
	JMP	TFN06		;JUMP TO MERGE
	.PAGE
;
;      TFIND (CONTINUED)
;
;      HERE FOR INTEGER OR REAL
;
TFN02::	MOVL	4*1(R9),R5	;LOAD VALUE AS HASH SOURCE
	BGEQ	TFN06
	MNEGL	R5,R5		;MAKE POSITIVE
	BVS	TFN06
	JMP	TFN06		;MERGE
;
;      FOR PATTERN, USE FIRST WORD (PCODE) AS SOURCE
;
TFN03::	MOVL	(R9),R6		;LOAD FIRST WORD AS HASH SOURCE
	JMP	TFN01		;MERGE BACK
;
;      FOR NAME, USE OFFSET AS HASH SOURCE
;
TFN04::	MOVL	4*NMOFS(R9),R6	;LOAD OFFSET AS HASH SOURCE
	JMP	TFN01		;MERGE BACK
;
;      HERE FOR STRING
;
TFN05::	JSB	HASHS		;CALL ROUTINE TO COMPUTE HASH
;
;      MERGE HERE WITH HASH SOURCE IN (IA)
;
TFN06::	RMI	TFNSI		;COMPUTE HASH INDEX BY REMAINDERING
	MFI	R8		;GET AS ONE WORD INTEGER
	MOVAL	0[R8],R8	;CONVERT TO BYTE OFFSET
	MOVL	(SP),R10	;GET TABLE PTR AGAIN
	ADDL2	R8,R10		;POINT TO PROPER BUCKET
	MOVL	4*TBBUK(R10),R9	;LOAD FIRST TEBLK POINTER
	CMPL	R9,(SP)		;JUMP IF NO TEBLKS ON CHAIN
	BEQLU	TFN10
;
;      LOOP THROUGH TEBLKS ON HASH CHAIN
;
TFN07::	MOVL	R9,R7		;SAVE TEBLK POINTER
	MOVL	4*TESUB(R9),R9	;LOAD SUBSCRIPT VALUE
	MOVL	4*1(SP),R10	;LOAD INPUT ARGUMENT SUBSCRIPT VAL
	JSB	IDENT		;COMPARE THEM
	.ADDRESS TFN08		;JUMP IF EQUAL (IDENT)
;
;      HERE IF NO MATCH WITH THAT TEBLK
;
	MOVL	R7,R10		;RESTORE TEBLK POINTER
	MOVL	4*TENXT(R10),R9	;POINT TO NEXT TEBLK ON CHAIN
	CMPL	R9,(SP)		;JUMP IF THERE IS ONE
	BNEQU	TFN07
;
;      HERE IF NO MATCH WITH ANY TEBLK ON CHAIN
;
	MOVL	#4*TENXT,R8	;SET OFFSET TO LINK FIELD (XL BASE)
	JMP	TFN11		;JUMP TO MERGE
	.PAGE
;
;      TFIND (CONTINUED)
;
;      HERE WE HAVE FOUND A MATCHING ELEMENT
;
TFN08::	MOVL	R7,R10		;RESTORE TEBLK POINTER
	MOVL	#4*TEVAL,R6	;SET TEBLK NAME OFFSET
	MOVL	4*2(SP),R7	;RESTORE NAME/VALUE INDICATOR
	BNEQU	TFN09
	JSB	ACESS		;ELSE GET VALUE
	.ADDRESS TFN12		;JUMP IF REFERENCE FAILS
	CLRL	R7		;RESTORE NAME/VALUE INDICATOR
;
;      COMMON EXIT FOR ENTRY FOUND
;
TFN09::	ADDL2	#4*NUM03,SP	;POP STACK ENTRIES
	ADDL2	#4*1,(SP)	;RETURN TO TFIND CALLER
	RSB
;
;      HERE IF NO TEBLKS ON THE HASH CHAIN
;
TFN10::	ADDL2	#4*TBBUK,R8	;GET OFFSET TO BUCKET PTR
	MOVL	(SP),R10	;SET TBBLK PTR AS BASE
;
;      MERGE HERE WITH (XL,WC) BASE,OFFSET OF FINAL LINK
;
TFN11::	MOVL	(SP),R9		;TBBLK POINTER
	MOVL	4*TBINV(R9),R9	;LOAD DEFAULT VALUE IN CASE
	MOVL	4*2(SP),R7	;LOAD NAME/VALUE INDICATOR
	BEQLU	TFN09
;
;      HERE WE MUST BUILD A NEW TEBLK
;
	MOVL	#4*TESI$,R6	;SET SIZE OF TEBLK
	JSB	ALLOC		;ALLOCATE TEBLK
	ADDL2	R8,R10		;POINT TO HASH LINK
	MOVL	R9,(R10)	;LINK NEW TEBLK AT END OF CHAIN
	MOVL	#B$TET,(R9)	;STORE TYPE WORD
	MOVL	#NULLS,4*TEVAL(R9) ;SET NULL AS INITIAL VALUE
	MOVL	(SP)+,4*TENXT(R9);SET TBBLK PTR TO MARK END OF CHAIN
	MOVL	(SP)+,4*TESUB(R9);STORE SUBSCRIPT VALUE
	ADDL2	#4,SP		;POP PAST NAME/VALUE INDICATOR
	MOVL	R9,R10		;COPY TEBLK POINTER (NAME BASE)
	MOVL	#4*TEVAL,R6	;SET OFFSET
	ADDL2	#4*1,(SP)	;RETURN TO CALLER WITH NEW TEBLK
	RSB
;
;      ACESS FAIL RETURN
;
TFN12::	MOVL	(SP)+,R11	;ALTERNATIVE RETURN
	JMP	@(R11)+
	;ENP			;END PROCEDURE TFIND
	.PAGE
;
;      TRACE -- SET/RESET A TRACE ASSOCIATION
;
;      THIS PROCEDURE IS SHARED BY TRACE AND STOPTR TO
;      EITHER INITIATE OR STOP A TRACE RESPECTIVELY.
;
;      (XL)                  TRBLK PTR (TRACE) OR ZERO (STOPTR)
;      1(XS)                 FIRST ARGUMENT (NAME)
;      0(XS)                 SECOND ARGUMENT (TRACE TYPE)
;      JSR  TRACE            CALL TO SET/RESET TRACE
;      PPM  LOC              TRANSFER LOC IF 1ST ARG IS BAD NAME
;      PPM  LOC              TRANSFER LOC IF 2ND ARG IS BAD TYPE
;      (XS)                  POPPED
;      (XL,XR,WA,WB,WC,IA)   DESTROYED
;
	.ENABLE	LOCAL_BLOCK
TRACE::	MOVL	(SP)+,TRACE_SAVE;ENTRY POINT
	.SAVE_PSECT LOCAL_BLOCK
	.PSECT	PRC_SAVE,NOEXE
TRACE_SAVE::.LONG	0
	.RESTORE_PSECT
	JSB	GTSTG		;GET TRACE TYPE STRING
	.ADDRESS TRC15		;JUMP IF NOT STRING
	MOVAB	CFP$F(R9),R9	;ELSE POINT TO STRING
	MOVZBL	(R9),R6		;LOAD FIRST CHARACTER
	MOVL	(SP),R9		;LOAD NAME ARGUMENT
	MOVL	R10,(SP)	;STACK TRBLK PTR OR ZERO
	MOVL	#TRTAC,R8	;SET TRTYP FOR ACCESS TRACE
	CMPL	R6,#CH$LA	;JUMP IF A (ACCESS)
	BNEQU	5262$
	JMP	TRC10
5262$:
	MOVL	#TRTVL,R8	;SET TRTYP FOR VALUE TRACE
	CMPL	R6,#CH$LV	;JUMP IF V (VALUE)
	BNEQU	5263$
	JMP	TRC10
5263$:
	CMPL	R6,#CH$BL	;JUMP IF BLANK (VALUE)
	BNEQU	5264$
	JMP	TRC10
5264$:
;
;      HERE FOR L,K,F,C,R
;
	CMPL	R6,#CH$LF	;JUMP IF F (FUNCTION)
	BEQLU	TRC01
	CMPL	R6,#CH$LR	;JUMP IF R (RETURN)
	BEQLU	TRC01
	CMPL	R6,#CH$LL	;JUMP IF L (LABEL)
	BEQLU	TRC03
	CMPL	R6,#CH$LK	;JUMP IF K (KEYWORD)
	BNEQU	5265$
	JMP	TRC06
5265$:
	CMPL	R6,#CH$LC	;ELSE ERROR IF NOT C (CALL)
	BEQLU	5266$
	JMP	TRC15
5266$:
;
;      HERE FOR F,C,R
;
TRC01::	JSB	GTNVR		;POINT TO VRBLK FOR NAME
	.ADDRESS TRC16		;JUMP IF BAD NAME
	ADDL2	#4,SP		;POP STACK
	MOVL	4*VRFNC(R9),R9	;POINT TO FUNCTION BLOCK
	CMPL	(R9),#B$PFC	;ERROR IF NOT PROGRAM FUNCTION
	BEQLU	5267$
	JMP	TRC17
5267$:
	CMPL	R6,#CH$LR	;JUMP IF R (RETURN)
	BEQLU	TRC02
	.PAGE
;
;      TRACE (CONTINUED)
;
;      HERE FOR F,C TO SET/RESET CALL TRACE
;
	MOVL	R10,4*PFCTR(R9)	;SET/RESET CALL TRACE
	CMPL	R6,#CH$LC	;EXIT WITH NULL IF C (CALL)
	BNEQU	5268$
	JMP	EXNUL
5268$:
;
;      HERE FOR F,R TO SET/RESET RETURN TRACE
;
TRC02::	MOVL	R10,4*PFRTR(R9)	;SET/RESET RETURN TRACE
	ADDL3	#4*2,TRACE_SAVE,R11 ;RETURN
	JMP	(R11)
;
;      HERE FOR L TO SET/RESET LABEL TRACE
;
TRC03::	JSB	GTNVR		;POINT TO VRBLK
	.ADDRESS TRC16		;JUMP IF BAD NAME
	MOVL	4*VRLBL(R9),R10	;LOAD LABEL POINTER
	CMPL	(R10),#B$TRT	;JUMP IF NO OLD TRACE
	BNEQU	TRC04
	MOVL	4*TRLBL(R10),R10;ELSE DELETE OLD TRACE ASSOCIATION
;
;      HERE WITH OLD LABEL TRACE ASSOCIATION DELETED
;
TRC04::	CMPL	R10,#STNDL	;ERROR IF UNDEFINED LABEL
	BNEQU	5269$
	JMP	TRC16
5269$:
	MOVL	(SP)+,R7	;GET TRBLK PTR AGAIN
	BEQLU	TRC05
	MOVL	R7,4*VRLBL(R9)	;ELSE SET NEW TRBLK POINTER
	MOVL	#B$VRT,4*VRTRA(R9) ;SET LABEL TRACE ROUTINE ADDRESS
	MOVL	R7,R9		;COPY TRBLK POINTER
	MOVL	R10,4*TRLBL(R9)	;STORE REAL LABEL IN TRBLK
	ADDL3	#4*2,TRACE_SAVE,R11 ;RETURN
	JMP	(R11)
;
;      HERE FOR STOPTR CASE FOR LABEL
;
TRC05::	MOVL	R10,4*VRLBL(R9)	;STORE LABEL PTR BACK IN VRBLK
	MOVL	#B$VRG,4*VRTRA(R9) ;STORE NORMAL TRANSFER ADDRESS
	ADDL3	#4*2,TRACE_SAVE,R11 ;RETURN
	JMP	(R11)
	.PAGE
;
;      TRACE (CONTINUED)
;
;      HERE FOR K (KEYWORD)
;
TRC06::	JSB	GTNVR		;POINT TO VRBLK
	.ADDRESS TRC16		;ERROR IF NOT NATURAL VAR
	TSTL	4*VRLEN(R9)	;ERROR IF NOT SYSTEM VAR
	BEQLU	5270$
	JMP	TRC16
5270$:
	ADDL2	#4,SP		;POP STACK
	TSTL	R10		;JUMP IF STOPTR CASE
	BEQLU	TRC07
	MOVL	R9,4*TRKVR(R10)	;STORE VRBLK PTR IN TRBLK FOR KTREX
;
;      MERGE HERE WITH TRBLK SET UP IN WB (OR ZERO)
;
TRC07::	MOVL	4*VRSVP(R9),R9	;POINT TO SVBLK
	CMPL	R9,#V$ERT	;JUMP IF ERRTYPE
	BEQLU	TRC08
	CMPL	R9,#V$STC	;JUMP IF STCOUNT
	BEQLU	TRC09
	CMPL	R9,#V$FNC	;ELSE ERROR IF NOT FNCLEVEL
	BEQLU	5271$
	JMP	TRC17
5271$:
;
;      FNCLEVEL
;
	MOVL	R10,R$FNC	;SET/RESET FNCLEVEL TRACE
	ADDL3	#4*2,TRACE_SAVE,R11 ;RETURN
	JMP	(R11)
;
;      ERRTYPE
;
TRC08::	MOVL	R10,R$ERT	;SET/RESET ERRTYPE TRACE
	ADDL3	#4*2,TRACE_SAVE,R11 ;RETURN
	JMP	(R11)
;
;      STCOUNT
;
TRC09::	MOVL	R10,R$STC	;SET/RESET STCOUNT TRACE
	ADDL3	#4*2,TRACE_SAVE,R11 ;RETURN
	JMP	(R11)
	.PAGE
;
;      TRACE (CONTINUED)
;
;      A,V MERGE HERE WITH TRTYP VALUE IN WC
;
TRC10::	JSB	GTVAR		;LOCATE VARIABLE
	.ADDRESS TRC16		;ERROR IF NOT APPROPRIATE NAME
	MOVL	(SP)+,R7	;GET NEW TRBLK PTR AGAIN
	ADDL2	R10,R6		;POINT TO VARIABLE LOCATION
	MOVL	R6,R9		;COPY VARIABLE POINTER
;
;      LOOP TO SEARCH TRBLK CHAIN
;
TRC11::	MOVL	(R9),R10	;POINT TO NEXT ENTRY
	CMPL	(R10),#B$TRT	;JUMP IF NOT TRBLK
	BNEQU	TRC13
	CMPL	R8,4*TRTYP(R10)	;JUMP IF TOO FAR OUT ON CHAIN
	BLSSU	TRC13
	CMPL	R8,4*TRTYP(R10)	;JUMP IF THIS MATCHES OUR TYPE
	BEQLU	TRC12
	ADDL2	#4*TRNXT,R10	;ELSE POINT TO LINK FIELD
	MOVL	R10,R9		;COPY POINTER
	JMP	TRC11		;AND LOOP BACK
;
;      HERE TO DELETE AN OLD TRBLK OF THE TYPE WE WERE GIVEN
;
TRC12::	MOVL	4*TRNXT(R10),R10;GET PTR TO NEXT BLOCK OR VALUE
	MOVL	R10,(R9)	;STORE TO DELETE THIS TRBLK
;
;      HERE AFTER DELETING ANY OLD ASSOCIATION OF THIS TYPE
;
TRC13::	TSTL	R7		;JUMP IF STOPTR CASE
	BEQLU	TRC14
	MOVL	R7,(R9)		;ELSE LINK NEW TRBLK IN
	MOVL	R7,R9		;COPY TRBLK POINTER
	MOVL	R10,4*TRNXT(R9)	;STORE FORWARD POINTER
	MOVL	R8,4*TRTYP(R9)	;STORE APPROPRIATE TRAP TYPE CODE
;
;      HERE TO MAKE SURE VRGET,VRSTO ARE SET PROPERLY
;
TRC14::	MOVL	R6,R9		;RECALL POSSIBLE VRBLK POINTER
	SUBL2	#4*VRVAL,R9	;POINT BACK TO VRBLK
	JSB	SETVR		;SET FIELDS IF VRBLK
	ADDL3	#4*2,TRACE_SAVE,R11 ;RETURN
	JMP	(R11)
;
;      HERE FOR BAD TRACE TYPE
;
TRC15::	ADDL3	#4*1,TRACE_SAVE,R11 ;TAKE BAD TRACE TYPE ERROR EXIT
	JMP	@(R11)+
;
;      POP STACK BEFORE FAILING
;
TRC16::	ADDL2	#4,SP		;POP STACK
;
;      HERE FOR BAD NAME ARGUMENT
;
TRC17::	MOVL	TRACE_SAVE,R11	;TAKE BAD NAME ERROR EXIT
	JMP	@(R11)+
	;ENP			;END PROCEDURE TRACE
	.PAGE
;
;      TRBLD -- BUILD TRBLK
;
;      TRBLK IS USED BY THE INPUT, OUTPUT AND TRACE FUNCTIONS
;      TO CONSTRUCT A TRBLK (TRAP BLOCK)
;
;      (XR)                  TRTAG OR TRTER
;      (XL)                  TRFNC OR TRFPT
;      (WB)                  TRTYP
;      JSR  TRBLD            CALL TO BUILD TRBLK
;      (XR)                  POINTER TO TRBLK
;      (WA)                  DESTROYED
;
	.ENABLE	LOCAL_BLOCK
TRBLD::	;PRC			;ENTRY POINT
	MOVL	R9,-(SP)	;STACK TRTAG (OR TRFNM)
	MOVL	#4*TRSI$,R6	;SET SIZE OF TRBLK
	JSB	ALLOC		;ALLOCATE TRBLK
	MOVL	#B$TRT,(R9)	;STORE FIRST WORD
	MOVL	R10,4*TRFNC(R9)	;STORE TRFNC (OR TRFPT)
	MOVL	(SP)+,4*TRTAG(R9);STORE TRTAG (OR TRFNM)
	MOVL	R7,4*TRTYP(R9)	;STORE TYPE
	MOVL	#NULLS,4*TRVAL(R9) ;FOR NOW, A NULL VALUE
	RSB			;RETURN TO CALLER
	;ENP			;END PROCEDURE TRBLD
	.PAGE
;
;      TRIMR -- TRIM TRAILING BLANKS
;
;      TRIMR IS PASSED A POINTER TO AN SCBLK WHICH MUST BE THE
;      LAST BLOCK IN DYNAMIC STORAGE. TRAILING BLANKS ARE
;      TRIMMED OFF AND THE DYNAMIC STORAGE POINTER RESET TO
;      THE END OF THE (POSSIBLY) SHORTENED BLOCK.
;
;      (WB)                  NON-ZERO TO TRIM TRAILING BLANKS
;      (XR)                  POINTER TO STRING TO TRIM
;      JSR  TRIMR            CALL TO TRIM STRING
;      (XR)                  POINTER TO TRIMMED STRING
;      (XL,WA,WB,WC)         DESTROYED
;
;      THE CALL WITH WB ZERO STILL PERFORMS THE END ZERO PAD
;      AND DNAMP READJUSTMENT. IT IS USED FROM ACESS IF KVTRM=0.
;
	.ENABLE	LOCAL_BLOCK
TRIMR::	;PRC			;ENTRY POINT
	MOVL	R9,R10		;COPY STRING POINTER
	MOVL	4*SCLEN(R9),R6	;LOAD STRING LENGTH
	TSTL	R6		;JUMP IF NULL INPUT
	BEQLU	TRIM2
	MOVAB	CFP$F(R10)[R6],R10 ;ELSE POINT PAST LAST CHARACTER
	TSTL	R7		;JUMP IF NO TRIM
	BEQLU	TRIM3
	MOVL	#CH$BL,R8	;LOAD BLANK CHARACTER
;
;      LOOP THROUGH CHARACTERS FROM RIGHT TO LEFT
;
TRIM0::	MOVZBL	-(R10),R7	;LOAD NEXT CHARACTER
	.IF NOT_EQUAL CAHT
	CMPL	R7,#CH$HT	;JUMP IF HORIZONTAL TAB
	BEQLU	TRIM1
	.ENDC
	CMPL	R7,R8		;JUMP IF NON-BLANK FOUND
	BNEQU	TRIM3
TRIM1::	DECL	R6		;ELSE DECREMENT CHARACTER COUNT
	TSTL	R6		;LOOP BACK IF MORE TO CHECK
	BNEQU	TRIM0
;
;      HERE IF RESULT IS NULL (NULL OR ALL-BLANK INPUT)
;
TRIM2::	MOVL	R9,DNAMP	;WIPE OUT INPUT STRING BLOCK
	MOVL	#NULLS,R9	;LOAD NULL RESULT
	JMP	TRIM5		;MERGE TO EXIT
	.PAGE
;
;      TRIMR (CONTINUED)
;
;      HERE WITH NON-BLANK FOUND (MERGE FOR NO TRIM)
;
TRIM3::	MOVL	R6,4*SCLEN(R9)	;SET NEW LENGTH
	MOVL	R9,R10		;COPY STRING POINTER
	MOVAB	CFP$F(R10)[R6],R10 ;READY FOR STORING BLANKS
	MOVAB	3+<4*SCHAR>(R6),R6 ;GET LENGTH OF BLOCK IN BYTES
	BICL2	#3,R6
	ADDL2	R9,R6		;POINT PAST NEW BLOCK
	MOVL	R6,DNAMP	;SET NEW TOP OF STORAGE POINTER
	MOVL	#CFP$C,R6	;GET COUNT OF CHARS IN WORD
	CLRL	R8		;SET BLANK CHAR
;
;      LOOP TO ZERO PAD LAST WORD OF CHARACTERS
;
TRIM4::	MOVB	R8,(R10)+	;STORE ZERO CHARACTER
	SOBGTR	R6,TRIM4	;LOOP BACK TILL ALL STORED
	;CSC	R10		;COMPLETE STORE CHARACTERS
;
;      COMMON EXIT POINT
;
TRIM5::	CLRL	R10		;CLEAR GARBAGE XL POINTER
	RSB			;RETURN TO CALLER
	;ENP			;END PROCEDURE TRIMR
	.PAGE
;
;      TRXEQ -- EXECUTE FUNCTION TYPE TRACE
;
;      TRXEQ IS USED TO EXECUTE A TRACE WHEN A FOURTH ARGUMENT
;      HAS BEEN SUPPLIED. TRACE HAS ALREADY BEEN DECREMENTED.
;
;      (XR)                  POINTER TO TRBLK
;      (XL,WA)               NAME BASE,OFFSET FOR VARIABLE
;      JSR  TRXEQ            CALL TO EXECUTE TRACE
;      (WB,WC,RA)            DESTROYED
;
;      THE FOLLOWING STACK ENTRIES ARE MADE BEFORE PASSING
;      CONTROL TO THE TRACE FUNCTION USING THE CFUNC ROUTINE.
;
;                            TRXEQ RETURN POINT WORD(S)
;                            SAVED VALUE OF TRACE KEYWORD
;                            TRBLK POINTER
;                            NAME BASE
;                            NAME OFFSET
;                            SAVED VALUE OF R$COD
;                            SAVED CODE PTR (-R$COD)
;                            SAVED VALUE OF FLPTR
;      FLPTR --------------- ZERO (DUMMY FAIL OFFSET)
;                            NMBLK FOR VARIABLE NAME
;      XS ------------------ TRACE TAG
;
;      R$COD AND THE CODE PTR ARE SET TO DUMMY VALUES WHICH
;      CAUSE CONTROL TO RETURN TO THE TRXEQ PROCEDURE ON SUCCESS
;      OR FAILURE (TRXEQ IGNORES A FAILURE CONDITION).
;
	.ENABLE	LOCAL_BLOCK
TRXEQ::	;PRC			;ENTRY POINT (RECURSIVE)
	MOVL	R$COD,R8	;LOAD CODE BLOCK POINTER
	MOVL	R3,R7		;GET CURRENT CODE POINTER
	SUBL2	R8,R7		;MAKE CODE POINTER INTO OFFSET
	MOVL	KVTRA,-(SP)	;STACK TRACE KEYWORD VALUE
	MOVL	R9,-(SP)	;STACK TRBLK POINTER
	MOVL	R10,-(SP)	;STACK NAME BASE
	MOVL	R6,-(SP)	;STACK NAME OFFSET
	MOVL	R8,-(SP)	;STACK CODE BLOCK POINTER
	MOVL	R7,-(SP)	;STACK CODE POINTER OFFSET
	MOVL	FLPTR,-(SP)	;STACK OLD FAILURE POINTER
	CLRL	-(SP)		;SET DUMMY FAIL OFFSET
	MOVL	SP,FLPTR	;SET NEW FAILURE POINTER
	CLRL	KVTRA		;RESET TRACE KEYWORD TO ZERO
	MOVL	#TRXDC,R8	;LOAD NEW (DUMMY) CODE BLK POINTER
	MOVL	R8,R$COD	;SET AS CODE BLOCK POINTER
	MOVL	R8,R3		;AND NEW CODE POINTER
	.PAGE
;
;      TRXEQ (CONTINUED)
;
;      NOW PREPARE ARGUMENTS FOR FUNCTION
;
	MOVL	R6,R7		;SAVE NAME OFFSET
	MOVL	#4*NMSI$,R6	;LOAD NMBLK SIZE
	JSB	ALLOC		;ALLOCATE SPACE FOR NMBLK
	MOVL	#B$NML,(R9)	;SET TYPE WORD
	MOVL	R10,4*NMBAS(R9)	;STORE NAME BASE
	MOVL	R7,4*NMOFS(R9)	;STORE NAME OFFSET
	MOVL	4*6(SP),R10	;RELOAD POINTER TO TRBLK
	MOVL	R9,-(SP)	;STACK NMBLK POINTER (1ST ARGUMENT)
	MOVL	4*TRTAG(R10),-(SP) ;STACK TRACE TAG (2ND ARGUMENT)
	MOVL	4*TRFNC(R10),R10;LOAD TRACE FUNCTION POINTER
	MOVL	#NUM02,R6	;SET NUMBER OF ARGUMENTS TO TWO
	JMP	CFUNC		;JUMP TO CALL FUNCTION
;
;      SEE O$TXR FOR DETAILS OF RETURN TO THIS POINT
;
TRXQ1::	MOVL	FLPTR,SP	;POINT BACK TO OUR STACK ENTRIES
	ADDL2	#4,SP		;POP OFF GARBAGE FAIL OFFSET
	MOVL	(SP)+,FLPTR	;RESTORE OLD FAILURE POINTER
	MOVL	(SP)+,R7	;RELOAD CODE OFFSET
	MOVL	(SP)+,R8	;LOAD OLD CODE BASE POINTER
	MOVL	R8,R9		;COPY CDBLK POINTER
	MOVL	4*CDSTM(R9),KVSTN;RESTORE STMNT NO
	MOVL	(SP)+,R6	;RELOAD NAME OFFSET
	MOVL	(SP)+,R10	;RELOAD NAME BASE
	MOVL	(SP)+,R9	;RELOAD TRBLK POINTER
	MOVL	(SP)+,KVTRA	;RESTORE TRACE KEYWORD VALUE
	ADDL2	R8,R7		;RECOMPUTE ABSOLUTE CODE POINTER
	MOVL	R7,R3		;RESTORE CODE POINTER
	MOVL	R8,R$COD	;AND CODE BLOCK POINTER
	RSB			;RETURN TO TRXEQ CALLER
	;ENP			;END PROCEDURE TRXEQ
	.PAGE
;
;      XSCAN -- EXECUTION FUNCTION ARGUMENT SCAN
;
;      XSCAN SCANS OUT ONE TOKEN IN A PROTOTYPE ARGUMENT IN
;      ARRAY,CLEAR,DATA,DEFINE,LOAD FUNCTION CALLS. XSCAN
;      CALLS MUST BE PRECEDED BY A CALL TO THE INITIALIZATION
;      PROCEDURE XSCNI. THE FOLLOWING VARIABLES ARE USED.
;
;      R$XSC                 POINTER TO SCBLK FOR FUNCTION ARG
;      XSOFS                 OFFSET (NUM CHARS SCANNED SO FAR)
;
;      (WC)                  DELIMITER ONE (CH$XX)
;      (XL)                  DELIMITER TWO (CH$XX)
;      JSR  XSCAN            CALL TO SCAN NEXT ITEM
;      (XR)                  POINTER TO SCBLK FOR TOKEN SCANNED
;      (WA)                  COMPLETION CODE (SEE BELOW)
;      (WC,XL)               DESTROYED
;
;      THE SCAN STARTS FROM THE CURRENT POSITION AND CONTINUES
;      UNTIL ONE OF THE FOLLOWING THREE CONDITIONS OCCURS.
;
;      1)   DELIMITER ONE IS ENCOUNTERED  (WA SET TO 1)
;
;      2)   DELIMITER TWO ENCOUNTERED  (WA SET TO 2)
;
;      3)   END OF STRING ENCOUNTERED  (WA SET TO 0)
;
;      THE RESULT IS A STRING CONTAINING ALL CHARACTERS SCANNED
;      UP TO BUT NOT INCLUDING ANY DELIMITER CHARACTER.
;      THE POINTER IS LEFT POINTING PAST THE DELIMITER.
;
;      IF ONLY ONE DELIMITER IS TO BE DETECTED, DELIMITER ONE
;      AND DELIMITER TWO SHOULD BE SET TO THE SAME VALUE.
;
;      IN THE CASE WHERE THE END OF STRING IS ENCOUNTERED, THE
;      STRING INCLUDES ALL THE CHARACTERS TO THE END OF THE
;      STRING. NO FURTHER CALLS CAN BE MADE TO XSCAN UNTIL
;      XSCNI IS CALLED TO INITIALIZE A NEW ARGUMENT SCAN
	.PAGE
;
;      XSCAN (CONTINUED)
;
	.ENABLE	LOCAL_BLOCK
XSCAN::	;PRC			;ENTRY POINT
	MOVL	R7,XSCWB	;PRESERVE WB
	MOVL	R$XSC,R9	;POINT TO ARGUMENT STRING
	MOVL	4*SCLEN(R9),R6	;LOAD STRING LENGTH
	MOVL	XSOFS,R7	;LOAD CURRENT OFFSET
	SUBL2	R7,R6		;GET NUMBER OF REMAINING CHARACTERS
	TSTL	R6		;JUMP IF NO CHARACTERS LEFT
	BEQLU	XSCN2
	MOVAB	CFP$F(R9)[R7],R9;POINT TO CURRENT CHARACTER
;
;      LOOP TO SEARCH FOR DELIMITER
;
XSCN1::	MOVZBL	(R9)+,R7	;LOAD NEXT CHARACTER
	CMPL	R7,R8		;JUMP IF DELIMITER ONE FOUND
	BEQLU	XSCN3
	CMPL	R7,R10		;JUMP IF DELIMITER TWO FOUND
	BEQLU	XSCN4
	DECL	R6		;DECREMENT COUNT OF CHARS LEFT
	TSTL	R6		;LOOP BACK IF MORE CHARS TO GO
	BNEQU	XSCN1
;
;      HERE FOR RUNOUT
;
XSCN2::	MOVL	R$XSC,R10	;POINT TO STRING BLOCK
	MOVL	4*SCLEN(R10),R6	;GET STRING LENGTH
	MOVL	XSOFS,R7	;LOAD OFFSET
	SUBL2	R7,R6		;GET SUBSTRING LENGTH
	CLRL	R$XSC		;CLEAR STRING PTR FOR COLLECTOR
	CLRL	XSCRT		;SET ZERO (RUNOUT) RETURN CODE
	JMP	XSCN6		;JUMP TO EXIT
	.PAGE
;
;      XSCAN (CONTINUED)
;
;      HERE IF DELIMITER ONE FOUND
;
XSCN3::	MOVL	#NUM01,XSCRT	;SET RETURN CODE
	JMP	XSCN5		;JUMP TO MERGE
;
;      HERE IF DELIMITER TWO FOUND
;
XSCN4::	MOVL	#NUM02,XSCRT	;SET RETURN CODE
;
;      MERGE HERE AFTER DETECTING A DELIMITER
;
XSCN5::	MOVL	R$XSC,R10	;RELOAD POINTER TO STRING
	MOVL	4*SCLEN(R10),R8	;GET ORIGINAL LENGTH OF STRING
	SUBL2	R6,R8		;MINUS CHARS LEFT = CHARS SCANNED
	MOVL	R8,R6		;MOVE TO REG FOR SBSTR
	MOVL	XSOFS,R7	;SET OFFSET
	SUBL2	R7,R6		;COMPUTE LENGTH FOR SBSTR
	INCL	R8		;ADJUST NEW CURSOR PAST DELIMITER
	MOVL	R8,XSOFS	;STORE NEW OFFSET
;
;      COMMON EXIT POINT
;
XSCN6::	CLRL	R9		;CLEAR GARBAGE CHARACTER PTR IN XR
	JSB	SBSTR		;BUILD SUB-STRING
	MOVL	XSCRT,R6	;LOAD RETURN CODE
	MOVL	XSCWB,R7	;RESTORE WB
	RSB			;RETURN TO XSCAN CALLER
	;ENP			;END PROCEDURE XSCAN
	.PAGE
;
;      XSCNI -- EXECUTION FUNCTION ARGUMENT SCAN
;
;      XSCNI INITIALIZES THE SCAN USED FOR PROTOTYPE ARGUMENTS
;      IN THE CLEAR, DEFINE, LOAD, DATA, ARRAY FUNCTIONS. SEE
;      XSCAN FOR THE PROCEDURE WHICH IS USED AFTER THIS CALL.
;
;      -(XS)                 ARGUMENT TO BE SCANNED (ON STACK)
;      JSR  XSCNI            CALL TO SCAN ARGUMENT
;      PPM  LOC              TRANSFER LOC IF ARG IS NOT STRING
;      PPM  LOC              TRANSFER LOC IF ARGUMENT IS NULL
;      (XS)                  POPPED
;      (XR,R$XSC)            ARGUMENT (SCBLK PTR)
;      (WA)                  ARGUMENT LENGTH
;      (IA,RA)               DESTROYED
;
	.ENABLE	LOCAL_BLOCK
XSCNI::	MOVL	(SP)+,XSCNI_SAVE;ENTRY POINT
	.SAVE_PSECT LOCAL_BLOCK
	.PSECT	PRC_SAVE,NOEXE
XSCNI_SAVE::.LONG	0
	.RESTORE_PSECT
	JSB	GTSTG		;FETCH ARGUMENT AS STRING
	.ADDRESS XSCI1		;JUMP IF NOT CONVERTIBLE
	MOVL	R9,R$XSC	;ELSE STORE SCBLK PTR FOR XSCAN
	CLRL	XSOFS		;SET OFFSET TO ZERO
	TSTL	R6		;JUMP IF NULL STRING
	BEQLU	XSCI2
	ADDL3	#4*2,XSCNI_SAVE,R11 ;RETURN TO XSCNI CALLER
	JMP	(R11)
;
;      HERE IF ARGUMENT IS NOT A STRING
;
XSCI1::	MOVL	XSCNI_SAVE,R11	;TAKE NOT-STRING ERROR EXIT
	JMP	@(R11)+
;
;      HERE FOR NULL STRING
;
XSCI2::	ADDL3	#4*1,XSCNI_SAVE,R11 ;TAKE NULL-STRING ERROR EXIT
	JMP	@(R11)+
	;ENP			;END PROCEDURE XSCNI
	.PAGE
	.SUBTITLE S P I T B O L -- UTILITY ROUTINES
;
;      THE FOLLOWING SECTION CONTAINS UTILITY ROUTINES USED FOR
;      VARIOUS PURPOSES THROUGHOUT THE SYSTEM. THESE DIFFER
;      FROM THE PROCEDURES IN THE UTILITY PROCEDURES SECTION IN
;      THEY ARE NOT IN PROCEDURE FORM AND THEY DO NOT RETURN
;      TO THEIR CALLERS. THEY ARE ACCESSED WITH A BRANCH TYPE
;      INSTRUCTION AFTER SETTING THE REGISTERS TO APPROPRIATE
;      PARAMETER VALUES.
;
;      THE REGISTER VALUES REQUIRED FOR EACH ROUTINE ARE
;      DOCUMENTED AT THE START OF EACH ROUTINE. REGISTERS NOT
;      MENTIONED MAY CONTAIN ANY VALUES EXCEPT THAT XR,XL
;      CAN ONLY CONTAIN PROPER COLLECTABLE POINTERS.
;
;      SOME OF THESE ROUTINES WILL TOLERATE GARBAGE POINTERS
;      IN XL,XR ON ENTRY. THIS IS ALWAYS DOCUMENTED AND IN
;      EACH CASE, THE ROUTINE CLEARS THESE GARBAGE VALUES BEFORE
;      EXITING AFTER COMPLETING ITS TASK.
;
;      THE ROUTINES HAVE NAMES CONSISTING OF FIVE LETTERS
;      AND ARE ASSEMBLED IN ALPHABETICAL ORDER.
	.PAGE
;      ARREF -- ARRAY REFERENCE
;
;      (XL)                  MAY BE NON-COLLECTABLE
;      (XR)                  NUMBER OF SUBSCRIPTS
;      (WB)                  SET ZERO/NONZERO FOR VALUE/NAME
;                            THE VALUE IN WB MUST BE COLLECTABLE
;      STACK                 SUBSCRIPTS AND ARRAY OPERAND
;      BRN  ARREF            JUMP TO CALL FUNCTION
;
;      ARREF CONTINUES BY EXECUTING THE NEXT CODE WORD WITH
;      THE RESULT NAME OR VALUE PLACED ON TOP OF THE STACK.
;      TO DEAL WITH THE PROBLEM OF ACCESSING SUBSCRIPTS IN THE
;      ORDER OF STACKING, XL IS USED AS A SUBSCRIPT POINTER
;      WORKING BELOW THE STACK POINTER.
;
ARREF::	;RTN
	MOVL	R9,R6		;COPY NUMBER OF SUBSCRIPTS
	MOVL	SP,R10		;POINT TO STACK FRONT
	MOVAL	0[R9],R9	;CONVERT TO BYTE OFFSET
	ADDL2	R9,R10		;POINT TO ARRAY OPERAND ON STACK
	ADDL2	#4,R10		;FINAL VALUE FOR STACK POPPING
	MOVL	R10,ARFXS	;KEEP FOR LATER
	MOVL	-(R10),R9	;LOAD ARRAY OPERAND POINTER
	MOVL	R9,R$ARF	;KEEP ARRAY POINTER
	MOVL	R10,R9		;SAVE POINTER TO SUBSCRIPTS
	MOVL	R$ARF,R10	;POINT XL TO POSSIBLE VCBLK OR TBBLK
	MOVL	(R10),R8	;LOAD FIRST WORD
	CMPL	R8,#B$ART	;JUMP IF ARBLK
	BEQLU	ARF01
	CMPL	R8,#B$VCT	;JUMP IF VCBLK
	BNEQU	5272$
	JMP	ARF07
5272$:
	CMPL	R8,#B$TBT	;JUMP IF TBBLK
	BNEQU	5273$
	JMP	ARF10
5273$:
	JMP	ERROR_235	;SUBSCRIPTED OPERAND IS NOT TABLE OR ARRAY
;
;      HERE FOR ARRAY (ARBLK)
;
ARF01::	CMPL	R6,4*ARNDM(R10)	;JUMP IF WRONG NUMBER OF DIMS
	BEQLU	5274$
	JMP	ARF09
5274$:
	MOVL	INTV0,R5	;GET INITIAL SUBSCRIPT OF ZERO
	MOVL	R9,R10		;POINT BEFORE SUBSCRIPTS
	CLRL	R6		;INITIAL OFFSET TO BOUNDS
	JMP	ARF03		;JUMP INTO LOOP
;
;      LOOP TO COMPUTE SUBSCRIPTS BY MULTIPLICATIONS
;
ARF02::	MULL2	4*ARDM2(R9),R5	;MULTIPLY TOTAL BY NEXT DIMENSION
;
;      MERGE HERE FIRST TIME
;
ARF03::	MOVL	-(R10),R9	;LOAD NEXT SUBSCRIPT
	MOVL	R5,ARFSI	;SAVE CURRENT SUBSCRIPT
	MOVL	4*ICVAL(R9),R5	;LOAD INTEGER VALUE IN CASE
	CMPL	(R9),#B$ICL	;JUMP IF IT WAS AN INTEGER
	BEQLU	ARF04
	.PAGE
;
;      ARREF (CONTINUED)
;
;
	JSB	GTINT		;CONVERT TO INTEGER
	.ADDRESS ARF12		;JUMP IF NOT INTEGER
	MOVL	4*ICVAL(R9),R5	;IF OK, LOAD INTEGER VALUE
;
;      HERE WITH INTEGER SUBSCRIPT IN (IA)
;
ARF04::	MOVL	R$ARF,R9	;POINT TO ARRAY
	ADDL2	R6,R9		;OFFSET TO NEXT BOUNDS
	SUBL2	4*ARLBD(R9),R5	;SUBTRACT LOW BOUND TO COMPARE
	BVC	5275$
	JMP	ARF13
5275$:
	TSTL	R5		;OUT OF RANGE FAIL IF TOO SMALL
	BGEQ	5276$
	JMP	ARF13
5276$:
	SUBL2	4*ARDIM(R9),R5	;SUBTRACT DIMENSION
	BLSS	5277$
	JMP	ARF13
5277$:
	ADDL2	4*ARDIM(R9),R5	;ELSE RESTORE SUBSCRIPT OFFSET
	ADDL2	ARFSI,R5	;ADD TO CURRENT TOTAL
	ADDL2	#4*ARDMS,R6	;POINT TO NEXT BOUNDS
	CMPL	R10,SP		;LOOP BACK IF MORE TO GO
	BNEQU	ARF02
;
;      HERE WITH INTEGER SUBSCRIPT COMPUTED
;
	MFI	R6		;GET AS ONE WORD INTEGER
	MOVAL	0[R6],R6	;CONVERT TO OFFSET
	MOVL	R$ARF,R10	;POINT TO ARBLK
	ADDL2	4*AROFS(R10),R6	;ADD OFFSET PAST BOUNDS
	ADDL2	#4,R6		;ADJUST FOR ARPRO FIELD
	TSTL	R7		;EXIT WITH NAME IF NAME CALL
	BNEQU	ARF08
;
;      MERGE HERE TO GET VALUE FOR VALUE CALL
;
ARF05::	JSB	ACESS		;GET VALUE
	.ADDRESS ARF13		;FAIL IF ACESS FAILS
;
;      RETURN VALUE
;
ARF06::	MOVL	ARFXS,SP	;POP STACK ENTRIES
	CLRL	R$ARF		;FINISHED WITH ARRAY POINTER
	JMP	EXIXR		;EXIT WITH VALUE IN XR
	.PAGE
;
;      ARREF (CONTINUED)
;
;      HERE FOR VECTOR
;
ARF07::	CMPL	R6,#NUM01	;ERROR IF MORE THAN 1 SUBSCRIPT
	BEQLU	5278$
	JMP	ARF09
5278$:
	MOVL	(SP),R9		;ELSE LOAD SUBSCRIPT
	JSB	GTINT		;CONVERT TO INTEGER
	.ADDRESS ARF12		;ERROR IF NOT INTEGER
	MOVL	4*ICVAL(R9),R5	;ELSE LOAD INTEGER VALUE
	SUBL2	INTV1,R5	;SUBTRACT FOR ONES OFFSET
	MFI	R6,ARF13	;GET SUBSCRIPT AS ONE WORD
	ADDL2	#VCVLS,R6	;ADD OFFSET FOR STANDARD FIELDS
	MOVAL	0[R6],R6	;CONVERT OFFSET TO BYTES
	CMPL	R6,4*VCLEN(R10)	;FAIL IF OUT OF RANGE SUBSCRIPT
	BLSSU	5279$
	JMP	ARF13
5279$:
	TSTL	R7		;BACK TO GET VALUE IF VALUE CALL
	BEQLU	ARF05
;
;      RETURN NAME
;
ARF08::	MOVL	ARFXS,SP	;POP STACK ENTRIES
	CLRL	R$ARF		;FINISHED WITH ARRAY POINTER
	JMP	EXNAM		;ELSE EXIT WITH NAME
;
;      HERE IF SUBSCRIPT COUNT IS WRONG
;
ARF09::	JMP	ERROR_236	;ARRAY REFERENCED WITH WRONG NUMBER OF SUBSCRIPTS
;
;      TABLE
;
ARF10::	CMPL	R6,#NUM01	;ERROR IF MORE THAN 1 SUBSCRIPT
	BNEQU	ARF11
	MOVL	(SP),R9		;ELSE LOAD SUBSCRIPT
	JSB	TFIND		;CALL TABLE SEARCH ROUTINE
	.ADDRESS ARF13		;FAIL IF FAILED
	TSTL	R7		;EXIT WITH NAME IF NAME CALL
	BNEQU	ARF08
	JMP	ARF06		;ELSE EXIT WITH VALUE
;
;      HERE FOR BAD TABLE REFERENCE
;
ARF11::	JMP	ERROR_237	;TABLE REFERENCED WITH MORE THAN ONE SUBSCRIPT
;
;      HERE FOR BAD SUBSCRIPT
;
ARF12::	JMP	ERROR_238	;ARRAY SUBSCRIPT IS NOT INTEGER
;
;      HERE TO SIGNAL FAILURE
;
ARF13::	CLRL	R$ARF		;FINISHED WITH ARRAY POINTER
	JMP	EXFAL		;FAIL
	.PAGE
;
;      CFUNC -- CALL A FUNCTION
;
;      CFUNC IS USED TO CALL A SNOBOL LEVEL FUNCTION. IT IS
;      USED BY THE APPLY FUNCTION (S$APP), THE FUNCTION
;      TRACE ROUTINE (TRXEQ) AND THE MAIN FUNCTION CALL ENTRY
;      (O$FNC, O$FNS). IN THE LATTER CASES, CFUNC IS USED ONLY
;      IF THE NUMBER OF ARGUMENTS IS INCORRECT.
;
;      (XL)                  POINTER TO FUNCTION BLOCK
;      (WA)                  ACTUAL NUMBER OF ARGUMENTS
;      (XS)                  POINTS TO STACKED ARGUMENTS
;      BRN  CFUNC            JUMP TO CALL FUNCTION
;
;      CFUNC CONTINUES BY EXECUTING THE FUNCTION
;
CFUNC::	;RTN
	CMPL	R6,4*FARGS(R10)	;JUMP IF TOO FEW ARGUMENTS
	BLSSU	CFNC1
	CMPL	R6,4*FARGS(R10)	;JUMP IF CORRECT NUMBER OF ARGS
	BEQLU	CFNC3
;
;      HERE IF TOO MANY ARGUMENTS SUPPLIED, POP THEM OFF
;
	MOVL	R6,R7		;COPY ACTUAL NUMBER
	SUBL2	4*FARGS(R10),R7	;GET NUMBER OF EXTRA ARGS
	MOVAL	0[R7],R7	;CONVERT TO BYTES
	ADDL2	R7,SP		;POP OFF UNWANTED ARGUMENTS
	JMP	CFNC3		;JUMP TO GO OFF TO FUNCTION
;
;      HERE IF TOO FEW ARGUMENTS
;
CFNC1::	MOVL	4*FARGS(R10),R7	;LOAD REQUIRED NUMBER OF ARGUMENTS
	CMPL	R7,#NINI9	;JUMP IF CASE OF VAR NUM OF ARGS
	BEQLU	CFNC3
	SUBL2	R6,R7		;CALCULATE NUMBER MISSING
				;SET COUNTER TO CONTROL LOOP
;
;      LOOP TO SUPPLY EXTRA NULL ARGUMENTS
;
CFNC2::	MOVL	#NULLS,-(SP)	;STACK A NULL ARGUMENT
	SOBGTR	R7,CFNC2	;LOOP TILL PROPER NUMBER STACKED
;
;      MERGE HERE TO JUMP TO FUNCTION
;
CFNC3::	MOVL	(R10),R11	;JUMP THROUGH FCODE FIELD
	JMP	(R11)
	.PAGE
;
;      EXFAL -- EXIT SIGNALLING SNOBOL FAILURE
;
;      (XL,XR)               MAY BE NON-COLLECTABLE
;      BRN  EXFAL            JUMP TO FAIL
;
;      EXFAL CONTINUES BY EXECUTING THE APPROPRIATE FAIL GOTO
;
EXFAL::	;RTN
	MOVL	FLPTR,SP	;POP STACK
	MOVL	(SP),R9		;LOAD FAILURE OFFSET
	ADDL2	R$COD,R9	;POINT TO FAILURE CODE LOCATION
	MOVL	R9,R3		;SET CODE POINTER
	JMP	EXITS		;DO NEXT CODE WORD
	.PAGE
;
;      EXINT -- EXIT WITH INTEGER RESULT
;
;      (XL,XR)               MAY BE NONCOLLECTABLE
;      (IA)                  INTEGER VALUE
;      BRN  EXINT            JUMP TO EXIT WITH INTEGER
;
;      EXINT CONTINUES BY EXECUTING THE NEXT CODE WORD
;      WHICH IT DOES BY FALLING THROUGH TO EXIXR
;
EXINT::	;RTN
	JSB	ICBLD		;BUILD ICBLK
	.PAGE
;      EXIXR -- EXIT WITH RESULT IN (XR)
;
;      (XR)                  RESULT
;      (XL)                  MAY BE NON-COLLECTABLE
;      BRN  EXIXR            JUMP TO EXIT WITH RESULT IN (XR)
;
;      EXIXR CONTINUES BY EXECUTING THE NEXT CODE WORD
;      WHICH IT DOES BY FALLING THROUGH TO EXITS.
EXIXR::	;RTN
;
	MOVL	R9,-(SP)	;STACK RESULT
;
;
;      EXITS -- EXIT WITH RESULT IF ANY STACKED
;
;      (XR,XL)               MAY BE NON-COLLECTABLE
;
;      BRN  EXITS            ENTER EXITS ROUTINE
;
EXITS::	;RTN
	MOVL	(R3)+,R9	;LOAD NEXT CODE WORD
	MOVL	(R9),R10	;LOAD ENTRY ADDRESS
	MOVL	R10,R11		;JUMP TO EXECUTE NEXT CODE WORD
	JMP	(R11)
	.PAGE
;
;      EXNAM -- EXIT WITH NAME IN (XL,WA)
;
;      (XL)                  NAME BASE
;      (WA)                  NAME OFFSET
;      (XR)                  MAY BE NON-COLLECTABLE
;      BRN  EXNAM            JUMP TO EXIT WITH NAME IN (XL,WA)
;
;      EXNAM CONTINUES BY EXECUTING THE NEXT CODE WORD
;
EXNAM::	;RTN
	MOVL	R10,-(SP)	;STACK NAME BASE
	MOVL	R6,-(SP)	;STACK NAME OFFSET
	JMP	EXITS		;DO NEXT CODE WORD
	.PAGE
;
;      EXNUL -- EXIT WITH NULL RESULT
;
;      (XL,XR)               MAY BE NON-COLLECTABLE
;      BRN  EXNUL            JUMP TO EXIT WITH NULL VALUE
;
;      EXNUL CONTINUES BY EXECUTING THE NEXT CODE WORD
;
EXNUL::	;RTN
	MOVL	#NULLS,-(SP)	;STACK NULL VALUE
	JMP	EXITS		;DO NEXT CODE WORD
	.PAGE
	.IF NOT_EQUAL CNRA
	.IF_FALSE
;
;      EXREA -- EXIT WITH REAL RESULT
;
;      (XL,XR)               MAY BE NON-COLLECTABLE
;      (RA)                  REAL VALUE
;      BRN  EXREA            JUMP TO EXIT WITH REAL VALUE
;
;      EXREA CONTINUES BY EXECUTING THE NEXT CODE WORD
;
EXREA::	;RTN
	JSB	RCBLD		;BUILD RCBLK
	JMP	EXIXR		;JUMP TO EXIT WITH RESULT IN XR
	.ENDC
	.PAGE
;
;      EXSID -- EXIT SETTING ID FIELD
;
;      EXSID IS USED TO EXIT AFTER BUILDING ANY OF THE FOLLOWING
;      BLOCKS (ARBLK, TBBLK, PDBLK, VCBLK). IT SETS THE IDVAL.
;
;      (XR)                  PTR TO BLOCK WITH IDVAL FIELD
;      (XL)                  MAY BE NON-COLLECTABLE
;      BRN  EXSID            JUMP TO EXIT AFTER SETTING ID FIELD
;
;      EXSID CONTINUES BY EXECUTING THE NEXT CODE WORD
;
EXSID::	;RTN
	MOVL	CURID,R6	;LOAD CURRENT ID VALUE
	CMPL	R6,#CFP$M	;JUMP IF NO OVERFLOW
	BNEQU	EXSI1
	CLRL	R6		;ELSE RESET FOR WRAPAROUND
;
;      HERE WITH OLD IDVAL IN WA
;
EXSI1::	INCL	R6		;BUMP ID VALUE
	MOVL	R6,CURID	;STORE FOR NEXT TIME
	MOVL	R6,4*IDVAL(R9)	;STORE ID VALUE
	JMP	EXIXR		;EXIT WITH RESULT IN (XR)
	.PAGE
;
;      EXVNM -- EXIT WITH NAME OF VARIABLE
;
;      EXVNM EXITS AFTER STACKING A VALUE WHICH IS A NMBLK
;      REFERENCING THE NAME OF A GIVEN NATURAL VARIABLE.
;
;      (XR)                  VRBLK POINTER
;      (XL)                  MAY BE NON-COLLECTABLE
;      BRN  EXVNM            EXIT WITH VRBLK POINTER IN XR
;
EXVNM::	;RTN
	MOVL	R9,R10		;COPY NAME BASE POINTER
	MOVL	#4*NMSI$,R6	;SET SIZE OF NMBLK
	JSB	ALLOC		;ALLOCATE NMBLK
	MOVL	#B$NML,(R9)	;STORE TYPE WORD
	MOVL	R10,4*NMBAS(R9)	;STORE NAME BASE
	MOVL	#4*VRVAL,4*NMOFS(R9) ;STORE NAME OFFSET
	JMP	EXIXR		;EXIT WITH RESULT IN XR
	.PAGE
;
;      FLPOP -- FAIL AND POP IN PATTERN MATCHING
;
;      FLPOP POPS THE NODE AND CURSOR ON THE STACK AND THEN
;      DROPS THROUGH INTO FAILP TO CAUSE PATTERN FAILURE
;
;      (XL,XR)               MAY BE NON-COLLECTABLE
;      BRN  FLPOP            JUMP TO FAIL AND POP STACK
;
FLPOP::	;RTN
	ADDL2	#4*NUM02,SP	;POP TWO ENTRIES OFF STACK
	.PAGE
;
;      FAILP -- FAILURE IN MATCHING PATTERN NODE
;
;      FAILP IS USED AFTER FAILING TO MATCH A PATTERN NODE.
;      SEE PATTERN MATCH ROUTINES FOR DETAILS OF USE.
;
;      (XL,XR)               MAY BE NON-COLLECTABLE
;      BRN  FAILP            SIGNAL FAILURE TO MATCH
;
;      FAILP CONTINUES BY MATCHING AN ALTERNATIVE FROM THE STACK
;
FAILP::	;RTN
	MOVL	(SP)+,R9	;LOAD ALTERNATIVE NODE POINTER
	MOVL	(SP)+,R7	;RESTORE OLD CURSOR
	MOVL	(R9),R10	;LOAD PCODE ENTRY POINTER
	MOVL	R10,R11		;JUMP TO EXECUTE CODE FOR NODE
	JMP	(R11)
	.PAGE
;
;      INDIR -- COMPUTE INDIRECT REFERENCE
;
;      (WB)                  NONZERO/ZERO FOR BY NAME/VALUE
;      BRN  INDIR            JUMP TO GET INDIRECT REF ON STACK
;
;      INDIR CONTINUES BY EXECUTING THE NEXT CODE WORD
;
INDIR::	;RTN
	MOVL	(SP)+,R9	;LOAD ARGUMENT
	CMPL	(R9),#B$NML	;JUMP IF A NAME
	BEQLU	INDR2
	JSB	GTNVR		;ELSE CONVERT TO VARIABLE
	.ADDRESS ERROR_239	;INDIRECTION OPERAND IS NOT NAME
	TSTL	R7		;SKIP IF BY VALUE
	BEQLU	INDR1
	MOVL	R9,-(SP)	;ELSE STACK VRBLK PTR
	MOVL	#4*VRVAL,-(SP)	;STACK NAME OFFSET
	JMP	EXITS		;EXIT WITH RESULT ON STACK
;
;      HERE TO GET VALUE OF NATURAL VARIABLE
;
INDR1::	MOVL	(R9),R11	;JUMP THROUGH VRGET FIELD OF VRBLK
	JMP	(R11)
;
;      HERE IF OPERAND IS A NAME
;
INDR2::	MOVL	4*NMBAS(R9),R10	;LOAD NAME BASE
	MOVL	4*NMOFS(R9),R6	;LOAD NAME OFFSET
	TSTL	R7		;EXIT IF CALLED BY NAME
	BEQLU	5280$
	JMP	EXNAM
5280$:
	JSB	ACESS		;ELSE GET VALUE FIRST
	.ADDRESS EXFAL		;FAIL IF ACCESS FAILS
	JMP	EXIXR		;ELSE RETURN WITH VALUE IN XR
	.PAGE
;
;      MATCH -- INITIATE PATTERN MATCH
;
;      (WB)                  MATCH TYPE CODE
;      BRN  MATCH            JUMP TO INITIATE PATTERN MATCH
;
;      MATCH CONTINUES BY EXECUTING THE PATTERN MATCH. SEE
;      PATTERN MATCH ROUTINES (P$XXX) FOR FULL DETAILS.
;
MATCH::	;RTN
	MOVL	(SP)+,R9	;LOAD PATTERN OPERAND
	JSB	GTPAT		;CONVERT TO PATTERN
	.ADDRESS ERROR_240	;PATTERN MATCH RIGHT OPERAND IS NOT PATTERN
	MOVL	R9,R10		;IF OK, SAVE PATTERN POINTER
	TSTL	R7		;JUMP IF NOT MATCH BY NAME
	BNEQU	MTCH1
	MOVL	(SP),R6		;ELSE LOAD NAME OFFSET
	MOVL	R10,-(SP)	;SAVE PATTERN POINTER
	MOVL	4*2(SP),R10	;LOAD NAME BASE
	JSB	ACESS		;ACCESS SUBJECT VALUE
	.ADDRESS EXFAL		;FAIL IF ACCESS FAILS
	MOVL	(SP),R10	;RESTORE PATTERN POINTER
	MOVL	R9,(SP)		;STACK SUBJECT STRING VAL FOR MERGE
	CLRL	R7		;RESTORE TYPE CODE
;
;      MERGE HERE WITH SUBJECT VALUE ON STACK
;
MTCH1::	JSB	GTSTG		;CONVERT SUBJECT TO STRING
	.ADDRESS ERROR_241	;PATTERN MATCH LEFT OPERAND IS NOT STRING
	MOVL	R9,R$PMS	;IF OK, STORE SUBJECT STRING POINTER
	MOVL	R6,PMSSL	;AND LENGTH
	MOVL	R7,-(SP)	;STACK MATCH TYPE CODE
	CLRL	-(SP)		;STACK INITIAL CURSOR (ZERO)
	CLRL	R7		;SET INITIAL CURSOR
	MOVL	SP,PMHBS	;SET HISTORY STACK BASE PTR
	CLRL	PMDFL		;RESET PATTERN ASSIGNMENT FLAG
	MOVL	R10,R9		;SET INITIAL NODE POINTER
	TSTL	KVANC		;JUMP IF ANCHORED
	BNEQU	MTCH2
;
;      HERE FOR UNANCHORED
;
	MOVL	R9,-(SP)	;STACK INITIAL NODE POINTER
	MOVL	#NDUNA,-(SP)	;STACK POINTER TO ANCHOR MOVE NODE
	MOVL	(R9),R11	;START MATCH OF FIRST NODE
	JMP	(R11)
;
;      HERE IN ANCHORED MODE
;
MTCH2::	CLRL	-(SP)		;DUMMY CURSOR VALUE
	MOVL	#NDABO,-(SP)	;STACK POINTER TO ABORT NODE
	MOVL	(R9),R11	;START MATCH OF FIRST NODE
	JMP	(R11)
	.PAGE
;
;      RETRN -- RETURN FROM FUNCTION
;
;      (WA)                  STRING POINTER FOR RETURN TYPE
;      BRN  RETRN            JUMP TO RETURN FROM (SNOBOL) FUNC
;
;      RETRN CONTINUES BY EXECUTING THE CODE AT THE RETURN POINT
;      THE STACK IS CLEANED OF ANY GARBAGE LEFT BY OTHER
;      ROUTINES WHICH MAY HAVE ALTERED FLPTR SINCE FUNCTION
;      ENTRY BY USING FLPRT, RESERVED FOR USE ONLY BY
;      FUNCTION CALL AND RETURN.
;
RETRN::	;RTN
	TSTL	KVFNC		;JUMP IF NOT LEVEL ZERO
	BNEQU	RTN01
	JMP	ERROR_242	;FUNCTION RETURN FROM LEVEL ZERO
;
;      HERE IF NOT LEVEL ZERO RETURN
;
RTN01::	MOVL	FLPRT,SP	;POP STACK
	ADDL2	#4,SP		;REMOVE FAILURE OFFSET
	MOVL	(SP)+,R9	;POP PFBLK POINTER
	MOVL	(SP)+,FLPTR	;POP FAILURE POINTER
	MOVL	(SP)+,FLPRT	;POP OLD FLPRT
	MOVL	(SP)+,R7	;POP CODE POINTER OFFSET
	MOVL	(SP)+,R8	;POP OLD CODE BLOCK POINTER
	ADDL2	R8,R7		;MAKE OLD CODE POINTER ABSOLUTE
	MOVL	R7,R3		;RESTORE OLD CODE POINTER
	MOVL	R8,R$COD	;RESTORE OLD CODE BLOCK POINTER
	DECL	KVFNC		;DECREMENT FUNCTION LEVEL
	MOVL	KVTRA,R7	;LOAD TRACE
	ADDL2	KVFTR,R7	;ADD FTRACE
	TSTL	R7		;JUMP IF NO TRACING POSSIBLE
	BNEQU	5281$
	JMP	RTN06
5281$:
;
;      HERE IF THERE MAY BE A TRACE
;
	MOVL	R6,-(SP)	;SAVE FUNCTION RETURN TYPE
	MOVL	R9,-(SP)	;SAVE PFBLK POINTER
	MOVL	R6,KVRTN	;SET RTNTYPE FOR TRACE FUNCTION
	MOVL	R$FNC,R10	;LOAD FNCLEVEL TRBLK PTR (IF ANY)
	JSB	KTREX		;EXECUTE POSSIBLE FNCLEVEL TRACE
	TSTL	KVTRA		;JUMP IF TRACE IS OFF
	BEQLU	RTN02
	MOVL	4*PFRTR(R9),R9	;ELSE LOAD RETURN TRACE TRBLK PTR
	BEQLU	RTN02
	DECL	KVTRA		;ELSE DECREMENT TRACE COUNT
	TSTL	4*TRFNC(R9)	;JUMP IF PRINT TRACE
	BEQLU	RTN03
	MOVL	#4*VRVAL,R6	;ELSE SET NAME OFFSET
	MOVL	4*1(SP),KVRTN	;MAKE SURE RTNTYPE IS SET RIGHT
	JSB	TRXEQ		;EXECUTE FULL TRACE
	.PAGE
;
;      RETRN (CONTINUED)
;
;      HERE TO TEST FOR FTRACE
;
RTN02::	TSTL	KVFTR		;JUMP IF FTRACE IS OFF
	BEQLU	RTN05
	DECL	KVFTR		;ELSE DECREMENT FTRACE
;
;      HERE FOR PRINT TRACE OF FUNCTION RETURN
;
RTN03::	JSB	PRTSN		;PRINT STATEMENT NUMBER
	MOVL	4*1(SP),R9	;LOAD RETURN TYPE
	JSB	PRTST		;PRINT IT
	MOVL	#CH$BL,R6	;LOAD BLANK
	JSB	PRTCH		;PRINT IT
	MOVL	(SP),R10	;LOAD PFBLK PTR
	MOVL	4*PFVBL(R10),R10;LOAD FUNCTION VRBLK PTR
	MOVL	#4*VRVAL,R6	;SET VRBLK NAME OFFSET
	CMPL	R9,#SCFRT	;JUMP IF NOT FRETURN CASE
	BNEQU	RTN04
;
;      FOR FRETURN, JUST PRINT FUNCTION NAME
;
	JSB	PRTNM		;PRINT NAME
	JSB	PRTNL		;TERMINATE PRINT LINE
	JMP	RTN05		;MERGE
;
;      HERE FOR RETURN OR NRETURN, PRINT FUNCTION NAME = VALUE
;
RTN04::	JSB	PRTNV		;PRINT NAME = VALUE
;
;      HERE AFTER COMPLETING TRACE
;
RTN05::	MOVL	(SP)+,R9	;POP PFBLK POINTER
	MOVL	(SP)+,R6	;POP RETURN TYPE STRING
;
;      MERGE HERE IF NO TRACE REQUIRED
;
RTN06::	MOVL	R6,KVRTN	;SET RTNTYPE KEYWORD
	MOVL	4*PFVBL(R9),R10	;LOAD POINTER TO FN VRBLK
	.PAGE
;      RETRN (CONTINUED)
;
;      GET VALUE OF FUNCTION
;
RTN07::	MOVL	R10,RTNBP	;SAVE BLOCK POINTER
	MOVL	4*VRVAL(R10),R10;LOAD VALUE
	CMPL	(R10),#B$TRT	;LOOP BACK IF TRAPPED
	BEQLU	RTN07
	MOVL	R10,RTNFV	;ELSE SAVE FUNCTION RESULT VALUE
	MOVL	(SP)+,RTNSV	;SAVE ORIGINAL FUNCTION VALUE
	.IF NOT_EQUAL CNPF
	MOVL	4*FARGS(R9),R7	;GET NUMBER OF ARGUMENTS
	.IF_FALSE
	MOVL	(SP)+,R10	;POP SAVED POINTER
	BEQLU	RTN7C
	TSTL	KVPFL		;JUMP IF NO PROFILING
	BEQLU	RTN7C
	JSB	PRFLU		;ELSE PROFILE LAST FUNC STMT
	CMPL	KVPFL,#NUM02	;BRANCH ON VALUE OF PROFILE KEYWD
	BEQLU	RTN7A
;
;      HERE IF &PROFILE = 1. START TIME MUST BE FRIGGED TO
;      APPEAR EARLIER THAN IT ACTUALLY IS, BY AMOUNT USED BEFORE
;      THE CALL.
;
	MOVL	PFSTM,R5	;LOAD CURRENT TIME
	SUBL2	4*ICVAL(R10),R5	;FRIG BY SUBTRACTING SAVED AMOUNT
	JMP	RTN7B		;AND MERGE
;
;      HERE IF &PROFILE = 2
;
RTN7A::	MOVL	4*ICVAL(R10),R5	;LOAD SAVED TIME
;
;      BOTH PROFILE TYPES MERGE HERE
;
RTN7B::	MOVL	R5,PFSTM	;STORE BACK CORRECT START TIME
;
;      MERGE HERE IF NO PROFILING
;
RTN7C::	MOVL	4*FARGS(R9),R7	;GET NUMBER OF ARGS
	.ENDC
	ADDL2	4*PFNLO(R9),R7	;ADD NUMBER OF LOCALS
	BEQLU	RTN10
				;ELSE SET LOOP COUNTER
	ADDL2	4*PFLEN(R9),R9	;AND POINT TO END OF PFBLK
;
;      LOOP TO RESTORE FUNCTIONS AND LOCALS
;
RTN08::	MOVL	-(R9),R10	;LOAD NEXT VRBLK POINTER
;
;      LOOP TO FIND VALUE BLOCK
;
RTN09::	MOVL	R10,R6		;SAVE BLOCK POINTER
	MOVL	4*VRVAL(R10),R10;LOAD POINTER TO NEXT VALUE
	CMPL	(R10),#B$TRT	;LOOP BACK IF TRAPPED
	BEQLU	RTN09
	MOVL	R6,R10		;ELSE RESTORE LAST BLOCK POINTER
	MOVL	(SP)+,4*VRVAL(R10) ;RESTORE OLD VARIABLE VALUE
	SOBGTR	R7,RTN08	;LOOP TILL ALL PROCESSED
;
;      NOW RESTORE FUNCTION VALUE AND EXIT
;
RTN10::	MOVL	RTNBP,R10	;RESTORE PTR TO LAST FUNCTION BLOCK
	MOVL	RTNSV,4*VRVAL(R10) ;RESTORE OLD FUNCTION VALUE
	MOVL	RTNFV,R9	;RELOAD FUNCTION RESULT
	MOVL	R$COD,R10	;POINT TO NEW CODE BLOCK
	MOVL	KVSTN,KVLST	;SET LASTNO FROM STNO
	MOVL	4*CDSTM(R10),KVSTN ;RESET PROPER STNO VALUE
	MOVL	KVRTN,R6	;LOAD RETURN TYPE
	CMPL	R6,#SCRTN	;EXIT WITH RESULT IN XR IF RETURN
	BNEQU	5282$
	JMP	EXIXR
5282$:
	CMPL	R6,#SCFRT	;FAIL IF FRETURN
	BNEQU	5283$
	JMP	EXFAL
5283$:
	.PAGE
;
;      RETRN (CONTINUED)
;
;      HERE FOR NRETURN
;
	CMPL	(R9),#B$NML	;JUMP IF IS A NAME
	BEQLU	RTN11
	JSB	GTNVR		;ELSE TRY CONVERT TO VARIABLE NAME
	.ADDRESS ERROR_243	;FUNCTION RESULT IN NRETURN IS NOT NAME
	MOVL	R9,R10		;IF OK, COPY VRBLK (NAME BASE) PTR
	MOVL	#4*VRVAL,R6	;SET NAME OFFSET
	JMP	RTN12		;AND MERGE
;
;      HERE IF RETURNED RESULT IS A NAME
;
RTN11::	MOVL	4*NMBAS(R9),R10	;LOAD NAME BASE
	MOVL	4*NMOFS(R9),R6	;LOAD NAME OFFSET
;
;      MERGE HERE WITH RETURNED NAME IN (XL,WA)
;
RTN12::	MOVL	R10,R9		;PRESERVE XL
	MOVL	(R3)+,R7	;LOAD NEXT WORD
	MOVL	R9,R10		;RESTORE XL
	CMPL	R7,#OFNE$	;EXIT IF CALLED BY NAME
	BNEQU	5284$
	JMP	EXNAM
5284$:
	MOVL	R7,-(SP)	;ELSE SAVE CODE WORD
	JSB	ACESS		;GET VALUE
	.ADDRESS EXFAL		;FAIL IF ACCESS FAILS
	MOVL	R9,R10		;IF OK, COPY RESULT
	MOVL	(SP),R9		;RELOAD NEXT CODE WORD
	MOVL	R10,(SP)	;STORE RESULT ON STACK
	MOVL	(R9),R10	;LOAD ROUTINE ADDRESS
	MOVL	R10,R11		;JUMP TO EXECUTE NEXT CODE WORD
	JMP	(R11)
	.PAGE
;
;      STCOV -- SIGNAL STATEMENT COUNTER OVERFLOW
;
;      BRN  STCOV            JUMP TO SIGNAL STATEMENT COUNT OFLO
;
;      PERMIT UP TO 10 MORE STATEMENTS TO BE OBEYED SO THAT
;      SETEXIT TRAP CAN REGAIN CONTROL.
;      STCOV CONTINUES BY ISSUING THE ERROR MESSAGE
;
STCOV::	;RTN
	INCL	ERRFT		;FATAL ERROR
	MOVL	INTVT,R5	;GET 10
	ADDL2	KVSTL,R5	;ADD TO FORMER LIMIT
	MOVL	R5,KVSTL	;STORE AS NEW STLIMIT
	MOVL	INTVT,R5	;GET 10
	MOVL	R5,KVSTC	;SET AS NEW COUNT
	JMP	ERROR_244	;STATEMENT COUNT EXCEEDS VALUE OF STLIMIT KEYWORD
	.PAGE
;
;      STMGO -- START EXECUTION OF NEW STATEMENT
;
;      (XR)                  POINTER TO CDBLK FOR NEW STATEMENT
;      BRN  STMGO            JUMP TO EXECUTE NEW STATEMENT
;
;      STMGO CONTINUES BY EXECUTING THE NEXT STATEMENT
;
STMGO::	;RTN
	MOVL	R9,R$COD	;SET NEW CODE BLOCK POINTER
	.IF NOT_EQUAL CNPF
	MOVL	KVSTN,KVLST	;SET LASTNO
	.IF_FALSE
	TSTL	KVPFL		;SKIP IF NO PROFILING
	BEQLU	STGO1
	JSB	PRFLU		;ELSE PROFILE THE STATEMENT
STGO1::	MOVL	KVSTN,KVLST	;SET LASTNO
	.ENDC
	MOVL	4*CDSTM(R9),KVSTN;SET STNO
	ADDL2	#4*CDCOD,R9	;POINT TO FIRST CODE WORD
	MOVL	R9,R3		;SET CODE POINTER
	MOVL	KVSTC,R5	;GET STMT COUNT
	BGEQ	5285$
	JMP	EXITS
5285$:
	TSTL	R5		;FAIL IF STLIMIT REACHED
	BEQL	STCOV
	SUBL2	INTV1,R5	;DECREMENT
	MOVL	R5,KVSTC	;REPLACE IT
	TSTL	R$STC		;EXIT IF NO STCOUNT TRACE
	BNEQU	5286$
	JMP	EXITS
5286$:
;
;      HERE FOR STCOUNT TRACE
;
	CLRL	R9		;CLEAR GARBAGE VALUE IN XR
	MOVL	R$STC,R10	;LOAD POINTER TO STCOUNT TRBLK
	JSB	KTREX		;EXECUTE KEYWORD TRACE
	JMP	EXITS		;AND THEN EXIT FOR NEXT CODE WORD
	.PAGE
;
;      STOPR -- TERMINATE RUN
;
;      (XR)                  POINTS TO ENDING MESSAGE
;      BRN STOPR             JUMP TO TERMINATE RUN
;
;      TERMINATE RUN AND PRINT STATISTICS.  ON ENTRY XR POINTS
;      TO ENDING MESSAGE OR IS ZERO IF MESSAGE  PRINTED ALREADY.
;
STOPR::	;RTN
	.IF NOT_EQUAL CSAX
	JSB	SYSAX		;CALL AFTER EXECUTION PROC
	.IF_FALSE
	.ENDC
	ADDL2	RSMEM,DNAME	;USE THE RESERVE MEMORY
	CMPL	R9,#ENDMS	;SKIP IF NOT NORMAL END MESSAGE
	BNEQU	STPR0
	TSTL	EXSTS		;SKIP IF EXEC STATS SUPPRESSED
	BEQLU	5287$
	JMP	STPR3
5287$:
	CLRL	ERICH		;CLEAR ERRORS TO INT.CH. FLAG
;
;      LOOK TO SEE IF AN ENDING MESSAGE IS SUPPLIED
;
STPR0::	JSB	PRTPG		;EJECT PRINTER
	TSTL	R9		;SKIP IF NO MESSAGE
	BEQLU	STPR1
	JSB	PRTST		;PRINT MESSAGE
;
;      MERGE HERE IF NO MESSAGE TO PRINT
;
STPR1::	JSB	PRTIS		;PRINT BLANK LINE
	MOVL	KVSTN,R5	;GET STATEMENT NUMBER
	MOVL	#STPM1,R9	;POINT TO MESSAGE /IN STATEMENT XXX/
	JSB	PRTMX		;PRINT IT
	JSB	SYSTM		;GET CURRENT TIME
	SUBL2	TIMSX,R5	;MINUS START TIME = ELAPSED EXEC TIM
	MOVL	R5,STPTI	;SAVE FOR LATER
	MOVL	#STPM3,R9	;POINT TO MSG /EXECUTION TIME MSEC /
	JSB	PRTMX		;PRINT IT
	MOVL	KVSTL,R5	;GET STATEMENT LIMIT
	BLSS	STPR2
	SUBL2	KVSTC,R5	;MINUS COUNTER = COUNT
	MOVL	R5,STPSI	;SAVE
	MOVL	#STPM2,R9	;POINT TO MESSAGE /STMTS EXECUTED/
	JSB	PRTMX		;PRINT IT
	MOVL	STPTI,R5	;RELOAD ELAPSED TIME
	MULL2	INTTH,R5	;*1000 (MICROSECS)
	BVS	STPR2
	DIVL2	STPSI,R5	;DIVIDE BY STATEMENT COUNT
	BVS	STPR2
	MOVL	#STPM4,R9	;POINT TO MSG (MCSEC PER STATEMENT /
	JSB	PRTMX		;PRINT IT
	.PAGE
;
;      STOPR (CONTINUED)
;
;      MERGE TO SKIP MESSAGE (OVERFLOW OR NEGATIVE STLIMIT)
;
STPR2::	MOVL	GBCNT,R5	;LOAD COUNT OF COLLECTIONS
	MOVL	#STPM5,R9	;POINT TO MESSAGE /REGENERATIONS /
	JSB	PRTMX		;PRINT IT
	JSB	PRTIS		;ONE MORE BLANK FOR LUCK
;
;      CHECK IF DUMP REQUESTED
;
	.IF NOT_EQUAL CNPF
STPR3::	MOVL	KVDMP,R9	;LOAD DUMP KEYWORD
	.IF_FALSE
STPR3::	JSB	PRFLR		;PRINT PROFILE IF WANTED
;
	MOVL	KVDMP,R9	;LOAD DUMP KEYWORD
	.ENDC
	JSB	DUMPR		;EXECUTE DUMP IF REQUESTED
	MOVL	R$FCB,R10	;GET FCBLK CHAIN HEAD
	MOVL	KVABE,R6	;LOAD ABEND VALUE
	MOVL	KVCOD,R7	;LOAD CODE VALUE
	JSB	SYSEJ		;EXIT TO SYSTEM
	.PAGE
;
;      SUCCP -- SIGNAL SUCCESSFUL MATCH OF A PATTERN NODE
;
;      SEE PATTERN MATCH ROUTINES FOR DETAILS
;
;      (XR)                  CURRENT NODE
;      (WB)                  CURRENT CURSOR
;      (XL)                  MAY BE NON-COLLECTABLE
;      BRN  SUCCP            SIGNAL SUCCESSFUL PATTERN MATCH
;
;      SUCCP CONTINUES BY MATCHING THE SUCCESSOR NODE
;
SUCCP::	;RTN
	MOVL	4*PTHEN(R9),R9	;LOAD SUCCESSOR NODE
	MOVL	(R9),R10	;LOAD NODE CODE ENTRY ADDRESS
	MOVL	R10,R11		;JUMP TO MATCH SUCCESSOR NODE
	JMP	(R11)
	.PAGE
;
;      SYSAB -- PRINT /ABNORMAL END/ AND TERMINATE
;
SYSAB::	;RTN
	MOVL	#ENDAB,R9	;POINT TO MESSAGE
	MOVL	#NUM01,KVABE	;SET ABEND FLAG
	JSB	PRTNL		;SKIP TO NEW LINE
	JMP	STOPR		;JUMP TO PACK UP
	.PAGE
;
;      SYSTU -- PRINT /TIME UP/ AND TERMINATE
;
SYSTU::	;RTN
	MOVL	#ENDTU,R9	;POINT TO MESSAGE
	MOVL	STRTU,R6	;GET CHARS /TU/
	MOVL	R6,KVCOD	;PUT IN KVCOD
	MOVL	TIMUP,R6	;CHECK STATE OF TIMEUP SWITCH
	MOVL	SP,TIMUP	;SET SWITCH
	TSTL	R6		;STOP RUN IF ALREADY SET
	BEQLU	5288$
	JMP	STOPR
5288$:
	JMP	ERROR_245	;TRANSLATION/EXECUTION TIME EXPIRED
	.PAGE
	.SUBTITLE S P I T B O L -- STACK OVERFLOW SECTION
;
;      CONTROL COMES HERE IF THE MAIN STACK OVERFLOWS
;
	.PAGE
ERR_ADDR::.ADDRESS ERROR$
ERROR_001::MOVZWL	#1,R6
	JMP	@ERR_ADDR
ERROR_002::MOVZWL	#2,R6
	JMP	@ERR_ADDR
ERROR_003::MOVZWL	#3,R6
	JMP	@ERR_ADDR
ERROR_004::MOVZWL	#4,R6
	JMP	@ERR_ADDR
ERROR_005::MOVZWL	#5,R6
	JMP	@ERR_ADDR
ERROR_006::MOVZWL	#6,R6
	JMP	@ERR_ADDR
ERROR_007::MOVZWL	#7,R6
	JMP	@ERR_ADDR
ERROR_008::MOVZWL	#8,R6
	JMP	@ERR_ADDR
ERROR_009::MOVZWL	#9,R6
	JMP	@ERR_ADDR
ERROR_010::MOVZWL	#10,R6
	JMP	@ERR_ADDR
ERROR_011::MOVZWL	#11,R6
	JMP	@ERR_ADDR
ERROR_012::MOVZWL	#12,R6
	JMP	@ERR_ADDR
ERROR_013::MOVZWL	#13,R6
	JMP	@ERR_ADDR
ERROR_014::MOVZWL	#14,R6
	JMP	@ERR_ADDR
ERROR_015::MOVZWL	#15,R6
	JMP	@ERR_ADDR
ERROR_016::MOVZWL	#16,R6
	JMP	@ERR_ADDR
ERROR_017::MOVZWL	#17,R6
	JMP	@ERR_ADDR
ERROR_018::MOVZWL	#18,R6
	JMP	@ERR_ADDR
ERROR_019::MOVZWL	#19,R6
	JMP	@ERR_ADDR
ERROR_020::MOVZWL	#20,R6
	JMP	@ERR_ADDR
ERROR_021::MOVZWL	#21,R6
	JMP	@ERR_ADDR
ERROR_022::MOVZWL	#22,R6
	JMP	@ERR_ADDR
ERROR_023::MOVZWL	#23,R6
	JMP	@ERR_ADDR
ERROR_024::MOVZWL	#24,R6
	JMP	@ERR_ADDR
ERROR_025::MOVZWL	#25,R6
	JMP	@ERR_ADDR
ERROR_026::MOVZWL	#26,R6
	JMP	@ERR_ADDR
ERROR_027::MOVZWL	#27,R6
	JMP	@ERR_ADDR
ERROR_028::MOVZWL	#28,R6
	JMP	@ERR_ADDR
ERROR_029::MOVZWL	#29,R6
	JMP	@ERR_ADDR
ERROR_030::MOVZWL	#30,R6
	JMP	@ERR_ADDR
ERROR_031::MOVZWL	#31,R6
	JMP	@ERR_ADDR
ERROR_032::MOVZWL	#32,R6
	JMP	@ERR_ADDR
ERROR_033::MOVZWL	#33,R6
	JMP	@ERR_ADDR
ERROR_034::MOVZWL	#34,R6
	JMP	@ERR_ADDR
ERROR_035::MOVZWL	#35,R6
	JMP	@ERR_ADDR
ERROR_036::MOVZWL	#36,R6
	JMP	@ERR_ADDR
ERROR_037::MOVZWL	#37,R6
	JMP	@ERR_ADDR
ERROR_038::MOVZWL	#38,R6
	JMP	@ERR_ADDR
ERROR_039::MOVZWL	#39,R6
	JMP	@ERR_ADDR
ERROR_040::MOVZWL	#40,R6
	JMP	@ERR_ADDR
ERROR_041::MOVZWL	#41,R6
	JMP	@ERR_ADDR
ERROR_042::MOVZWL	#42,R6
	JMP	@ERR_ADDR
ERROR_043::MOVZWL	#43,R6
	JMP	@ERR_ADDR
ERROR_044::MOVZWL	#44,R6
	JMP	@ERR_ADDR
ERROR_045::MOVZWL	#45,R6
	JMP	@ERR_ADDR
ERROR_046::MOVZWL	#46,R6
	JMP	@ERR_ADDR
ERROR_047::MOVZWL	#47,R6
	JMP	@ERR_ADDR
ERROR_048::MOVZWL	#48,R6
	JMP	@ERR_ADDR
ERROR_049::MOVZWL	#49,R6
	JMP	@ERR_ADDR
ERROR_050::MOVZWL	#50,R6
	JMP	@ERR_ADDR
ERROR_051::MOVZWL	#51,R6
	JMP	@ERR_ADDR
ERROR_052::MOVZWL	#52,R6
	JMP	@ERR_ADDR
ERROR_053::MOVZWL	#53,R6
	JMP	@ERR_ADDR
ERROR_054::MOVZWL	#54,R6
	JMP	@ERR_ADDR
ERROR_055::MOVZWL	#55,R6
	JMP	@ERR_ADDR
ERROR_056::MOVZWL	#56,R6
	JMP	@ERR_ADDR
ERROR_057::MOVZWL	#57,R6
	JMP	@ERR_ADDR
ERROR_058::MOVZWL	#58,R6
	JMP	@ERR_ADDR
ERROR_059::MOVZWL	#59,R6
	JMP	@ERR_ADDR
ERROR_060::MOVZWL	#60,R6
	JMP	@ERR_ADDR
ERROR_061::MOVZWL	#61,R6
	JMP	@ERR_ADDR
ERROR_062::MOVZWL	#62,R6
	JMP	@ERR_ADDR
ERROR_063::MOVZWL	#63,R6
	JMP	@ERR_ADDR
ERROR_064::MOVZWL	#64,R6
	JMP	@ERR_ADDR
ERROR_065::MOVZWL	#65,R6
	JMP	@ERR_ADDR
ERROR_066::MOVZWL	#66,R6
	JMP	@ERR_ADDR
ERROR_067::MOVZWL	#67,R6
	JMP	@ERR_ADDR
ERROR_068::MOVZWL	#68,R6
	JMP	@ERR_ADDR
ERROR_069::MOVZWL	#69,R6
	JMP	@ERR_ADDR
ERROR_070::MOVZWL	#70,R6
	JMP	@ERR_ADDR
ERROR_071::MOVZWL	#71,R6
	JMP	@ERR_ADDR
ERROR_072::MOVZWL	#72,R6
	JMP	@ERR_ADDR
ERROR_073::MOVZWL	#73,R6
	JMP	@ERR_ADDR
ERROR_074::MOVZWL	#74,R6
	JMP	@ERR_ADDR
ERROR_075::MOVZWL	#75,R6
	JMP	@ERR_ADDR
ERROR_076::MOVZWL	#76,R6
	JMP	@ERR_ADDR
ERROR_077::MOVZWL	#77,R6
	JMP	@ERR_ADDR
ERROR_078::MOVZWL	#78,R6
	JMP	@ERR_ADDR
ERROR_079::MOVZWL	#79,R6
	JMP	@ERR_ADDR
ERROR_080::MOVZWL	#80,R6
	JMP	@ERR_ADDR
ERROR_081::MOVZWL	#81,R6
	JMP	@ERR_ADDR
ERROR_082::MOVZWL	#82,R6
	JMP	@ERR_ADDR
ERROR_083::MOVZWL	#83,R6
	JMP	@ERR_ADDR
ERROR_084::MOVZWL	#84,R6
	JMP	@ERR_ADDR
ERROR_085::MOVZWL	#85,R6
	JMP	@ERR_ADDR
ERROR_086::MOVZWL	#86,R6
	JMP	@ERR_ADDR
ERROR_087::MOVZWL	#87,R6
	JMP	@ERR_ADDR
ERROR_088::MOVZWL	#88,R6
	JMP	@ERR_ADDR
ERROR_089::MOVZWL	#89,R6
	JMP	@ERR_ADDR
ERROR_090::MOVZWL	#90,R6
	JMP	@ERR_ADDR
ERROR_091::MOVZWL	#91,R6
	JMP	@ERR_ADDR
ERROR_092::MOVZWL	#92,R6
	JMP	@ERR_ADDR
ERROR_093::MOVZWL	#93,R6
	JMP	@ERR_ADDR
ERROR_094::MOVZWL	#94,R6
	JMP	@ERR_ADDR
ERROR_095::MOVZWL	#95,R6
	JMP	@ERR_ADDR
ERROR_096::MOVZWL	#96,R6
	JMP	@ERR_ADDR
ERROR_097::MOVZWL	#97,R6
	JMP	@ERR_ADDR
ERROR_098::MOVZWL	#98,R6
	JMP	@ERR_ADDR
ERROR_099::MOVZWL	#99,R6
	JMP	@ERR_ADDR
ERROR_100::MOVZWL	#100,R6
	JMP	@ERR_ADDR
ERROR_101::MOVZWL	#101,R6
	JMP	@ERR_ADDR
ERROR_102::MOVZWL	#102,R6
	JMP	@ERR_ADDR
ERROR_103::MOVZWL	#103,R6
	JMP	@ERR_ADDR
ERROR_104::MOVZWL	#104,R6
	JMP	@ERR_ADDR
ERROR_105::MOVZWL	#105,R6
	JMP	@ERR_ADDR
ERROR_106::MOVZWL	#106,R6
	JMP	@ERR_ADDR
ERROR_107::MOVZWL	#107,R6
	JMP	@ERR_ADDR
ERROR_108::MOVZWL	#108,R6
	JMP	@ERR_ADDR
ERROR_109::MOVZWL	#109,R6
	JMP	@ERR_ADDR
ERROR_110::MOVZWL	#110,R6
	JMP	@ERR_ADDR
ERROR_111::MOVZWL	#111,R6
	JMP	@ERR_ADDR
ERROR_112::MOVZWL	#112,R6
	JMP	@ERR_ADDR
ERROR_113::MOVZWL	#113,R6
	JMP	@ERR_ADDR
ERROR_114::MOVZWL	#114,R6
	JMP	@ERR_ADDR
ERROR_115::MOVZWL	#115,R6
	JMP	@ERR_ADDR
ERROR_116::MOVZWL	#116,R6
	JMP	@ERR_ADDR
ERROR_117::MOVZWL	#117,R6
	JMP	@ERR_ADDR
ERROR_118::MOVZWL	#118,R6
	JMP	@ERR_ADDR
ERROR_119::MOVZWL	#119,R6
	JMP	@ERR_ADDR
ERROR_120::MOVZWL	#120,R6
	JMP	@ERR_ADDR
ERROR_121::MOVZWL	#121,R6
	JMP	@ERR_ADDR
ERROR_122::MOVZWL	#122,R6
	JMP	@ERR_ADDR
ERROR_123::MOVZWL	#123,R6
	JMP	@ERR_ADDR
ERROR_124::MOVZWL	#124,R6
	JMP	@ERR_ADDR
ERROR_125::MOVZWL	#125,R6
	JMP	@ERR_ADDR
ERROR_126::MOVZWL	#126,R6
	JMP	@ERR_ADDR
ERROR_127::MOVZWL	#127,R6
	JMP	@ERR_ADDR
ERROR_128::MOVZWL	#128,R6
	JMP	@ERR_ADDR
ERROR_129::MOVZWL	#129,R6
	JMP	@ERR_ADDR
ERROR_130::MOVZWL	#130,R6
	JMP	@ERR_ADDR
ERROR_131::MOVZWL	#131,R6
	JMP	@ERR_ADDR
ERROR_132::MOVZWL	#132,R6
	JMP	@ERR_ADDR
ERROR_133::MOVZWL	#133,R6
	JMP	@ERR_ADDR
ERROR_134::MOVZWL	#134,R6
	JMP	@ERR_ADDR
ERROR_135::MOVZWL	#135,R6
	JMP	@ERR_ADDR
ERROR_136::MOVZWL	#136,R6
	JMP	@ERR_ADDR
ERROR_137::MOVZWL	#137,R6
	JMP	@ERR_ADDR
ERROR_138::MOVZWL	#138,R6
	JMP	@ERR_ADDR
ERROR_139::MOVZWL	#139,R6
	JMP	@ERR_ADDR
ERROR_140::MOVZWL	#140,R6
	JMP	@ERR_ADDR
ERROR_141::MOVZWL	#141,R6
	JMP	@ERR_ADDR
ERROR_142::MOVZWL	#142,R6
	JMP	@ERR_ADDR
ERROR_143::MOVZWL	#143,R6
	JMP	@ERR_ADDR
ERROR_144::MOVZWL	#144,R6
	JMP	@ERR_ADDR
ERROR_145::MOVZWL	#145,R6
	JMP	@ERR_ADDR
ERROR_146::MOVZWL	#146,R6
	JMP	@ERR_ADDR
ERROR_147::MOVZWL	#147,R6
	JMP	@ERR_ADDR
ERROR_148::MOVZWL	#148,R6
	JMP	@ERR_ADDR
ERROR_149::MOVZWL	#149,R6
	JMP	@ERR_ADDR
ERROR_150::MOVZWL	#150,R6
	JMP	@ERR_ADDR
ERROR_151::MOVZWL	#151,R6
	JMP	@ERR_ADDR
ERROR_152::MOVZWL	#152,R6
	JMP	@ERR_ADDR
ERROR_153::MOVZWL	#153,R6
	JMP	@ERR_ADDR
ERROR_154::MOVZWL	#154,R6
	JMP	@ERR_ADDR
ERROR_155::MOVZWL	#155,R6
	JMP	@ERR_ADDR
ERROR_156::MOVZWL	#156,R6
	JMP	@ERR_ADDR
ERROR_157::MOVZWL	#157,R6
	JMP	@ERR_ADDR
ERROR_158::MOVZWL	#158,R6
	JMP	@ERR_ADDR
ERROR_159::MOVZWL	#159,R6
	JMP	@ERR_ADDR
ERROR_160::MOVZWL	#160,R6
	JMP	@ERR_ADDR
ERROR_161::MOVZWL	#161,R6
	JMP	@ERR_ADDR
ERROR_162::MOVZWL	#162,R6
	JMP	@ERR_ADDR
ERROR_163::MOVZWL	#163,R6
	JMP	@ERR_ADDR
ERROR_164::MOVZWL	#164,R6
	JMP	@ERR_ADDR
ERROR_165::MOVZWL	#165,R6
	JMP	@ERR_ADDR
ERROR_166::MOVZWL	#166,R6
	JMP	@ERR_ADDR
ERROR_167::MOVZWL	#167,R6
	JMP	@ERR_ADDR
ERROR_168::MOVZWL	#168,R6
	JMP	@ERR_ADDR
ERROR_169::MOVZWL	#169,R6
	JMP	@ERR_ADDR
ERROR_170::MOVZWL	#170,R6
	JMP	@ERR_ADDR
ERROR_171::MOVZWL	#171,R6
	JMP	@ERR_ADDR
ERROR_172::MOVZWL	#172,R6
	JMP	@ERR_ADDR
ERROR_173::MOVZWL	#173,R6
	JMP	@ERR_ADDR
ERROR_174::MOVZWL	#174,R6
	JMP	@ERR_ADDR
ERROR_175::MOVZWL	#175,R6
	JMP	@ERR_ADDR
ERROR_176::MOVZWL	#176,R6
	JMP	@ERR_ADDR
ERROR_177::MOVZWL	#177,R6
	JMP	@ERR_ADDR
ERROR_178::MOVZWL	#178,R6
	JMP	@ERR_ADDR
ERROR_179::MOVZWL	#179,R6
	JMP	@ERR_ADDR
ERROR_180::MOVZWL	#180,R6
	JMP	@ERR_ADDR
ERROR_181::MOVZWL	#181,R6
	JMP	@ERR_ADDR
ERROR_182::MOVZWL	#182,R6
	JMP	@ERR_ADDR
ERROR_183::MOVZWL	#183,R6
	JMP	@ERR_ADDR
ERROR_184::MOVZWL	#184,R6
	JMP	@ERR_ADDR
ERROR_185::MOVZWL	#185,R6
	JMP	@ERR_ADDR
ERROR_186::MOVZWL	#186,R6
	JMP	@ERR_ADDR
ERROR_187::MOVZWL	#187,R6
	JMP	@ERR_ADDR
ERROR_188::MOVZWL	#188,R6
	JMP	@ERR_ADDR
ERROR_189::MOVZWL	#189,R6
	JMP	@ERR_ADDR
ERROR_190::MOVZWL	#190,R6
	JMP	@ERR_ADDR
ERROR_191::MOVZWL	#191,R6
	JMP	@ERR_ADDR
ERROR_192::MOVZWL	#192,R6
	JMP	@ERR_ADDR
ERROR_193::MOVZWL	#193,R6
	JMP	@ERR_ADDR
ERROR_194::MOVZWL	#194,R6
	JMP	@ERR_ADDR
ERROR_195::MOVZWL	#195,R6
	JMP	@ERR_ADDR
ERROR_196::MOVZWL	#196,R6
	JMP	@ERR_ADDR
ERROR_197::MOVZWL	#197,R6
	JMP	@ERR_ADDR
ERROR_198::MOVZWL	#198,R6
	JMP	@ERR_ADDR
ERROR_199::MOVZWL	#199,R6
	JMP	@ERR_ADDR
ERROR_200::MOVZWL	#200,R6
	JMP	@ERR_ADDR
ERROR_201::MOVZWL	#201,R6
	JMP	@ERR_ADDR
ERROR_202::MOVZWL	#202,R6
	JMP	@ERR_ADDR
ERROR_203::MOVZWL	#203,R6
	JMP	@ERR_ADDR
ERROR_204::MOVZWL	#204,R6
	JMP	@ERR_ADDR
ERROR_205::MOVZWL	#205,R6
	JMP	@ERR_ADDR
ERROR_206::MOVZWL	#206,R6
	JMP	@ERR_ADDR
ERROR_207::MOVZWL	#207,R6
	JMP	@ERR_ADDR
ERROR_208::MOVZWL	#208,R6
	JMP	@ERR_ADDR
ERROR_209::MOVZWL	#209,R6
	JMP	@ERR_ADDR
ERROR_210::MOVZWL	#210,R6
	JMP	@ERR_ADDR
ERROR_211::MOVZWL	#211,R6
	JMP	@ERR_ADDR
ERROR_212::MOVZWL	#212,R6
	JMP	@ERR_ADDR
ERROR_213::MOVZWL	#213,R6
	JMP	@ERR_ADDR
ERROR_214::MOVZWL	#214,R6
	JMP	@ERR_ADDR
ERROR_215::MOVZWL	#215,R6
	JMP	@ERR_ADDR
ERROR_216::MOVZWL	#216,R6
	JMP	@ERR_ADDR
ERROR_217::MOVZWL	#217,R6
	JMP	@ERR_ADDR
ERROR_218::MOVZWL	#218,R6
	JMP	@ERR_ADDR
ERROR_219::MOVZWL	#219,R6
	JMP	@ERR_ADDR
ERROR_220::MOVZWL	#220,R6
	JMP	@ERR_ADDR
ERROR_221::MOVZWL	#221,R6
	JMP	@ERR_ADDR
ERROR_222::MOVZWL	#222,R6
	JMP	@ERR_ADDR
ERROR_223::MOVZWL	#223,R6
	JMP	@ERR_ADDR
ERROR_224::MOVZWL	#224,R6
	JMP	@ERR_ADDR
ERROR_225::MOVZWL	#225,R6
	JMP	@ERR_ADDR
ERROR_226::MOVZWL	#226,R6
	JMP	@ERR_ADDR
ERROR_227::MOVZWL	#227,R6
	JMP	@ERR_ADDR
ERROR_228::MOVZWL	#228,R6
	JMP	@ERR_ADDR
ERROR_229::MOVZWL	#229,R6
	JMP	@ERR_ADDR
ERROR_230::MOVZWL	#230,R6
	JMP	@ERR_ADDR
ERROR_231::MOVZWL	#231,R6
	JMP	@ERR_ADDR
ERROR_232::MOVZWL	#232,R6
	JMP	@ERR_ADDR
ERROR_233::MOVZWL	#233,R6
	JMP	@ERR_ADDR
ERROR_234::MOVZWL	#234,R6
	JMP	@ERR_ADDR
ERROR_235::MOVZWL	#235,R6
	JMP	@ERR_ADDR
ERROR_236::MOVZWL	#236,R6
	JMP	@ERR_ADDR
ERROR_237::MOVZWL	#237,R6
	JMP	@ERR_ADDR
ERROR_238::MOVZWL	#238,R6
	JMP	@ERR_ADDR
ERROR_239::MOVZWL	#239,R6
	JMP	@ERR_ADDR
ERROR_240::MOVZWL	#240,R6
	JMP	@ERR_ADDR
ERROR_241::MOVZWL	#241,R6
	JMP	@ERR_ADDR
ERROR_242::MOVZWL	#242,R6
	JMP	@ERR_ADDR
ERROR_243::MOVZWL	#243,R6
	JMP	@ERR_ADDR
ERROR_244::MOVZWL	#244,R6
	JMP	@ERR_ADDR
ERROR_245::MOVZWL	#245,R6
	JMP	@ERR_ADDR
ERROR_246::MOVZWL	#246,R6
	JMP	@ERR_ADDR
ERROR_247::MOVZWL	#247,R6
	JMP	@ERR_ADDR
ERROR_248::MOVZWL	#248,R6
	JMP	@ERR_ADDR
ERROR_249::MOVZWL	#249,R6
	JMP	@ERR_ADDR
ERROR_250::MOVZWL	#250,R6
	JMP	@ERR_ADDR
ERROR_251::MOVZWL	#251,R6
	JMP	@ERR_ADDR
ERROR_252::MOVZWL	#252,R6
	JMP	@ERR_ADDR
ERROR_253::MOVZWL	#253,R6
	JMP	@ERR_ADDR
ERROR_254::MOVZWL	#254,R6
	JMP	@ERR_ADDR
ERROR_255::MOVZWL	#255,R6
	JMP	@ERR_ADDR
ERROR_256::MOVZWL	#256,R6
	JMP	@ERR_ADDR
ERROR_257::MOVZWL	#257,R6
	JMP	@ERR_ADDR
ERROR_258::MOVZWL	#258,R6
	JMP	@ERR_ADDR
ERROR_259::MOVZWL	#259,R6
	JMP	@ERR_ADDR
ERROR_260::MOVZWL	#260,R6
	JMP	@ERR_ADDR
ERROR_261::MOVZWL	#261,R6
	JMP	@ERR_ADDR
ERROR_262::MOVZWL	#262,R6
	JMP	@ERR_ADDR
ERROR_263::MOVZWL	#263,R6
	JMP	@ERR_ADDR
ERROR_264::MOVZWL	#264,R6
	JMP	@ERR_ADDR
ERROR_265::MOVZWL	#265,R6
	JMP	@ERR_ADDR
ERROR_266::MOVZWL	#266,R6
	JMP	@ERR_ADDR
ERROR_267::MOVZWL	#267,R6
	JMP	@ERR_ADDR
ERROR_268::MOVZWL	#268,R6
	JMP	@ERR_ADDR
	SEC			;START OF STACK OVERFLOW SECTION
;
	INCL	ERRFT		;FATAL ERROR
	MOVL	FLPTR,SP	;POP STACK TO AVOID MORE FAILS
	TSTL	GBCFL		;JUMP IF GARBAGE COLLECTING
	BNEQU	STAK1
	JMP	ERROR_246	;STACK OVERFLOW
;
;      NO CHANCE OF RECOVERY IN MID GARBAGE COLLECTION
;
STAK1::	MOVL	#ENDSO,R9	;POINT TO MESSAGE
	CLRL	KVDMP		;MEMORY IS UNDUMPABLE
	JMP	STOPR		;GIVE UP
	.PAGE
	.SUBTITLE S P I T B O L -- ERROR SECTION
;
;      THIS SECTION OF CODE IS ENTERED WHENEVER A PROCEDURE
;      RETURN VIA AN ERR PARAMETER OR AN ERB OPCODE IS OBEYED.
;
;      (WA)                  IS THE ERROR CODE
;
;      THE GLOBAL VARIABLE STAGE INDICATES THE POINT AT WHICH
;      THE ERROR OCCURED AS FOLLOWS.
;
;      STAGE=STGIC           ERROR DURING INITIAL COMPILE
;
;      STAGE=STGXC           ERROR DURING COMPILE AT EXECUTE
;                            TIME (CODE, CONVERT FUNCTION CALLS)
;
;      STAGE=STGEV           ERROR DURING COMPILATION OF
;                            EXPRESSION AT EXECUTION TIME
;                            (EVAL, CONVERT FUNCTION CALL).
;
;      STAGE=STGXT           ERROR AT EXECUTE TIME. COMPILER
;                            NOT ACTIVE.
;
;      STAGE=STGCE           ERROR DURING INITIAL COMPILE AFTER
;                            SCANNING OUT THE END LINE.
;
;      STAGE=STGXE           ERROR DURING COMPILE AT EXECUTE
;                            TIME AFTER SCANNING END LINE.
;
;      STAGE=STGEE           ERROR DURING EXPRESSION EVALUATION
;
	SEC			;START OF ERROR SECTION
;
ERROR::	CMPL	R$CIM,#CMLAB	;JUMP IF ERROR IN SCANNING LABEL
	BNEQU	5289$
	JMP	CMPLE
5289$:
	MOVL	R6,KVERT	;SAVE ERROR CODE
	CLRL	SCNRS		;RESET RESCAN SWITCH FOR SCANE
	CLRL	SCNGO		;RESET GOTO SWITCH FOR SCANE
	MOVL	STAGE,R9	;LOAD CURRENT STAGE
	BSW	R9,STGNO	;JUMP TO APPROPRIATE ERROR CIRCUIT
	IFF	STGIC,ERR01	;INITIAL COMPILE
	IFF	STGXC,ERR04	;EXECUTE TIME COMPILE
	IFF	STGEV,ERR04	;EVAL COMPILING EXPR.
	IFF	STGEE,ERR04	;EVAL EVALUATING EXPR
	IFF	STGXT,ERR05	;EXECUTE TIME
	IFF	STGCE,ERR01	;COMPILE - AFTER END
	IFF	STGXE,ERR04	;XEQ COMPILE-PAST END
	ESW			;END SWITCH ON ERROR TYPE
	.PAGE
;
;      ERROR DURING INITIAL COMPILE
;
;      THE ERROR MESSAGE IS PRINTED AS PART OF THE COMPILER
;      OUTPUT. THIS PRINTOUT INCLUDES THE OFFENDING LINE (IF NOT
;      PRINTED ALREADY) AND AN ERROR FLAG UNDER THE APPROPRIATE
;      COLUMN AS INDICATED BY SCNSE UNLESS SCNSE IS SET TO ZERO.
;
;      AFTER PRINTING THE MESSAGE, THE GENERATED CODE IS
;      MODIFIED TO AN ERROR CALL AND CONTROL IS RETURNED TO
;      THE CMPIL PROCEDURE AFTER RESETTING THE STACK POINTER.
;
;      IF THE ERROR OCCURS AFTER THE END LINE, CONTROL RETURNS
;      IN A SLIGHTLY DIFFERENT MANNER TO ENSURE PROPER CLEANUP.
;
ERR01::	MOVL	CMPXS,SP	;RESET STACK POINTER
	;SSL	CMPSS		;RESTORE S-R STACK PTR FOR CMPIL
	TSTL	ERRSP		;JUMP IF ERROR SUPPRESS FLAG SET
	BEQLU	5290$
	JMP	ERR03
5290$:
	MOVL	ERICH,ERLST	;SET FLAG FOR LISTR
	JSB	LISTR		;LIST LINE
	JSB	PRTIS		;TERMINATE LISTING
	CLRL	ERLST		;CLEAR LISTR FLAG
	MOVL	SCNSE,R6	;LOAD SCAN ELEMENT OFFSET
	BEQLU	ERR02
	.IF NOT_EQUAL CAHT
	MOVL	R6,R7		;LOOP COUNTER
	INCL	R6		;INCREASE FOR CH$EX
	JSB	ALOCS		;STRING BLOCK FOR ERROR FLAG
	MOVL	R9,R6		;REMEMBER STRING PTR
	MOVAB	CFP$F(R9),R9	;READY FOR CHARACTER STORING
	MOVL	R$CIM,R10	;POINT TO BAD STATEMENT
	MOVAB	CFP$F(R10),R10	;READY TO GET CHARS
;
;      LOOP TO REPLACE ALL CHARS BUT TABS BY BLANKS
;
ERRA1::	MOVZBL	(R10)+,R8	;GET NEXT CHAR
	CMPL	R8,#CH$HT	;SKIP IF TAB
	BEQLU	ERRA2
	MOVL	#CH$BL,R8	;GET A BLANK
	.PAGE
;
;      MERGE TO STORE BLANK OR TAB IN ERROR LINE
;
ERRA2::	MOVB	R8,(R9)+	;STORE CHAR
	SOBGTR	R7,ERRA1	;LOOP
	MOVL	#CH$EX,R10	;EXCLAMATION MARK
	MOVB	R10,(R9)	;STORE AT END OF ERROR LINE
	;CSC	R9		;END OF SCH LOOP
	MOVL	#STNPD,PROFS	;ALLOW FOR STATEMENT NUMBER
	MOVL	R6,R9		;POINT TO ERROR LINE
	JSB	PRTST		;PRINT ERROR LINE
	.IF_FALSE
	MOVL	PRLEN,R5	;GET PRINT BUFFER LENGTH
	MFI	GTNSI		;STORE AS SIGNED INTEGER
	ADDL2	#STNPD,R6	;ADJUST FOR STATEMENT NUMBER
	MOVL	R6,R5		;COPY TO INTEGER ACCUMULATOR
	RMI	GTNSI		;REMAINDER MODULO PRINT BFR LENGTH
	MOVL	R5,PROFS	;USE AS CHARACTER OFFSET
	MOVL	#CH$EX,R6	;GET EXCLAMATION MARK
	JSB	PRTCH		;GENERATE UNDER BAD COLUMN
	.ENDC
;
;      HERE AFTER PLACING ERROR FLAG AS REQUIRED
;
ERR02::	JSB	ERMSG		;GENERATE FLAG AND ERROR MESSAGE
	ADDL2	#NUM03,LSTLC	;BUMP PAGE CTR FOR BLANK, ERROR, BLK
	CLRL	R9		;IN CASE OF FATAL ERROR
	CMPL	ERRFT,#NUM03	;PACK UP IF SEVERAL FATALS
	BLSSU	5291$
	JMP	STOPR
5291$:
;
;      COUNT ERROR, INHIBIT EXECUTION IF REQUIRED
;
	INCL	CMERC		;BUMP ERROR COUNT
	ADDL2	CSWER,NOXEQ	;INHIBIT XEQ IF -NOERRORS
	CMPL	STAGE,#STGIC	;SPECIAL RETURN IF AFTER END LINE
	BEQLU	5292$
	JMP	CMP10
5292$:
	.PAGE
;
;      LOOP TO SCAN TO END OF STATEMENT
;
ERR03::	MOVL	R$CIM,R9	;POINT TO START OF IMAGE
	MOVAB	CFP$F(R9),R9	;POINT TO FIRST CHAR
	MOVZBL	(R9),R9		;GET FIRST CHAR
	CMPL	R9,#CH$MN	;JUMP IF ERROR IN CONTROL CARD
	BNEQU	5293$
	JMP	CMPCE
5293$:
	CLRL	SCNRS		;CLEAR RESCAN FLAG
	MOVL	SP,ERRSP	;SET ERROR SUPPRESS FLAG
	JSB	SCANE		;SCAN NEXT ELEMENT
	CMPL	R10,#T$SMC	;LOOP BACK IF NOT STATEMENT END
	BEQLU	5294$
	JMP	ERR03
5294$:
	CLRL	ERRSP		;CLEAR ERROR SUPPRESS FLAG
;
;      GENERATE ERROR CALL IN CODE AND RETURN TO CMPIL
;
	MOVL	#4*CDCOD,CWCOF	;RESET OFFSET IN CCBLK
	MOVL	#OCER$,R6	;LOAD COMPILE ERROR CALL
	JSB	CDWRD		;GENERATE IT
	MOVL	CWCOF,4*CMSOC(SP);SET SUCCESS FILL IN OFFSET
	MOVL	SP,4*CMFFC(SP)	;SET FAILURE FILL IN FLAG
	JSB	CDWRD		;GENERATE SUCC. FILL IN WORD
	JMP	CMPSE		;MERGE TO GENERATE ERROR AS CDFAL
;
;      ERROR DURING EXECUTE TIME COMPILE OR EXPRESSION EVALUATIO
;
;      EXECUTE TIME COMPILATION IS INITIATED THROUGH GTCOD OR
;      GTEXP WHICH ARE CALLED BY COMPILE, CODE OR EVAL.
;      BEFORE CAUSING STATEMENT FAILURE THROUGH EXFAL IT IS
;      HELPFUL TO SET KEYWORD ERRTEXT AND FOR GENERALITY
;      THESE ERRORS MAY BE HANDLED BY THE SETEXIT MECHANISM.
;
ERR04::	CLRL	R$CCB		;FORGET GARBAGE CODE BLOCK
	;SSL	INISS		;RESTORE MAIN PROG S-R STACK PTR
	JSB	ERTEX		;GET FAIL MESSAGE TEXT
	SUBL2	#4,SP		;ENSURE STACK OK ON LOOP START
;
;      POP STACK UNTIL FIND FLPTR FOR MOST DEEPLY NESTED PROG.
;      DEFINED FUNCTION CALL OR CALL OF EVAL / CODE.
;
ERRA4::	ADDL2	#4,SP		;POP STACK
	CMPL	SP,FLPRT	;JUMP IF PROG DEFINED FN CALL FOUND
	BEQLU	ERRC4
	CMPL	SP,GTCEF	;LOOP IF NOT EVAL OR CODE CALL YET
	BNEQU	ERRA4
	MOVL	#STGXT,STAGE	;RE-SET STAGE FOR EXECUTE
	MOVL	R$GTC,R$COD	;RECOVER CODE PTR
	MOVL	SP,FLPTR	;RESTORE FAIL POINTER
	CLRL	R$CIM		;FORGET POSSIBLE IMAGE
;
;      TEST ERRLIMIT
;
ERRB4::	TSTL	KVERL		;JUMP IF ERRLIMIT NON-ZERO
	BNEQU	ERR07
	JMP	EXFAL		;FAIL
;
;      RETURN FROM PROG. DEFINED FUNCTION IS OUTSTANDING
;
ERRC4::	MOVL	FLPTR,SP	;RESTORE STACK FROM FLPTR
	JMP	ERRB4		;MERGE
	.PAGE
;
;      ERROR AT EXECUTE TIME.
;
;      THE ACTION TAKEN ON AN ERROR IS AS FOLLOWS.
;
;      IF ERRLIMIT KEYWORD IS ZERO, AN ABORT IS SIGNALLED,
;      SEE CODING FOR SYSTEM LABEL ABORT AT L$ABO.
;
;      OTHERWISE, ERRLIMIT IS DECREMENTED AND AN ERRTYPE TRACE
;      GENERATED IF REQUIRED. CONTROL RETURNS EITHER VIA A JUMP
;      TO CONTINUE (TO TAKE THE FAILURE EXIT) OR A SPECIFIED
;      SETEXIT TRAP IS EXECUTED AND CONTROL PASSES TO THE TRAP.
;      IF 3 OR MORE FATAL ERRORS OCCUR AN ABORT IS SIGNALLED
;      REGARDLESS OF ERRLIMIT AND SETEXIT - LOOPING IS ALL TOO
;      PROBABLE OTHERWISE. FATAL ERRORS INCLUDE STACK OVERFLOW
;      AND EXCEEDING STLIMIT.
;
ERR05::	;SSL	INISS		;RESTORE MAIN PROG S-R STACK PTR
	TSTL	DMVCH		;JUMP IF IN MID-DUMP
	BNEQU	ERR08
;
;      MERGE HERE FROM ERR08
;
ERR06::	TSTL	KVERL		;ABORT IF ERRLIMIT IS ZERO
	BNEQU	5295$
	JMP	LABO1
5295$:
	JSB	ERTEX		;GET FAIL MESSAGE TEXT
;
;      MERGE FROM ERR04
;
ERR07::	CMPL	ERRFT,#NUM03	;ABORT IF TOO MANY FATAL ERRORS
	BLSSU	5296$
	JMP	LABO1
5296$:
	DECL	KVERL		;DECREMENT ERRLIMIT
	MOVL	R$ERT,R10	;LOAD ERRTYPE TRACE POINTER
	JSB	KTREX		;GENERATE ERRTYPE TRACE IF REQUIRED
	MOVL	R$COD,R$CNT	;SET CDBLK PTR FOR CONTINUATION
	MOVL	FLPTR,R9	;SET PTR TO FAILURE OFFSET
	MOVL	(R9),STXOF	;SAVE FAILURE OFFSET FOR CONTINUE
	MOVL	R$SXC,R9	;LOAD SETEXIT CDBLK POINTER
	BNEQU	5297$
	JMP	LCNT1
5297$:
	CLRL	R$SXC		;ELSE RESET TRAP
	MOVL	#NULLS,STXVR	;RESET SETEXIT ARG TO NULL
	MOVL	(R9),R10	;LOAD PTR TO CODE BLOCK ROUTINE
	MOVL	R10,R11		;EXECUTE FIRST TRAP STATEMENT
	JMP	(R11)
;
;      INTERRUPTED PARTLY THROUGH A DUMP WHILST STORE IS IN A
;      MESS SO DO A TIDY UP OPERATION. SEE DUMPR FOR DETAILS.
;
ERR08::	MOVL	DMVCH,R9	;CHAIN HEAD FOR AFFECTED VRBLKS
	BEQLU	ERR06
	MOVL	(R9),DMVCH	;SET NEXT LINK AS CHAIN HEAD
	JSB	SETVR		;RESTORE VRGET FIELD
	JMP	ERR08		;LOOP THROUGH CHAIN
	.PAGE
	.SUBTITLE S P I T B O L -- HERE ENDETH THE CODE
;
;      END OF ASSEMBLY
;
	.END			;END MACRO-SPITBOL ASSEMBLY
